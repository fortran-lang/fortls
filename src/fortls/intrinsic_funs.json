{
  "ABORT": {
    "doc": "ABORT causes immediate termination of the program.",
    "type": 2
  },
  "ABS": {
    "args": "A",
    "doc": "ABS(A) computes the absolute value of A.",
    "type": 3
  },
  "ACCESS": {
    "args": "NAME,MODE",
    "doc": "ACCESS(NAME,MODE) checks whether the file NAME exists, is readable, writable or executable.",
    "type": 3
  },
  "ACHAR": {
    "args": "I,KIND=kind",
    "doc": "ACHAR(I,KIND=kind) returns the character located at position I in the ASCII collating sequence.",
    "type": 3
  },
  "ACOS": {
    "args": "X",
    "doc": "ACOS(X) computes the arccosine of X (inverse of COS(X)).",
    "type": 3
  },
  "ACOSD": {
    "args": "X",
    "doc": "ACOSD(X) computes the arccosine of X in degrees (inverse of COSD(X).",
    "type": 3
  },
  "ACOSH": {
    "args": "X",
    "doc": "ACOSH(X) computes the inverse hyperbolic cosine of X.",
    "type": 3
  },
  "ADJUSTL": {
    "args": "STRING",
    "doc": "ADJUSTL(STRING) will left adjust a string by removing leading spaces.",
    "type": 3
  },
  "ADJUSTR": {
    "args": "STRING",
    "doc": "ADJUSTR(STRING) will right adjust a string by removing trailing spaces.",
    "type": 3
  },
  "AIMAG": {
    "args": "Z",
    "doc": "AIMAG(Z) yields the imaginary part of complex argument Z.",
    "type": 3
  },
  "AINT": {
    "args": "A,KIND=kind",
    "doc": "AINT(A,KIND=kind) truncates its argument to a whole number.",
    "type": 3
  },
  "ALARM": {
    "args": "SECONDS,HANDLER,STATUS=status",
    "doc": "ALARM(SECONDS,HANDLER,STATUS=status) causes external subroutine HANDLER to be executed after a delay of SECONDS by using alarm(2) to set up a signal and signal(2) to catch it. If STATUS is supplied, it will be returned with the number of seconds remaining until any previously scheduled alarm was due to be delivered, or zero if there was no previously scheduled alarm.",
    "type": 2
  },
  "ALL": {
    "args": "MASK,DIM=dim",
    "doc": "ALL(MASK,DIM=dim) determines if all the values are true in MASK in the array along dimension DIM.",
    "type": 3
  },
  "ALLOCATED": {
    "args": "A",
    "doc": "ALLOCATED(A) check the allocation status of A.",
    "type": 3
  },
  "ANINT": {
    "args": "A,KIND=kind",
    "doc": "ANINT(A,KIND=kind) rounds its argument to the nearest whole number.",
    "type": 3
  },
  "ANY": {
    "args": "MASK,DIM=dim",
    "doc": "ANY(MASK,DIM=dim) determines if any of the values are true in MASK in the array along dimension DIM.",
    "type": 3
  },
  "ASIN": {
    "args": "X",
    "doc": "ASIN(X) computes the arcsine of X (inverse of SIN(X)).",
    "type": 3
  },
  "ASIND": {
    "args": "X",
    "doc": "ASIND(X) computes the arcsine of its X in degrees (inverse of SIND(X)).",
    "type": 3
  },
  "ASINH": {
    "args": "X",
    "doc": "ASINH(X) computes the inverse hyperbolic sine of X.",
    "type": 3
  },
  "ASSOCIATED": {
    "args": "POINTER,TARGET=target",
    "doc": "ASSOCIATED(POINTER,TARGET=target) determines the status of the pointer POINTER or if POINTER is associated with the target TARGET.",
    "type": 3
  },
  "ATAN": {
    "args": "X",
    "doc": "ATAN(X) computes the arctangent of X (inverse of TAN(X)).",
    "type": 3
  },
  "ATAND": {
    "args": "X",
    "doc": "ATAND(X) computes the arctangent of X in degrees (inverse of TAND).",
    "type": 3
  },
  "ATAN2": {
    "args": "Y,X",
    "doc": "ATAN2(Y,X) computes the principal value of the argument function of the complex number X + i Y.",
    "type": 3
  },
  "ATAN2D": {
    "args": "Y,X",
    "doc": "ATAN2D(Y,X) computes the principal value of the argument function of the complex number X + i Y in degrees.",
    "type": 3
  },
  "ATANH": {
    "args": "X",
    "doc": "ATANH(X) computes the inverse hyperbolic tangent of X.",
    "type": 3
  },
  "ATOMIC_ADD": {
    "args": "ATOM,VALUE",
    "doc": "ATOMIC_ADD(ATOM,VALUE) atomically adds the value of VALUE to the variable ATOM.",
    "type": 2
  },
  "ATOMIC_AND": {
    "args": "ATOM,VALUE",
    "doc": "ATOMIC_AND(ATOM,VALUE) atomically defines ATOM with the bitwise AND between the values of ATOM and VALUE.",
    "type": 2
  },
  "ATOMIC_CAS": {
    "args": "ATOM,OLD,COMPARE,NEW,STAT=stat",
    "doc": "ATOMIC_CAS compares the variable ATOM with the value of COMPARE; if the value is the same, ATOM is set to the value of NEW. Additionally, OLD is set to the value of ATOM that was used for the comparison.",
    "type": 2
  },
  "ATOMIC_DEFINE": {
    "args": "ATOM,VALUE,STAT=stat",
    "doc": "ATOMIC_DEFINE(ATOM,VALUE) defines the variable ATOM with the value VALUE atomically.",
    "type": 2
  },
  "ATOMIC_FETCH_ADD": {
    "args": "ATOM,VALUE,OLD,STAT=stat",
    "doc": "ATOMIC_FETCH_ADD(ATOM,VALUE,OLD) atomically stores the value of ATOM in OLD and adds the value of VALUE to the variable ATOM.",
    "type": 2
  },
  "ATOMIC_FETCH_AND": {
    "args": "ATOM,VALUE,OLD,STAT=stat",
    "doc": "ATOMIC_AND(ATOM,VALUE) atomically stores the value of ATOM in OLD and defines ATOM with the bitwise AND between the values of ATOM and VALUE.",
    "type": 2
  },
  "ATOMIC_FETCH_OR": {
    "args": "ATOM,VALUE,OLD,STAT=stat",
    "doc": "ATOMIC_OR(ATOM,VALUE) atomically stores the value of ATOM in OLD and defines ATOM with the bitwise OR between the values of ATOM and VALUE.",
    "type": 2
  },
  "ATOMIC_FETCH_XOR": {
    "args": "ATOM,VALUE,OLD,STAT=stat",
    "doc": "ATOMIC_XOR(ATOM,VALUE) atomically stores the value of ATOM in OLD and defines ATOM with the bitwise XOR between the values of ATOM and VALUE.",
    "type": 2
  },
  "ATOMIC_OR": {
    "args": "ATOM,VALUE,STAT=stat",
    "doc": "ATOMIC_OR(ATOM,VALUE) atomically defines ATOM with the bitwise AND between the values of ATOM and VALUE.",
    "type": 2
  },
  "ATOMIC_REF": {
    "args": "ATOM,VALUE,STAT=stat",
    "doc": "ATOMIC_DEFINE(ATOM,VALUE) atomically assigns the value of the variable ATOM to VALUE.",
    "type": 2
  },
  "ATOMIC_XOR": {
    "args": "ATOM,VALUE,STAT=stat",
    "doc": "ATOMIC_AND(ATOM,VALUE) atomically defines ATOM with the bitwise XOR between the values of ATOM and VALUE.",
    "type": 2
  },
  "BACKTRACE": {
    "args": "",
    "doc": "BACKTRACE shows a backtrace at an arbitrary place in user code. Program execution continues normally afterwards. The backtrace information is printed to the unit corresponding to ERROR_UNIT in ISO_FORTRAN_ENV.",
    "type": 2
  },
  "BESSEL_J0": {
    "args": "X",
    "doc": "BESSEL_J0(X) computes the Bessel function of the first kind of order 0 of X.",
    "type": 3
  },
  "BESSEL_J1": {
    "args": "X",
    "doc": "BESSEL_J1(X) computes the Bessel function of the first kind of order 1 of X.",
    "type": 3
  },
  "BESSEL_JN": {
    "args": "N,X",
    "doc": "BESSEL_JN(N,X) computes the Bessel function of the first kind of order N of X.",
    "type": 3
  },
  "BESSEL_Y0": {
    "args": "X",
    "doc": "BESSEL_Y0(X) computes the Bessel function of the second kind of order 0 of X.",
    "type": 3
  },
  "BESSEL_Y1": {
    "args": "X",
    "doc": "BESSEL_Y1(X) computes the Bessel function of the second kind of order 1 of X.",
    "type": 3
  },
  "BESSEL_YN": {
    "args": "N,X",
    "doc": "BESSEL_YN(N,X) computes the Bessel function of the second kind of order N of X.",
    "type": 3
  },
  "BGE": {
    "args": "I,J",
    "doc": "BGE(I,J) determines whether an integral is a bitwise greater than or equal to another.",
    "type": 3
  },
  "BGT": {
    "args": "I,J",
    "doc": "BGT(I,J) determines whether an integral is a bitwise greater than another.",
    "type": 3
  },
  "BIT_SIZE": {
    "args": "I",
    "doc": "BIT_SIZE(I) returns the number of bits represented by the type of I",
    "type": 3
  },
  "BLE": {
    "args": "I,J",
    "doc": "BLE(I,J) determines whether an integral is a bitwise less than or equal to another.",
    "type": 3
  },
  "BLT": {
    "args": "I,J",
    "doc": "BLT(I,J) determines whether an integral is a bitwise less than another.",
    "type": 3
  },
  "BTEST": {
    "args": "I,J",
    "doc": "BTEST(I,POS) returns logical .TRUE. if the bit at POS in I is set.",
    "type": 3
  },
  "CEILING": {
    "args": "A,KIND=kind",
    "doc": "CEILING(A,KIND=kind) returns the least integer greater than or equal to A.",
    "type": 3
  },
  "CHAR": {
    "args": "I,KIND=kind",
    "doc": "CHAR(I,KIND=kind) returns the character represented by the integer I.",
    "type": 3
  },
  "CHDIR": {
    "args": "NAME,STATUS=status",
    "doc": "CHDIR(NAME,STATUS=status) change current working directory to a specified path.",
    "type": 2
  },
  "CHMOD": {
    "args": "NAME,MODE,STATUS=status",
    "doc": "CHMOD(NAME,MODE,STATUS=status) changes the permissions of a file.",
    "type": 2
  },
  "CMPLX": {
    "args": "X,Y=y,KIND=kind",
    "doc": "CMPLX(X,Y=y,KIND=kind) returns a complex number where X is converted to the real component.",
    "type": 3
  },
  "CO_BROADCAST": {
    "args": "A,SOURCE_IMAGE,STAT=stat,ERRMSG=errmsg",
    "doc": "CO_BROADCAST(A,SOURCE_IMAGE,STAT=stat,ERRMSG=errmsg) copies the value of argument A on the image with image index SOURCE_IMAGE to all images in the current team.",
    "type": 2
  },
  "CO_MAX": {
    "args": "A,RESULT_IMAGE=result_image,STAT=stat,ERRMSG=errmsg",
    "doc": "CO_MAX(A,RESULT_IMAGE=result_image,STAT=stat,ERRMSG=errmsg) determines element-wise the maximal value of A on all images of the current team.",
    "type": 2
  },
  "CO_MIN": {
    "args": "A,RESULT_IMAGE=result_image,STAT=stat,ERRMSG=errmsg",
    "doc": "CO_MIN(A,RESULT_IMAGE=result_image,STAT=stat,ERRMSG=errmsg) determines element-wise the minimal value of A on all images of the current team.",
    "type": 2
  },
  "CO_REDUCE": {
    "args": "A,OPERATION,RESULT_IMAGE=result_image,STAT=stat,ERRMSG=errmsg",
    "doc": "CO_REDUCE(A,OPERATION,RESULT_IMAGE=result_image,STAT=stat,ERRMSG=errmsg) determines element-wise the reduction of the value of A on all images of the current team.",
    "type": 2
  },
  "CO_SUM": {
    "args": "A,RESULT_IMAGE=result_image,STAT=stat,ERRMSG=errmsg",
    "doc": "CO_SUM(A,RESULT_IMAGE=result_image,STAT=stat,ERRMSG=errmsg) sums up the values of each element of A on all images of the current team.",
    "type": 2
  },
  "COMMAND_ARGUMENT_COUNT": {
    "args": "X",
    "doc": "COMMAND_ARGUMENT_COUNT() returns the number of arguments passed on the command line when the containing program was invoked.",
    "type": 3
  },
  "COMPLEX": {
    "args": "X,Y",
    "doc": "COMPLEX(X,Y) returns a complex number where X is converted to the real component and Y is converted to the imaginary component.",
    "type": 3
  },
  "CONJG": {
    "args": "Z",
    "doc": "CONJG(Z) returns the conjugate of Z.",
    "type": 3
  },
  "COS": {
    "args": "X",
    "doc": "COS(X) computes the cosine of X.",
    "type": 3
  },
  "COSD": {
    "args": "X",
    "doc": "COSD(X) computes the cosine of X in degrees.",
    "type": 3
  },
  "COSH": {
    "args": "X",
    "doc": "COSH(X) computes the hyperbolic cosine of X.",
    "type": 3
  },
  "COTAN": {
    "args": "X",
    "doc": "COTAN(X) computes the cotangent of X.",
    "type": 3
  },
  "COTAND": {
    "args": "X",
    "doc": "COTAND(X) computes the cotangent of X in degrees.",
    "type": 3
  },
  "COUNT": {
    "args": "MASK,DIM=dim,KIND=kind",
    "doc": "COUNT(MASK,DIM=dim,KIND=kind) Count the number of true elements of MASK along dimension DIM.",
    "type": 3
  },
  "CPU_TIME": {
    "args": "TIME",
    "doc": "CPU_TIME(TIME) returns a REAL value representing the elapsed CPU time in seconds.",
    "type": 2
  },
  "CSHIFT": {
    "args": "ARRAY,SHIFT,DIM=dim",
    "doc": "CSHIFT(ARRAY,SHIFT,DIM=dim) performs a circular shift on elements of ARRAY along the dimension of DIM.",
    "type": 3
  },
  "CTIME": {
    "args": "TIME",
    "doc": "CTIME(TIME) converts a system time value, such as returned by TIME8, to a string. The output will be of the form ‘Sat Aug 19 18:13:14 1995’.",
    "type": 3
  },
  "DATE_AND_TIME": {
    "args": "DATE,TIME,ZONE,VALUES",
    "doc": "DATE_AND_TIME(DATE,TIME,ZONE,VALUES) gets the corresponding date and time information from the real-time system clock.",
    "type": 2
  },
  "DBLE": {
    "args": "A",
    "doc": "DBLE(A) converts A to double precision real type.",
    "type": 3
  },
  "DIGITS": {
    "args": "X",
    "doc": "DIGITS(X) returns the number of significant binary digits of the internal model representation of X.",
    "type": 3
  },
  "DIM": {
    "args": "X,Y",
    "doc": "DIM(X,Y) returns the difference X-Y if the result is positive; otherwise returns zero.",
    "type": 3
  },
  "DOT_PRODUCT": {
    "args": "A,B",
    "doc": "DOT_PRODUCT(A,B) computes the dot product multiplication of two vectors A and B.",
    "type": 3
  },
  "DPROD": {
    "args": "X,Y",
    "doc": "DPROD(X,Y) returns the product X*Y.",
    "type": 3
  },
  "DSHIFTL": {
    "args": "I,J,SHIFT",
    "doc": "DSHIFTL(I,J,SHIFT) combines bits of I and J.",
    "type": 3
  },
  "DSHIFTR": {
    "args": "I,J,SHIFT",
    "doc": "DSHIFTR(I,J,SHIFT) combines bits of I and J.",
    "type": 3
  },
  "EOSHIFT": {
    "args": "ARRAY,SHIFT,DIM=dim",
    "doc": "EOSHIFT(ARRAY,SHIFT,BOUNDARY=boundary,DIM=dim) performs a end-off shift on elements of ARRAY along the dimension of DIM.",
    "type": 3
  },
  "EPSILON": {
    "args": "X",
    "doc": "EPSILON(X) returns the smallest number E of the same kind as X such that 1 + E > 1.",
    "type": 3
  },
  "ERF": {
    "args": "X",
    "doc": "ERF(X) computes the error function of X.",
    "type": 3
  },
  "ERFC": {
    "args": "X",
    "doc": "ERFC(X) computes the complementary error function of X.",
    "type": 3
  },
  "ERFC_SCALED": {
    "args": "X",
    "doc": "ERFC_SCALED(X) computes the exponentially-scaled complementary error function of X.",
    "type": 3
  },
  "ETIME": {
    "args": "VALUES(2),TIME,",
    "doc": "ETIME(VALUES(2),TIME) returns the number of seconds of runtime since the start of the process’s execution in TIME.",
    "type": 3
  },
  "EVENT_QUERY": {
    "args": "EVENT,COUNT,STAT=stat",
    "doc": "EVENT_QUERY(EVENT,COUNT,STAT=stat) assigns the number of events to COUNT which have been posted to the EVENT variable and not yet been removed by calling EVENT WAIT.",
    "type": 2
  },
  "EXECUTE_COMMAND_LINE": {
    "args": "COMMAND,WAIT=wait,EXITSTAT=exitstat,CMDSTAT=cmdstat,CMDMSG=cmdmsg",
    "doc": "EXECUTE_COMMAND_LINE(COMMAND,WAIT=wait,EXITSTAT=exitstat,CMDSTAT=cmdstat,CMDMSG=cmdmsg) runs a shell command, synchronously or asynchronously.",
    "type": 2
  },
  "EXIT": {
    "args": "STATUS=status",
    "doc": "EXIT(STATUS=status) causes immediate termination of the program with status.",
    "type": 2
  },
  "EXP": {
    "args": "X",
    "doc": "EXP(X) computes the base e exponential of X.",
    "type": 3
  },
  "EXPONENT": {
    "args": "X",
    "doc": "EXPONENT(X) returns the value of the exponent part of X.",
    "type": 3
  },
  "EXTENDS_TYPE_OF": {
    "args": "A,MOLD",
    "doc": "EXTENDS_TYPE_OF(A,MOLD) queries dynamic type for extension.",
    "type": 3
  },
  "FDATE": {
    "args": "DATE",
    "doc": "FDATE(DATE) returns the current date (using the same format as CTIME) in DATE. It is equivalent to CALL CTIME(DATE, TIME()).",
    "type": 2
  },
  "FGET": {
    "args": "C,STATUS=status",
    "doc": "FDATE(C,STATUS=status) Read a single character in stream mode from stdin by bypassing normal formatted output.",
    "type": 2
  },
  "FGETC": {
    "args": "UNIT,C,STATUS=status",
    "doc": "FDATE(UNIT,C,STATUS=status) Read a single character in stream mode by bypassing normal formatted output.",
    "type": 2
  },
  "FINDLOC": {
    "args": "ARRAY,VALUE,DIM=dim,MASK=mask,KIND=kind,BACK=back",
    "doc": "FINDLOC(ARRAY,VALUE,DIM=dim,MASK=mask,KIND=kind,BACK=back) determines the location of the element in the array with the value given in the VALUE argument.",
    "type": 3
  },
  "FLOOR": {
    "args": "A,KIND=kind",
    "doc": "FLOOR(A,KIND=kind) returns the greatest integer less than or equal to A.",
    "type": 3
  },
  "FLUSH": {
    "args": "UNIT=unit",
    "doc": "FLUSH(UNIT=unit) Flushes Fortran unit(s) currently open for output.",
    "type": 2
  },
  "FNUM": {
    "args": "UNIT",
    "doc": "FNUM(UNIT) returns the POSIX file descriptor number corresponding to the open Fortran I/O unit UNIT.",
    "type": 3
  },
  "FPUT": {
    "args": "C,STATUS=status",
    "doc": "FPUT(C,STATUS=status) Write a single character in stream mode to stdout by bypassing normal formatted output.",
    "type": 3
  },
  "FPUTC": {
    "args": "C,UNIT=unit,STATUS=status",
    "doc": "FPUTC(C,UNIT=unit,STATUS=status) Write a single character in stream mode to stdout by bypassing normal formatted output.",
    "type": 3
  },
  "FRACTION": {
    "args": "X",
    "doc": "FRACTION(X) returns the fractional part of the model representation of X.",
    "type": 3
  },
  "FREE": {
    "args": "PTR",
    "doc": "FREE(PTR) Frees memory previously allocated by MALLOC.",
    "type": 2
  },
  "FSEEK": {
    "args": "UNIT,OFFSET,WHENCE,STATUS=status",
    "doc": "FSEEK(UNIT,OFFSET,WHENCE,STATUS=status) Moves UNIT to the specified OFFSET.",
    "type": 2
  },
  "FSTAT": {
    "args": "UNIT,VALUES",
    "doc": "FSTAT(UNIT,VALUES) FSTAT is identical to STAT, except that information about an already opened file is obtained.",
    "type": 3
  },
  "FTELL": {
    "args": "UNIT",
    "doc": "FSTAT(UNIT) Retrieves the current position within an open file.",
    "type": 3
  },
  "GAMMA": {
    "args": "X",
    "doc": "GAMMA(X) computes the gamma function of X.",
    "type": 3
  },
  "GERROR": {
    "args": "RESULT",
    "doc": "GERROR(RESULT) Returns the system error message corresponding to the last system error.",
    "type": 2
  },
  "GETARG": {
    "args": "POS,VALUE",
    "doc": "GETARG(POS,VALUE) Retrieve the POS-th argument that was passed on the command line when the containing program was invoked.",
    "type": 2
  },
  "GET_COMMAND": {
    "args": "COMMAND=command,LENGTH=length,STATUS=status",
    "doc": "GET_COMMAND(COMMAND=command,LENGTH=length,STATUS=status) retrieve the entire command line that was used to invoke the program.",
    "type": 2
  },
  "GET_COMMAND_ARGUMENT": {
    "args": "NUMBER=number,VALUE=value,LENGTH=length,STATUS=status",
    "doc": "GET_COMMAND_ARGUMENT(NUMBER=number,VALUE=value,LENGTH=length,STATUS=status) retrieve the NUMBER-th argument that was passed on the command line when the containing program was invoked.",
    "type": 2
  },
  "GETCWD": {
    "args": "C,STATUS=status",
    "doc": "GETCWD(C,STATUS=status) Get current working directory.",
    "type": 3
  },
  "GETENV": {
    "args": "NAME,VALUE",
    "doc": "GETENV(NAME,VALUE) Get the VALUE of the environmental variable NAME.",
    "type": 2
  },
  "GET_ENVIRONMENT_VARIABLE": {
    "args": "NAME=name,VALUE=value,LENGTH=length,STATUS=status,TRIM_NAME=trim_name",
    "doc": "GET_ENVIRONMENT_VARIABLE(NAME=name,VALUE=value,LENGTH=length,STATUS=status,TRIM_NAME=trim_name) gets the VALUE of the environmental variable NAME.",
    "type": 2
  },
  "GETGID": {
    "args": "",
    "doc": "GETGID() Returns the numerical group ID of the current process.",
    "type": 3
  },
  "GETLOG": {
    "args": "C",
    "doc": "GETLOG(C)Gets the username under which the program is running.",
    "type": 2
  },
  "GETPID": {
    "args": "",
    "doc": "GETPID() Returns the numerical process identifier of the current process.",
    "type": 3
  },
  "GETUID": {
    "args": "",
    "doc": "GETUID() Returns the numerical user ID of the current process.",
    "type": 3
  },
  "GMTIME": {
    "args": "TIME,VALUES",
    "doc": "GMTIME(TIME,VALUES) Given a system time value TIME (as provided by the TIME intrinsic), fills VALUES with values extracted from it appropriate to the UTC time zone, using gmtime(3).",
    "type": 2
  },
  "HOSTNM": {
    "args": "C,STATUS=status",
    "doc": "HOSTNM(C,STATUS=status) Retrieves the host name of the system on which the program is running.",
    "type": 3
  },
  "HUGE": {
    "args": "X",
    "doc": "HUGE(X) returns the largest number that is not an infinity in the model of the type of X.",
    "type": 3
  },
  "HYPOT": {
    "args": "X,Y",
    "doc": "HYPOT(X,Y)  is the Euclidean distance function without undue underflow or overflow.",
    "type": 3
  },
  "IACHAR": {
    "args": "I,KIND=kind",
    "doc": "IACHAR(C,KIND=kind) returns the code for the ASCII character in the first character position of C.",
    "type": 3
  },
  "IALL": {
    "args": "MASK,DIM=dim",
    "doc": "IALL(MASK,DIM=dim) reduces with bitwise AND the elements of ARRAY along dimension DIM.",
    "type": 3
  },
  "IAND": {
    "args": "I,J",
    "doc": "IAND(I,J) Bitwise logical AND.",
    "type": 3
  },
  "IANY": {
    "args": "MASK,DIM=dim",
    "doc": "IANY(MASK,DIM=dim) reduces with bitwise OR the elements of ARRAY along dimension DIM.",
    "type": 3
  },
  "IARGC": {
    "args": "",
    "doc": "IARGC() returns the number of arguments passed on the command line when the containing program was invoked.",
    "type": 3
  },
  "IBCLR": {
    "args": "I,POS",
    "doc": "IBCLR(I,POS) returns the value of I with the bit at position POS set to zero.",
    "type": 3
  },
  "IBITS": {
    "args": "I,POS,LEN",
    "doc": "IBITS(I,POS,LEN) extracts a field of length LEN from I, starting from bit position POS and extending left for LEN bits.",
    "type": 3
  },
  "IBSET": {
    "args": "I,POS",
    "doc": "IBSET(I,POS) returns the value of I with the bit at position POS set to one.",
    "type": 3
  },
  "ICHAR": {
    "args": "I,KIND=kind",
    "doc": "ICHAR(C,KIND=kind) returns the code for the character in the first character position of C in the system's native character set.",
    "type": 3
  },
  "IDATE": {
    "args": "VALUES",
    "doc": "IDATE(VALUES) Fills VALUES with the numerical values at the current local time.",
    "type": 2
  },
  "IEOR": {
    "args": "I,J",
    "doc": "IEOR(I,J) Bitwise logical exclusive OR.",
    "type": 3
  },
  "IEORNO": {
    "args": "",
    "doc": "IEORNO() Returns the last system error number, as given by the C errno variable.",
    "type": 3
  },
  "IMAGE_INDEX": {
    "args": "COARRAY,SUB",
    "doc": "IMAGE_INDEX(COARRAY,SUB) returns the image index belonging to a cosubscript.",
    "type": 3
  },
  "INDEX": {
    "args": "STRING,SUBSTRING,BACK=back,KIND=kind",
    "doc": "INDEX(STRING,SUBSTRING,BACK=back,KIND=kind) returns the position of the start of the first occurrence of string SUBSTRING as a substring in STRING, counting from one.",
    "type": 3
  },
  "INT": {
    "args": "A,KIND=kind",
    "doc": "INT(A,KIND=kind) Convert to integer type.",
    "type": 3
  },
  "INT2": {
    "args": "A",
    "doc": "INT2(A) Convert to a KIND=2 integer type.",
    "type": 3
  },
  "INT8": {
    "args": "A",
    "doc": "INT8(A) Convert to a KIND=8 integer type.",
    "type": 3
  },
  "IOR": {
    "args": "I,J",
    "doc": "IOR(I,J) Bitwise logical inclusive OR.",
    "type": 3
  },
  "IPARITY": {
    "args": "ARRAY,DIM=dim,MASK=mask",
    "doc": "IPARITY(ARRAY,DIM=dim,MASK=mask) reduces with bitwise XOR (exclusive or) the elements of ARRAY along dimension DIM if the corresponding element in MASK is TRUE.",
    "type": 3
  },
  "IRAND": {
    "args": "FLAG",
    "doc": "IRAND(FLAG) returns a pseudo-random number from a uniform distribution between 0 and a system-dependent limit (which is in most cases 2147483647).",
    "type": 3
  },
  "IS_CONTIGUOUS": {
    "args": "ARRAY",
    "doc": "IS_CONTIGUOUS(ARRAY) tests whether an array is contiguous.",
    "type": 3
  },
  "IS_IOSTAT_END": {
    "args": "I",
    "doc": "IS_IOSTAT_END(I) tests whether the variable I has the value of the I/O status 'end of file'",
    "type": 3
  },
  "IS_IOSTAT_EOR": {
    "args": "I",
    "doc": "IS_IOSTAT_EOR(I) tests whether the variable I has the value of the I/O status 'end of record'",
    "type": 3
  },
  "ISATTY": {
    "args": "UNIT",
    "doc": "ISATTY(UNIT) Determine whether a unit is connected to a terminal device.",
    "type": 3
  },
  "ISHFT": {
    "args": "I,SHIFT",
    "doc": "ISHFT(I,SHIFT) returns a value corresponding to I with all of the bits shifted SHIFT places.",
    "type": 3
  },
  "ISHFTC": {
    "args": "I,SHIFT,SIZE=size",
    "doc": "ISHFTC(I,SHIFT,SIZE=size) returns a value corresponding to I with the rightmost SIZE bits shifted circularly SHIFT places; that is, bits shifted out one end are shifted into the opposite end.",
    "type": 3
  },
  "ISNAN": {
    "args": "X",
    "doc": "ISNAN(X) tests whether a floating-point value is an IEEE Not-a-Number (NaN).",
    "type": 3
  },
  "ITIME": {
    "args": "VALUES",
    "doc": "ITIME(VALUES) Fills VALUES with the numerical values at the current local time.",
    "type": 2
  },
  "KILL": {
    "args": "PID,STATUS=status",
    "doc": "KILL(PID,STATUS=status) Sends the signal specified by SIG to the process PID. See kill(2).",
    "type": 3
  },
  "KIND": {
    "args": "X",
    "doc": "KIND(X) returns the kind value of the entity X.",
    "type": 3
  },
  "LBOUND": {
    "args": "ARRAY,DIM=dim,KIND=kind",
    "doc": "LBOUND(ARRAY,DIM=dim,KIND=kind) returns the lower bounds of an array, or a single lower bound along the DIM dimension.",
    "type": 3
  },
  "LCOBOUND": {
    "args": "COARRAY,DIM=dim,KIND=kind",
    "doc": "LCOBOUND(COARRAY,DIM=dim,KIND=kind) Returns the lower bounds of a coarray, or a single lower cobound along the DIM codimension.",
    "type": 3
  },
  "LEADZ": {
    "args": "I",
    "doc": "LEADZ(I) returns the number of leading zero bits of an integer.",
    "type": 3
  },
  "LEN": {
    "args": "STRING,KIND=kind",
    "doc": "LEN(STRING,KIND=kind) returns the length of a character string.",
    "type": 3
  },
  "LEN_TRIM": {
    "args": "STRING,KIND=kind",
    "doc": "LEN_TRIM(STRING,KIND=kind) returns the length of a character string, ignoring any trailing blanks.",
    "type": 3
  },
  "LGE": {
    "args": "STRING_A,STRING_B",
    "doc": "LGE(STRING_A,STRING_B) determines whether one string is lexically greater than or equal to another string.",
    "type": 3
  },
  "LGT": {
    "args": "STRING_A,STRING_B",
    "doc": "LGT(STRING_A,STRING_B) determines whether one string is lexically greater than another string.",
    "type": 3
  },
  "LINK": {
    "args": "PATH1,PATH2",
    "doc": "LINK(PATH1,PATH2) Makes a (hard) link from file PATH1 to PATH2.",
    "type": 3
  },
  "LLE": {
    "args": "STRING_A,STRING_B",
    "doc": "LLE(STRING_A,STRING_B) determines whether one string is lexically less than or equal to another string.",
    "type": 3
  },
  "LLT": {
    "args": "STRING_A,STRING_B",
    "doc": "LLT(STRING_A,STRING_B) determines whether one string is lexically less than another string.",
    "type": 3
  },
  "LNBLNK": {
    "args": "STRING",
    "doc": "LNBLNK(STRING) Returns the length of a character string, ignoring any trailing blanks.",
    "type": 3
  },
  "LOC": {
    "args": "X",
    "doc": "LOC(X) returns the address of X as an integer.",
    "type": 3
  },
  "LOG": {
    "args": "X",
    "doc": "LOG(X) computes the natural logarithm of X, i.e. the logarithm to the base e.",
    "type": 3
  },
  "LOG10": {
    "args": "X",
    "doc": "LOG10(X) computes the base 10 logarithm of X.",
    "type": 3
  },
  "LOG_GAMMA": {
    "args": "X",
    "doc": "LOG_GAMMA(X) computes the natural logarithm of the absolute value of the Gamma function.",
    "type": 3
  },
  "LOGICAL": {
    "args": "L,KIND=kind",
    "doc": "LOGICAL(L,KIND=kind) Converts one kind of LOGICAL variable to another.",
    "type": 3
  },
  "LSHIFT": {
    "args": "I,SHIFT",
    "doc": "LSHIFT(I,SHIFT) returns a value corresponding to I with all of the bits shifted left by SHIFT places.",
    "type": 3
  },
  "LSTAT": {
    "args": "NAME,VALUES,STATUS=status",
    "doc": "LSTAT(NAME,VALUES,STATUS=status) is identical to STAT, except that if path is a symbolic link, then the link itself is statted, not the file that it refers to.",
    "type": 3
  },
  "LTIME": {
    "args": "TIME,VALUES",
    "doc": "LTIME(TIME,VALUES) Given a system time value TIME (as provided by the TIME intrinsic), fills VALUES with values extracted from it appropriate to the local time zone using localtime(3).",
    "type": 2
  },
  "MALLOC": {
    "args": "SIZE",
    "doc": "MALLOC(SIZE) allocates SIZE bytes of dynamic memory and returns the address of the allocated memory.",
    "type": 3
  },
  "MASKL": {
    "args": "I,KIND=kind",
    "doc": "MASKL(I,KIND=kind) has its leftmost I bits set to 1, and the remaining bits set to 0.",
    "type": 3
  },
  "MASKR": {
    "args": "I,KIND=kind",
    "doc": "MASKR(I,KIND=kind) has its rightmost I bits set to 1, and the remaining bits set to 0.",
    "type": 3
  },
  "MATMUL": {
    "args": "MATRIX_A,MATRIX_B",
    "doc": "MATMUL(MATRIX_A,MATRIX_B) performs a matrix multiplication on numeric or logical arguments.",
    "type": 3
  },
  "MAX": {
    "args": "A1,A2",
    "doc": "MAX(A1,A2,...) returns the argument with the largest (most positive) value.",
    "type": 3
  },
  "MAXEXPONENT": {
    "args": "X",
    "doc": "MAXEXPONENT(X) returns the maximum exponent in the model of the type of X.",
    "type": 3
  },
  "MAXLOC": {
    "args": "ARRAY,DIM=dim,MASK=mask,KIND=kind,BACK=back",
    "doc": "MAXLOC(ARRAY,DIM=dim,MASK=mask,KIND=kind,BACK=back) determines the location of the element in the array with the maximum value.",
    "type": 3
  },
  "MAXVAL": {
    "args": "ARRAY,DIM=dim,MASK=mask,KIND=kind,BACK=back",
    "doc": "MAXVAL(ARRAY,DIM=dim,MASK=mask) determines the maximum value of the elements in an array.",
    "type": 3
  },
  "MCLOCK": {
    "args": "",
    "doc": "MCLOCK() Returns the number of clock ticks since the start of the process, based on the function clock(3) in the C standard library.",
    "type": 3
  },
  "MCLOCK8": {
    "args": "",
    "doc": "MCLOCK8() Returns the number of clock ticks since the start of the process, based on the function clock(3) in the C standard library.",
    "type": 3
  },
  "MERGE": {
    "args": "TSOURCE,FSOURCE,MASK",
    "doc": "MERGE(TSOURCE,FSOURCE,MASK) select values from two arrays according to a logical mask.",
    "type": 3
  },
  "MERGE_BITS": {
    "args": "I,J,MASK",
    "doc": "MERGE_BITS(I,J,MASK) merges the bits of I and J as determined by the mask.",
    "type": 3
  },
  "MIN": {
    "args": "A1,A2",
    "doc": "MIN(A1,A2,...) returns the argument with the smallest (most negative) value.",
    "type": 3
  },
  "MINEXPONENT": {
    "args": "X",
    "doc": "MINEXPONENT(X) returns the minimum exponent in the model of the type of X.",
    "type": 3
  },
  "MINLOC": {
    "args": "ARRAY,DIM=dim,MASK=mask,KIND=kind,BACK=back",
    "doc": "MINLOC(ARRAY,DIM=dim,MASK=mask,KIND=kind,BACK=back) determines the location of the element in the array with the minimum value.",
    "type": 3
  },
  "MINVAL": {
    "args": "ARRAY,DIM=dim,MASK=mask,KIND=kind,BACK=back",
    "doc": "MINVAL(ARRAY,DIM=dim,MASK=mask) determines the minimum value of the elements in an array.",
    "type": 3
  },
  "MOD": {
    "args": "A,P",
    "doc": "MOD(A,P) computes the remainder of the division of A by P.",
    "type": 3
  },
  "MODULO": {
    "args": "A,P",
    "doc": "MODULO(A,P) computes the A modulo P.",
    "type": 3
  },
  "MOVE_ALLOC": {
    "args": "FROM,TO",
    "doc": "MOVE_ALLOC(FROM,TO) moves the allocation from FROM to TO.",
    "type": 3
  },
  "MVBITS": {
    "args": "FROM,TO",
    "doc": "MVBITS(FROM,FROMPOS,LEN,TO,TOPOS) moves LEN bits from positions FROMPOS through FROMPOS+LEN-1 of FROM to positions TOPOS through TOPOS+LEN-1 of TO.",
    "type": 3
  },
  "NEAREST": {
    "args": "X,S",
    "doc": "NEAREST(X,S) returns the processor-representable number nearest to X in the direction indicated by the sign of S.",
    "type": 3
  },
  "NEW_LINE": {
    "args": "C",
    "doc": "NEW_LINE(C) returns the new-line character.",
    "type": 3
  },
  "NINT": {
    "args": "A,KIND=kind",
    "doc": "NINT(A,KIND=kind) rounds its argument to the nearest whole number.",
    "type": 3
  },
  "NORM2": {
    "args": "ARRAY,DIM=dim",
    "doc": "NORM2(ARRAY,DIM=dim) Calculates the Euclidean vector norm (L_2 norm) of ARRAY along dimension DIM.",
    "type": 3
  },
  "NOT": {
    "args": "I",
    "doc": "NOT(I) returns the bitwise Boolean inverse of I.",
    "type": 3
  },
  "NULL": {
    "doc": "NULL() returns a disassociated pointer.",
    "type": 3
  },
  "PACK": {
    "args": "ARRAY,MASK=mask,VECTOR=vector",
    "doc": "PACK(ARRAY,MASK=mask,VECTOR=vector) stores the elements of ARRAY in an array of rank one.",
    "type": 3
  },
  "PARITY": {
    "args": "MASK,DIM=dim",
    "doc": "PARITY(MASK,DIM=dim) Calculates the parity, i.e. the reduction using .XOR., of MASK along dimension DIM.",
    "type": 3
  },
  "PERROR": {
    "args": "STRING",
    "doc": "PERROR(STRING) Prints (on the C stderr stream) a newline-terminated error message corresponding to the last system error. This is prefixed by STRING, a colon and a space.",
    "type": 2
  },
  "POPCNT": {
    "args": "I",
    "doc": "POPCNT(I) returns the number of bits set (’1’ bits) in the binary representation of I.",
    "type": 3
  },
  "POPPAR": {
    "args": "I",
    "doc": "POPPAR(I) returns parity of the integer I, i.e. the parity of the number of bits set ('1' bits) in the binary representation of I. It is equal to 0 if I has an even number of bits set, and 1 for an odd number of '1' bits.",
    "type": 3
  },
  "PRECISION": {
    "args": "X",
    "doc": "PRECISION(X) returns the decimal precision in the model of the type of X.",
    "type": 3
  },
  "PRESENT": {
    "args": "A",
    "doc": "PRESENT(A) determines whether an optional dummy argument is present.",
    "type": 3
  },
  "PRODUCT": {
    "args": "ARRAY,DIM=dim,MASK=mask",
    "doc": "PRODUCT(ARRAY,DIM=dim,MASK=mask) multiplies the elements of ARRAY along dimension DIM if the corresponding element in MASK is TRUE.",
    "type": 3
  },
  "RADIX": {
    "args": "X",
    "doc": "RADIX(X) returns the base of the model representing the entity X.",
    "type": 3
  },
  "RAN": {
    "args": "I",
    "doc": "RAN(I) For compatibility with HP FORTRAN 77/iX, the RAN intrinsic is provided as an alias for RAND.",
    "type": 3
  },
  "RAND": {
    "args": "I",
    "doc": "RAND(I) returns a pseudo-random number from a uniform distribution between 0 and 1.",
    "type": 3
  },
  "RANDOM_INIT": {
    "args": "REPEATABLE,IMAGE_DISTINCT",
    "doc": "RANDOM_INIT(REPEATABLE,IMAGE_DISTINCT) Initializes the state of the pseudorandom number generator used by RANDOM_NUMBER.",
    "type": 2
  },
  "RANDOM_NUMBER": {
    "args": "HARVEST",
    "doc": "RANDOM_NUMBER(HARVEST) returns a single pseudorandom number or an array of pseudorandom numbers.",
    "type": 2
  },
  "RANDOM_SEED": {
    "args": "SIZE=size,PUT=put,GET=get",
    "doc": "RANDOM_SEED(SIZE=size,PUT=put,GET=get) restarts or queries the state of the pseudorandom number generator used by RANDOM_NUMBER.",
    "type": 2
  },
  "RANGE": {
    "args": "X",
    "doc": "RANGE(X) returns the decimal exponent range in the model of the type of X.",
    "type": 3
  },
  "RANK": {
    "args": "A",
    "doc": "RANK(A) returns the rank of a scalar or array data object.",
    "type": 3
  },
  "REAL": {
    "args": "A,KIND=kind",
    "doc": "REAL(A,KIND=kind) converts its argument A to a real type.",
    "type": 3
  },
  "RENAME": {
    "args": "PATH1,PATH2",
    "doc": "RENAME(PATH1,PATH2) Renames a file from file PATH1 to PATH2.",
    "type": 3
  },
  "REPEAT": {
    "args": "STRING,NCOPIES",
    "doc": "REPEAT(STRING,NCOPIES) concatenates NCOPIES copies of a string.",
    "type": 3
  },
  "RESHAPE": {
    "args": "SOURCE,SHAPE,PAD=pad,ORDER=order",
    "doc": "RESHAPE(SOURCE,SHAPE,PAD=pad,ORDER=order) reshapes SOURCE to correspond to SHAPE.",
    "type": 3
  },
  "RRSPACING": {
    "args": "X",
    "doc": "RRSPACING(X) returns the reciprocal of the relative spacing of model numbers near X.",
    "type": 3
  },
  "RSHIFT": {
    "args": "I,SHIFT",
    "doc": "RSHIFT(I,SHIFT) eturns a value corresponding to I with all of the bits shifted right by SHIFT places.",
    "type": 3
  },
  "SAME_TYPE_AS": {
    "args": "A,B",
    "doc": "SAME_TYPE_AS(A,B) query dynamic types for equality.",
    "type": 3
  },
  "SCALE": {
    "args": "X,I",
    "doc": "SCALE(X,I) returns X * RADIX(X)**I.",
    "type": 3
  },
  "SCAN": {
    "args": "STRING,SET,BACK=back,KIND=kind",
    "doc": "SCAN(STRING,SET,BACK=back,KIND=kind) scans a STRING for any of the characters in a SET of characters.",
    "type": 3
  },
  "SECNDS": {
    "args": "X",
    "doc": "SECNDS(X) gets the time in seconds from the real-time system clock.",
    "type": 3
  },
  "SECOND": {
    "args": "TIME",
    "doc": "SECOND(TIME) Returns a REAL(4) value representing the elapsed CPU time in seconds.",
    "type": 3
  },
  "SELECTED_CHAR_KIND": {
    "args": "NAME",
    "doc": "SELECTED_CHAR_KIND(NAME) returns the kind value for the character set named NAME, if a character set with such a name is supported, or -1 otherwise.",
    "type": 3
  },
  "SELECTED_INT_KIND": {
    "args": "R",
    "doc": "SELECTED_INT_KIND(R) return the kind value of the smallest integer type that can represent all values ranging from -10^R (exclusive) to 10^R (exclusive).",
    "type": 3
  },
  "SELECTED_REAL_KIND": {
    "args": "P,R",
    "doc": "SELECTED_REAL_KIND(P,R) returns the kind value of a real data type with decimal precision of at least P digits, exponent range of at least R, and with a radix of RADIX.",
    "type": 3
  },
  "SET_EXPONENT": {
    "args": "X,I",
    "doc": "SET_EXPONENT(X,I) returns the real number whose fractional part is that that of X and whose exponent part is I.",
    "type": 3
  },
  "SHAPE": {
    "args": "SOURCE,KIND=kind",
    "doc": "SHAPE(SOURCE,KIND=kind) determines the shape of an array.",
    "type": 3
  },
  "SHIFTA": {
    "args": "I,SHIFT",
    "doc": "SHIFTA(I,SHIFT) returns a value corresponding to I with all of the bits shifted right by SHIFT places.",
    "type": 3
  },
  "SHIFTL": {
    "args": "I,SHIFT",
    "doc": "SHIFTL(I,SHIFT) returns a value corresponding to I with all of the bits shifted left by SHIFT places.",
    "type": 3
  },
  "SHIFTR": {
    "args": "I,SHIFT",
    "doc": "SHIFTR(I,SHIFT) returns a value corresponding to I with all of the bits shifted right by SHIFT places.",
    "type": 3
  },
  "SIGN": {
    "args": "A,B",
    "doc": "SIGN(A,B) returns the value of A with the sign of B.",
    "type": 3
  },
  "SIGNAL": {
    "args": "NUMBER,HANDLER",
    "doc": "SIGNAL(NUMBER,HANDLER) causes external subroutine HANDLER to be executed with a single integer argument when signal NUMBER occurs.",
    "type": 3
  },
  "SIN": {
    "args": "X",
    "doc": "SIN(X) computes the sine of X.",
    "type": 3
  },
  "SIND": {
    "args": "X",
    "doc": "SIND(X) computes the sine of X in degrees.",
    "type": 3
  },
  "SINH": {
    "args": "X",
    "doc": "SINH(X) computes the hyperbolic sine of X.",
    "type": 3
  },
  "SIZE": {
    "args": "ARRAY,DIM=dim,KIND=kind",
    "doc": "SIZE(ARRAY,DIM=dim,KIND=kind) determines the extent of ARRAY along a specified dimension DIM, or the total number of elements in ARRAY if DIM is absent.",
    "type": 3
  },
  "SIZEOF": {
    "args": "X",
    "doc": "SIZEOF(X) calculates the number of bytes of storage the expression X occupies.",
    "type": 3
  },
  "SLEEP": {
    "args": "SECONDS",
    "doc": "SLEEP(SECONDS) Calling this subroutine causes the process to pause for SECONDS seconds.",
    "type": 2
  },
  "SPACING": {
    "args": "X",
    "doc": "SPACING(X) determines the distance between the argument X and the nearest adjacent number of the same type.",
    "type": 3
  },
  "SPREAD": {
    "args": "SOURCE,DIM,NCOPIES",
    "doc": "SPREAD(SOURCE,DIM,NCOPIES) replicates a SOURCE array NCOPIES times along a specified dimension DIM.",
    "type": 3
  },
  "SQRT": {
    "args": "X",
    "doc": "SQRT(X) computes the square root of X.",
    "type": 3
  },
  "SRAND": {
    "args": "SEED",
    "doc": "SRAND(SEED) reinitializes the pseudo-random number generator called by RAND and IRAND.",
    "type": 2
  },
  "STAT": {
    "args": "NAME,VALUES",
    "doc": "STAT(NAME,VALUES) This function returns information about a file.",
    "type": 3
  },
  "STORAGE_SIZE": {
    "args": "A,KIND=kind",
    "doc": "STORAGE_SIZE(A,KIND=kind) Returns the storage size of argument A in bits.",
    "type": 3
  },
  "SUM": {
    "args": "ARRAY,DIM=dim,MASK=mask",
    "doc": "SUM(ARRAY,DIM=dim,MASK=mask) adds the elements of ARRAY along dimension DIM if the corresponding element in MASK is TRUE.",
    "type": 3
  },
  "SYMLNK": {
    "args": "PATH1,PATH2",
    "doc": "SYMLNK(PATH1,PATH2) Makes a symbolic link from file PATH1 to PATH2.",
    "type": 3
  },
  "SYSTEM": {
    "args": "COMMAND,STATUS=status",
    "doc": "SYSTEM(COMMAND,STATUS=status) Passes the command COMMAND to a shell (see system(3)).",
    "type": 3
  },
  "SYSTEM_CLOCK": {
    "args": "COUNT=count,COUNT_RATE=count_rate,COUNT_MAX=count_max",
    "doc": "SYSTEM_CLOCK(COUNT=count,COUNT_RATE=count_rate,COUNT_MAX=count_max) determines the COUNT of a processor clock since an unspecified time in the past modulo COUNT_MAX, COUNT_RATE determines the number of clock ticks per second.",
    "type": 3
  },
  "TAN": {
    "args": "X",
    "doc": "TAN(X) computes the tangent of X.",
    "type": 3
  },
  "TAND": {
    "args": "X",
    "doc": "TAND(X) computes the tangent of X in degrees.",
    "type": 3
  },
  "TANH": {
    "args": "X",
    "doc": "TANH(X) computes the hyperbolic tangent of X.",
    "type": 3
  },
  "THIS_IMAGE": {
    "args": "DISTANCE=distance|COARRAY,DIM=dim",
    "doc": "THIS_IMAGE(DISTANCE=distance|COARRAY,DIM=dim) Returns the cosubscript for this image.",
    "type": 3
  },
  "TIME": {
    "args": "",
    "doc": "TIME() Returns the current time encoded as an integer.",
    "type": 3
  },
  "TIME8": {
    "args": "",
    "doc": "TIME8() Returns the current time encoded as an integer. This value is suitable for passing to CTIME, GMTIME, and LTIME.",
    "type": 3
  },
  "TINY": {
    "args": "X",
    "doc": "TINY(X) returns the smallest positive (non zero) number in the model of the type of X.",
    "type": 3
  },
  "TRAILZ": {
    "args": "I",
    "doc": "TRAILZ(I) returns the number of trailing zero bits of an integer.",
    "type": 3
  },
  "TRANSFER": {
    "args": "SOURCE,MOLD,SIZE=size",
    "doc": "TRANSFER(SOURCE,MOLD,SIZE=size) interprets the bitwise representation of SOURCE in memory as if it is the representation of a variable or array of the same type and type parameters as MOLD.",
    "type": 3
  },
  "TRANSPOSE": {
    "args": "MATRIX",
    "doc": "TRANSPOSE(MATRIX) transpose an array of rank two.",
    "type": 3
  },
  "TRIM": {
    "args": "STRING",
    "doc": "TRIM(STRING) removes trailing blank characters of a string.",
    "type": 3
  },
  "TTYNAM": {
    "args": "UNIT",
    "doc": "TTYNAM(UNIT) Get the name of a terminal device.",
    "type": 3
  },
  "UBOUND": {
    "args": "ARRAY,DIM=dim,KIND=kind",
    "doc": "UBOUND(ARRAY,DIM=dim,KIND=kind) returns the upper bounds of an array, or a single upper bound along the DIM dimension.",
    "type": 3
  },
  "UCOBOUND": {
    "args": "ARRAY,DIM=dim,KIND=kind",
    "doc": "UCOBOUND(ARRAY,DIM=dim,KIND=kind) Returns the upper cobounds of a coarray, or a single upper cobound along the DIM codimension.",
    "type": 3
  },
  "UMASK": {
    "args": "MASK",
    "doc": "UMASK(MASK) Sets the file creation mask to MASK.",
    "type": 3
  },
  "UNLINK": {
    "args": "PATH",
    "doc": "UNLINK(PATH) Unlinks the file PATH.",
    "type": 3
  },
  "UNPACK": {
    "args": "VECTOR,MASK,FIELD",
    "doc": "UNPACK(VECTOR,MASK,FIELD) Store the elements of VECTOR in an array of higher rank.",
    "type": 3
  },
  "VERIFY": {
    "args": "STRING,SET,BACK=back,KIND=kind",
    "doc": "VERIFY(STRING,SET,BACK=back,KIND=kind) verifies that all the characters in STRING belong to the set of characters in SET.",
    "type": 3
  },
  "XOR": {
    "args": "I,J",
    "doc": "XOR(I,J) Bitwise logical exclusive or.",
    "type": 3
  }
}
