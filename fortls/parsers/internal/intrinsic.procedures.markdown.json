{
  "ABS": "## abs\n\n### **Name**\n\n**abs** - \\[NUMERIC\\] Absolute value\n\n### **Synopsis**\n```fortran\n    result = abs(a)\n```\n```fortran\n     elemental TYPE(kind=KIND) function abs(a)\n\n      TYPE(kind=KIND),intent(in) :: a\n```\n### **Characteristics**\n\n- **a** may be any _real_, _integer_, or _complex_ value.\n\n- If **a** is _complex_ the returned value will be a _real_ with the\n  same kind as **a**.\n\n  Otherwise the returned type and kind is the same as for **a**.\n\n### **Description**\n\n   **abs** computes the absolute value of numeric argument **a**.\n\n   In mathematics, the absolute value or modulus of a real number **x**,\n   denoted **|x|**, is the magnitude of **x** without regard to its sign.\n\n   The absolute value of a number may be thought of as its distance from\n   zero. So for a complex value the absolute value is a real number\n   with magnitude **sqrt(x%re\\*\\*2,x%im\\*\\*2)**, as if the real component\n   is the x value and the imaginary value is the y value for the point\n   \\<x,y\\>.\n\n### **Options**\n\n- **a**\n  : The value to compute the absolute value of.\n\n### **Result**\n\n   If **a** is of type _integer_ or _real_, the value of the result\n   is the absolute value **|a|** and of the same type and kind as the\n   input argument.\n\n   If **a** is _complex_ with value **(x, y)**, the result is a _real_\n   equal to a processor-dependent approximation to\n```fortran\n        sqrt(x**2 + y**2)\n```\n   computed without undue overflow or underflow (that means the\n   computation of the result can overflow the allowed magnitude of the\n   real value returned, and that very small values can produce underflows\n   if they are squared while calculating the returned value, for example).\n\n   That is, if you think of non-complex values as being complex values\n   on the x-axis and complex values as being x-y points <x%re,x%im>\n   the result of **abs** is the (positive) magnitude of the distance\n   of the value from the origin.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_abs\nimplicit none\ninteger,parameter :: dp=kind(0.0d0)\n\ninteger           :: i = -1\nreal              :: x = -1.0\ncomplex           :: z = (-3.0,-4.0)\ndoubleprecision   :: rr = -45.78_dp\n\ncharacter(len=*),parameter :: &\n   ! some formats\n   frmt  =  '(1x,a15,1x,\" In: \",g0,            T51,\" Out: \",g0)', &\n   frmtc = '(1x,a15,1x,\" In: (\",g0,\",\",g0,\")\",T51,\" Out: \",g0)',  &\n   g     = '(*(g0,1x))'\n\n  ! basic usage\n    ! any integer, real, or complex type\n    write(*, frmt)  'integer         ',  i, abs(i)\n    write(*, frmt)  'real            ',  x, abs(x)\n    write(*, frmt)  'doubleprecision ', rr, abs(rr)\n    write(*, frmtc) 'complex         ',  z, abs(z)\n\n  ! You can take the absolute value of any value whose positive value\n  ! is representable with the same type and kind.\n    write(*, *) 'abs range test : ', abs(huge(0)), abs(-huge(0))\n    write(*, *) 'abs range test : ', abs(huge(0.0)), abs(-huge(0.0))\n    write(*, *) 'abs range test : ', abs(tiny(0.0)), abs(-tiny(0.0))\n    ! A dusty corner is that abs(-huge(0)-1) of an integer would be\n    ! a representable negative value on most machines but result in a\n    ! positive value out of range.\n\n  ! elemental\n    write(*, g) ' abs is elemental:', abs([20,  0,  -1,  -3,  100])\n\n  ! COMPLEX input produces REAL output\n    write(*, g)' complex input produces real output', &\n    & abs(cmplx(30.0_dp,40.0_dp,kind=dp))\n    ! dusty corner: \"kind=dp\" is required or the value returned by\n    ! CMPLX() is a default real instead of double precision\n\n  ! the returned value for complex input can be thought of as the\n  ! distance from the origin <0,0>\n    write(*, g) ' distance of (', z, ') from zero is', abs( z )\n    write(*, g) ' so beware of overflow with complex values'\n    !write(*, g) abs(cmplx( huge(0.0), huge(0.0) ))\n    write(*, g) ' because the biggest default real is',huge(0.0)\n\nend program demo_abs\n```\nResults:\n```text\n    integer          In: -1                     Out: 1\n    real             In: -1.000000              Out: 1.000000\n    doubleprecision  In: -45.78000000000000     Out: 45.78000000000000\n    complex          In: (-3.000000,-4.000000)  Out: 5.000000\n    abs range test :   2147483647  2147483647\n    abs range test :   3.4028235E+38  3.4028235E+38\n    abs range test :   1.1754944E-38  1.1754944E-38\n    abs is elemental: 20 0 1 3 100\n    complex input produces real output 50.00000000000000\n    distance of ( -3.000000 -4.000000 ) from zero is 5.000000\n    so beware of overflow with complex values\n    Inf\n    because the biggest default real is .3402823E+39\n```\n### **Standard**\n\n   FORTRAN 77\n\n### **See Also**\n\n[**sign**(3)](#sign)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ACHAR": "## achar\n\n### **Name**\n\n**achar** - \\[CHARACTER:CONVERSION\\] Returns a character in a specified position in the ASCII collating sequence\n\n### **Synopsis**\n```fortran\n    result = achar(i [,kind])\n```\n```fortran\n     elemental character(len=1,kind=KIND) function achar(i,KIND)\n\n      integer(kind=**),intent(in) :: i\n      integer(kind=**),intent(in),optional :: KIND\n```\n### **Characteristics**\n\n- a kind designated as ** may be any supported kind for the type\n\n- The _character_ kind returned is the value of **kind** if present.\n  otherwise, a single default _character_ is returned.\n\n### **Description**\n\n  **achar** returns the character located at position **i** (commonly\n  called the _ADE_ or ASCII Decimal Equivalent) in the ASCII collating\n  sequence.\n\n  The **achar** function is often used for generating in-band escape\n  sequences to control terminal attributes, as it makes it easy to print\n  unprintable characters such as escape and tab. For example:\n```fortran\n   write(*,'(*(a))')achar(27),'[2J'\n```\n  will clear the screen on an ANSI-compatible terminal display,\n\n### **Note**\n\nThe ADEs (ASCII Decimal Equivalents) for ASCII are\n```text\n*-------*-------*-------*-------*-------*-------*-------*-------*\n| 00 nul| 01 soh| 02 stx| 03 etx| 04 eot| 05 enq| 06 ack| 07 bel|\n| 08 bs | 09 ht | 10 nl | 11 vt | 12 np | 13 cr | 14 so | 15 si |\n| 16 dle| 17 dc1| 18 dc2| 19 dc3| 20 dc4| 21 nak| 22 syn| 23 etb|\n| 24 can| 25 em | 26 sub| 27 esc| 28 fs | 29 gs | 30 rs | 31 us |\n| 32 sp | 33  ! | 34  \" | 35  # | 36  $ | 37  % | 38  & | 39  ' |\n| 40  ( | 41  ) | 42  * | 43  + | 44  , | 45  - | 46  . | 47  / |\n| 48  0 | 49  1 | 50  2 | 51  3 | 52  4 | 53  5 | 54  6 | 55  7 |\n| 56  8 | 57  9 | 58  : | 59  ; | 60  < | 61  = | 62  > | 63  ? |\n| 64  @ | 65  A | 66  B | 67  C | 68  D | 69  E | 70  F | 71  G |\n| 72  H | 73  I | 74  J | 75  K | 76  L | 77  M | 78  N | 79  O |\n| 80  P | 81  Q | 82  R | 83  S | 84  T | 85  U | 86  V | 87  W |\n| 88  X | 89  Y | 90  Z | 91  [ | 92  \\ | 93  ] | 94  ^ | 95  _ |\n| 96  ` | 97  a | 98  b | 99  c |100  d |101  e |102  f |103  g |\n|104  h |105  i |106  j |107  k |108  l |109  m |110  n |111  o |\n|112  p |113  q |114  r |115  s |116  t |117  u |118  v |119  w |\n|120  x |121  y |122  z |123  { |124  | |125  } |126  ~ |127 del|\n*-------*-------*-------*-------*-------*-------*-------*-------*\n```\n### **Options**\n\n- **i**\n  : the _integer_ value to convert to an ASCII character, in the range\n  0 to 127.\n  : **achar** shall have the value C for any character\n  C capable of representation as a default character.\n\n- **kind**\n  : a _integer_ initialization expression indicating the kind\n  parameter of the result.\n\n### **Result**\n  Assuming **i** has a value in the range 0 <= I <= 127, the result is the\n  character in position **i** of the ASCII collating sequence, provided\n  the processor is capable of representing that character in the character\n  kind of the result; otherwise, the result is processor dependent.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_achar\nuse,intrinsic::iso_fortran_env,only:int8,int16,int32,int64\nimplicit none\ninteger :: i\n   i=65\n   write(*,'(\"decimal     =\",i0)')i\n   write(*,'(\"character   =\",a1)')achar(i)\n   write(*,'(\"binary      =\",b0)')achar(i)\n   write(*,'(\"octal       =\",o0)')achar(i)\n   write(*,'(\"hexadecimal =\",z0)')achar(i)\n\n   write(*,'(8(i3,1x,a,1x),/)')(i,achar(i), i=32,126)\n\n   write(*,'(a)')upper('Mixed Case')\ncontains\n! a classic use of achar(3) is to convert the case of a string\n\npure elemental function upper(str) result (string)\n!\n!$@(#) upper(3f): function to return a trimmed uppercase-only string\n!\n! input string to convert to all uppercase\ncharacter(*), intent(in)      :: str\n! output string that contains no miniscule letters\ncharacter(len(str))           :: string\ninteger                       :: i, iend\ninteger,parameter             :: toupper = iachar('A')-iachar('a')\n   iend=len_trim(str)\n   ! initialize output string to trimmed input string\n   string = str(:iend)\n   ! process each letter in the string\n   do concurrent (i = 1:iend)\n       select case (str(i:i))\n       ! located miniscule letter\n       case ('a':'z')\n          ! change miniscule to majuscule letter\n          string(i:i) = achar(iachar(str(i:i))+toupper)\n       end select\n   enddo\nend function upper\nend program demo_achar\n```\nResults:\n```\n   decimal     =65\n   character   =A\n   binary      =1000001\n   octal       =101\n   hexadecimal =41\n    32    33 !  34 \"  35 #  36 $  37 %  38 &  39 '\n\n    40 (  41 )  42 *  43 +  44 ,  45 -  46 .  47 /\n\n    48 0  49 1  50 2  51 3  52 4  53 5  54 6  55 7\n\n    56 8  57 9  58 :  59 ;  60 <  61 =  62 >  63 ?\n\n    64 @  65 A  66 B  67 C  68 D  69 E  70 F  71 G\n\n    72 H  73 I  74 J  75 K  76 L  77 M  78 N  79 O\n\n    80 P  81 Q  82 R  83 S  84 T  85 U  86 V  87 W\n\n    88 X  89 Y  90 Z  91 [  92 \\  93 ]  94 ^  95 _\n\n    96 `  97 a  98 b  99 c 100 d 101 e 102 f 103 g\n\n   104 h 105 i 106 j 107 k 108 l 109 m 110 n 111 o\n\n   112 p 113 q 114 r 115 s 116 t 117 u 118 v 119 w\n\n   120 x 121 y 122 z 123 { 124 | 125 } 126 ~\n   MIXED CASE\n```\n### **Standard**\n\nFORTRAN 77. KIND argument added Fortran 2003\n\n### **See Also**\n\n[**char**(3)](#char),\n[**iachar**(3)](#iachar),\n[**ichar**(3)](#ichar)\n\n### **Resources**\n\n- [ANSI escape sequences](https://en.wikipedia.org/wiki/ANSI_escape_code)\n- [M_attr module](https://github.com/urbanjost/M_attr) for controlling ANSI-compatible terminals\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ACOS": "## acos\n\n### **Name**\n\n**acos** - \\[MATHEMATICS:TRIGONOMETRIC\\] Arccosine (inverse cosine) function\n\n### **Synopsis**\n```fortran\n    result = acos(x)\n```\n```fortran\n     elemental TYPE(kind=KIND) function acos(x)\n\n      TYPE(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **TYPE** may be _real_ or _complex_\n - **KIND** may be any kind supported by the associated type.\n - The returned value will be of the same type and kind as the argument.\n\n### **Description**\n\n**acos** computes the arccosine of **x** (inverse of **cos(x)**).\n\n### **Options**\n\n- **x**\n  : The value to compute the arctangent of.\n  : If the type is _real_, the value must satisfy |**x**| <= 1.\n\n### **Result**\n\nThe return value is of the same type and kind as **x**. The _real_ part of\nthe result is in radians and lies in the range **0 \\<= acos(x%re) \\<= PI** .\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_acos\nuse, intrinsic :: iso_fortran_env, only : real_kinds,real32,real64,real128\nimplicit none\ncharacter(len=*),parameter :: all='(*(g0,1x))'\nreal(kind=real64) :: x , d2r\n\n   ! basics\n    x = 0.866_real64\n    print all,'acos(',x,') is ', acos(x)\n\n   ! acos(-1) should be PI\n    print all,'for reference &\n    &PI ~= 3.14159265358979323846264338327950288419716939937510'\n    write(*,*) acos(-1.0_real64)\n    d2r=acos(-1.0_real64)/180.0_real64\n    print all,'90 degrees is ', d2r*90.0_real64, ' radians'\n   ! elemental\n    print all,'elemental',acos([-1.0,-0.5,0.0,0.50,1.0])\n   ! complex\n    print *,'complex',acos( (-1.0,  0.0) )\n    print *,'complex',acos( (-1.0, -1.0) )\n    print *,'complex',acos( ( 0.0, -0.0) )\n    print *,'complex',acos( ( 1.0,  0.0) )\n\nend program demo_acos\n```\nResults:\n```text\n acos( 0.86599999999999999 ) is  0.52364958093182890\n for reference PI ~= 3.14159265358979323846264338327950288419716939937510\n    3.1415926535897931\n 90 degrees is  1.5707963267948966  radians\n elemental 3.14159274 2.09439516 1.57079637 1.04719758 0.00000000\n  complex            (3.14159274,-0.00000000)\n  complex             (2.23703575,1.06127501)\n  complex             (1.57079637,0.00000000)\n  complex            (0.00000000,-0.00000000)\n```\n### **Standard**\n\nFORTRAN 77 ; for a _complex_ argument - Fortran 2008\n\n### **See Also**\nInverse function: [**cos**(3)](cos)\n\n### **Resources**\n- [wikipedia: inverse trigonometric functions](https://en.wikipedia.org/wiki/Inverse_trigonometric_functions)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ACOSH": "## acosh\n\n### **Name**\n\n**acosh** - \\[MATHEMATICS:TRIGONOMETRIC\\] Inverse hyperbolic cosine function\n\n### **Synopsis**\n```fortran\n    result = acosh(x)\n```\n```fortran\n     elemental TYPE(kind=KIND) function acosh(x)\n\n      TYPE(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **TYPE** may be _real_ or _complex_\n - **KIND** may be any kind supported by the associated type.\n - The returned value will be of the same type and kind as the argument.\n\n### **Description**\n\n**acosh** computes the inverse hyperbolic cosine of **x** in radians.\n\n### **Options**\n\n- **x**\n  : The value to compute the hyperbolic cosine of. A real value should\n  be \\>= 1 or the result with be a Nan.\n\n### **Result**\n\nThe result has a value equal to a processor-dependent approximation to\nthe inverse hyperbolic cosine function of X.\n\nIf **x** is _complex_, the imaginary part of the result is in radians\nand lies between\n```fortran\n 0 <= aimag(acosh(x)) <= PI\n```\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_acosh\nuse,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32\nimplicit none\nreal(kind=dp), dimension(3) :: x = [ 1.0d0, 2.0d0, 3.0d0 ]\n   if( any(x.lt.1) )then\n      write (*,*) ' warning: values < 1 are present'\n   endif\n   write (*,*) acosh(x)\nend program demo_acosh\n```\nResults:\n```text\n 0.000000000000000E+000   1.31695789692482        1.76274717403909\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\nInverse function: [**cosh**(3)](#cosh)\n\n### **Resources**\n- [Wikipedia:hyperbolic functions](https://en.wikipedia.org/wiki/Hyperbolic_functions)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ADJUSTL": "## adjustl\n\n### **Name**\n\n**adjustl** - \\[CHARACTER:WHITESPACE\\] Left-justified a string\n\n### **Synopsis**\n```fortran\n  result = adjustl(string)\n```\n```fortran\n   elemental character(len=len(string),kind=KIND) function adjustl(string)\n\n    character(len=*,kind=KIND),intent(in) :: string\n```\n### **Characteristics**\n - **string** is a _character_ variable of any supported kind\n - The return value is a _character_ variable of the same kind\n   and length as **string**\n\n### **Description**\n\n  **adjustl** will left-justify a string by removing leading\n  spaces. Spaces are inserted at the end of the string as needed.\n\n### **Options**\n\n- **string**\n  : the string to left-justify\n\n### **Result**\n\n  A copy of **string** where leading spaces are removed and the same\n  number of spaces are inserted on the end of **string**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_adjustl\nimplicit none\ncharacter(len=20) :: str = '   sample string'\ncharacter(len=:),allocatable :: astr\ninteger :: length\n\n   ! basic use\n    write(*,'(a,\"[\",a,\"]\")') 'original: ',str\n    str=adjustl(str)\n    write(*,'(a,\"[\",a,\"]\")') 'adjusted: ',str\n\n    ! a fixed-length string can be printed\n    ! trimmed using trim(3f) or len_trim(3f)\n    write(*,'(a,\"[\",a,\"]\")') 'trimmed:  ',trim(str)\n    length=len_trim(str)\n    write(*,'(a,\"[\",a,\"]\")') 'substring:',str(:length)\n\n    ! note an allocatable string stays the same length too\n    ! and is not trimmed by just an adjustl(3f) call.\n    astr='    allocatable string   '\n    write(*,'(a,\"[\",a,\"]\")') 'original:',astr\n    astr = adjustl(astr)\n    write(*,'(a,\"[\",a,\"]\")') 'adjusted:',astr\n    ! trim(3f) can be used to change the length\n    astr = trim(astr)\n    write(*,'(a,\"[\",a,\"]\")') 'trimmed: ',astr\n\nend program demo_adjustl\n```\nResults:\n```text\n   original: [   sample string    ]\n   adjusted: [sample string       ]\n   trimmed:  [sample string]\n   substring:[sample string]\n   original:[    allocatable string   ]\n   adjusted:[allocatable string       ]\n   trimmed: [allocatable string]\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**adjustr**(3)](#adjustr),\n[**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ADJUSTR": "## adjustr\n\n### **Name**\n\n**adjustr** - \\[CHARACTER:WHITESPACE\\] Right-justify a string\n\n### **Synopsis**\n```fortran\n  result = adjustr(string)\n```\n```fortran\n   elemental character(len=len(string),kind=KIND) function adjustr(string)\n\n    character(len=*,kind=KIND),intent(in) :: string\n```\n### **Characteristics**\n\n- **string** is a _character_ variable\n- The return value is a _character_ variable of the same kind and\n  length as **string**\n\n### **Description**\n\n**adjustr** right-justifies a string by removing trailing spaces. Spaces\nare inserted at the start of the string as needed to retain the original\nlength.\n\n### **Options**\n\n- **string**\n  : the string to right-justify\n\n### **Result**\n\nTrailing spaces are removed and the same number of spaces are inserted\nat the start of **string**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_adjustr\nimplicit none\ncharacter(len=20) :: str\n   ! print a short number line\n   write(*,'(a)')repeat('1234567890',2)\n\n  ! basic usage\n   str = '  sample string '\n   write(*,'(a)') str\n   str = adjustr(str)\n   write(*,'(a)') str\n\n   !\n   ! elemental\n   !\n   write(*,'(a)')repeat('1234567890',5)\n   write(*,'(a)')adjustr([character(len=50) :: &\n   '  first           ', &\n   '     second       ', &\n   '         third    ' ])\n   write(*,'(a)')repeat('1234567890',5)\n\nend program demo_adjustr\n```\nResults:\n```text\n   12345678901234567890\n     sample string\n          sample string\n   12345678901234567890123456789012345678901234567890\n                                                first\n                                               second\n                                                third\n   12345678901234567890123456789012345678901234567890\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**adjustl**(3)](#adjustl),\n[**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "AIMAG": "## aimag\n\n### **Name**\n\n**aimag** - \\[TYPE:NUMERIC\\] Imaginary part of complex number\n\n### **Synopsis**\n```fortran\n    result = aimag(z)\n```\n```fortran\n     elemental complex(kind=KIND) function aimag(z)\n\n      complex(kind=KIND),intent(in) :: z\n```\n### **Characteristics**\n\n- The type of the argument **z** shall be _complex_ and any supported\n  _complex_ kind\n\n- The return value is of type _real_ with the kind type parameter of\n  the argument.\n\n### **Description**\n\n  **aimag** yields the imaginary part of the complex argument **z**.\n\n  This is similar to the modern complex-part-designator **%IM** which also\n  designates the imaginary part of a value, accept a designator can appear\n  on the left-hand side of an assignment as well, as in **val%im=10.0**.\n\n### **Options**\n\n- **z**\n  : The _complex_ value to extract the imaginary component of.\n\n### **Result**\n\n  The return value is a _real_ value with the magnitude and sign of the\n  imaginary component of the argument **z**.\n\n  That is, If **z** has the value **(x,y)**, the result has the value\n  **y**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_aimag\nuse, intrinsic :: iso_fortran_env, only : real_kinds, &\n & real32, real64, real128\nimplicit none\ncharacter(len=*),parameter :: g='(*(1x,g0))'\ncomplex              :: z4\ncomplex(kind=real64) :: z8\n   ! basics\n    z4 = cmplx(1.e0, 2.e0)\n    print *, 'value=',z4\n    print g, 'imaginary part=',aimag(z4),'or', z4%im\n\n    ! other kinds other than the default may be supported\n    z8 = cmplx(3.e0_real64, 4.e0_real64,kind=real64)\n    print *, 'value=',z8\n    print g, 'imaginary part=',aimag(z8),'or', z8%im\n\n    ! an elemental function can be passed an array\n    print *\n    print *, [z4,z4/2.0,z4+z4,z4**3]\n    print *\n    print *, aimag([z4,z4/2.0,z4+z4,z4**3])\n\nend program demo_aimag\n```\nResults:\n```text\n value= (1.00000000,2.00000000)\n imaginary part= 2.00000000 or 2.00000000\n value= (3.0000000000000000,4.0000000000000000)\n imaginary part= 4.0000000000000000 or 4.0000000000000000\n\n (1.00000000,2.00000000) (0.500000000,1.00000000) (2.00000000,4.00000000)\n (-11.0000000,-2.00000000)\n\n   2.00000000       1.00000000       4.00000000      -2.00000000\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n- [**cmplx**(3)](#cmplx) - Complex conversion function\n- [**conjg**(3)](#conjg) - Complex conjugate function\n- [**real**(3)](#real) - Convert to real type\n\nFortran has strong support for _complex_ values, including many intrinsics\nthat take or produce _complex_ values in addition to algebraic and\nlogical expressions:\n\n[**abs**(3)](#abs),\n[**acosh**(3)](#acosh),\n[**acos**(3)](#acos),\n[**asinh**(3)](#asinh),\n[**asin**(3)](#asin),\n[**atan2**(3)](#atan2),\n[**atanh**(3)](#atanh),\n[**atan**(3)](#atan),\n[**cosh**(3)](#cosh),\n[**cos**(3)](#cos),\n[**co_sum**(3)](#co_sum),\n[**dble**(3)](#dble),\n[**dot_product**(3)](#dot_product),\n[**exp**(3)](#exp),\n[**int**(3)](#int),\n[**is_contiguous**(3)](#is_contiguous),\n[**kind**(3)](#kind),\n[**log**(3)](#log),\n[**matmul**(3)](#matmul),\n[**precision**(3)](#precision),\n[**product**(3)](#product),\n[**range**(3)](#range),\n[**rank**(3)](#rank),\n[**sinh**(3)](#sinh),\n[**sin**(3)](#sin),\n[**sqrt**(3)](#sqrt),\n[**storage_size**(3)](#storage_size),\n[**sum**(3)](#sum),\n[**tanh**(3)](#tanh),\n[**tan**(3)](#tan),\n[**unpack**(3)](#unpack),\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "AINT": "## aint\n\n### **Name**\n\n**aint** - \\[NUMERIC\\] Truncate toward zero to a whole number\n\n### **Synopsis**\n```fortran\n    result = aint(x [,kind])\n```\n```fortran\n     elemental real(kind=KIND) function iaint(x,KIND)\n\n      real(kind=**),intent(in)   :: x\n      integer(kind=**),intent(in),optional :: KIND\n```\n### **Characteristics**\n\n- a kind designated as ** may be any supported kind for the type\n- the result is a real of the default kind unless **kind** is specified.\n- **kind** is an _integer_ initialization expression indicating the\n  kind parameter of the result.\n\n### **Description**\n\n  **aint** truncates its argument toward zero to a whole number.\n\n### **Options**\n\n- **x**\n  : the _real_ value to truncate.\n\n- **kind**\n  : indicates the kind parameter of the result.\n\n### **Result**\n\n  The sign is the same as the sign of **x** unless the magnitude of **x**\n  is less than one, in which case zero is returned.\n\n  Otherwise **aint** returns the largest whole number that does not\n  exceed the magnitude of **x** with the same sign as the input.\n\n  That is, it truncates the value towards zero.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_aint\nuse, intrinsic :: iso_fortran_env, only : sp=>real32, dp=>real64\nimplicit none\nreal(kind=dp) :: x8\n   print *,'basics:'\n   print *,' just chops off the fractional part'\n   print *,  aint(-2.999), aint(-2.1111)\n   print *,' if |x| < 1 a positive zero is returned'\n   print *,  aint(-0.999), aint( 0.9999)\n   print *,' input may be of any real kind'\n   x8 = 4.3210_dp\n   print *, aint(-x8), aint(x8)\n   print *,'elemental:'\n   print *,aint([ &\n    &  -2.7,  -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, &\n    &  0.0,   &\n    &  +0.5,  +1.0, +1.5, +2.0, +2.2, +2.5, +2.7  ])\nend program demo_aint\n```\nResults:\n```text\n basics:\n  just chops off the fractional part\n  -2.000000      -2.000000\n  if |x| < 1 a positive zero is returned\n  0.0000000E+00  0.0000000E+00\n  input may be of any real kind\n  -4.00000000000000        4.00000000000000\n elemental:\n  -2.000000      -2.000000      -2.000000      -2.000000      -1.000000\n  -1.000000      0.0000000E+00  0.0000000E+00  0.0000000E+00   1.000000\n   1.000000       2.000000       2.000000       2.000000       2.000000\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n[**anint**(3)](#anint),\n[**int**(3)](#int),\n[**nint**(3)](#nint),\n[**selected_int_kind**(3)](#selected_int_kind),\n[**ceiling**(3)](#ceiling),\n[**floor**(3)](#floor)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ALL": "## all\n\n### **Name**\n\n**all** - \\[ARRAY:REDUCTION\\] Determines if all the values are true\n\n### **Synopsis**\n```fortran\n   result = all(mask [,dim])\n```\n```fortran\n     function all(mask ,dim)\n\n      logical(kind=KIND),intent(in) :: mask(..)\n      integer,intent(in),optional   :: dim\n      logical(kind=KIND)            :: all(..)\n```\n### **Characteristics**\n\n - **mask** is a _logical_ array\n - **dim** is an _integer_\n - the result is a logical array if **dim** is supplied,\n   otherwise it is a logical scalar. It has the same characteristics\n   as **mask**\n\n### **Description**\n\n  **all** determines if all the values are true in **mask** in the\n  array along dimension **dim** if **dim** is specified; otherwise all\n  elements are tested together.\n\n  This testing type is called a logical conjunction of elements of\n  **mask** along dimension **dim**.\n\n  The mask is generally a _logical_ expression, allowing for comparing\n  arrays and many other common operations.\n\n### **Options**\n\n- **mask**\n  : the logical array to be tested for all elements being _.true_.\n\n- **dim**\n  : **dim** indicates the direction through the elements of **mask**\n  to group elements for testing.\n  : **dim** has a value that lies between one and the rank of **mask**.\n  : The corresponding actual argument shall not be an optional dummy\n  argument.\n  : If **dim** is not present all elements are tested and a single\n  scalar value is returned.\n\n### **Result**\n\n1.  If **dim** is not present **all(mask)** is _.true._ if all elements\n    of **mask** are _.true._. It also is _.true._ if **mask** has zero size;\n    otherwise, it is _.false._ .\n\n2.  If the rank of **mask** is one, then **all(mask, dim)** is equivalent\n    to **all(mask)**.\n\n3.  If the rank of **mask** is greater than one and **dim** is present then\n    **all(mask,dim)** returns an array with the rank (number of\n    dimensions)  of **mask** minus 1. The shape is determined from the\n    shape of **mask** where the **dim** dimension is elided. A value is\n    returned for each set of elements along the **dim** dimension.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_all\nimplicit none\nlogical,parameter :: T=.true., F=.false.\nlogical bool\n\n  ! basic usage\n   ! is everything true?\n   bool = all([ T,T,T ])\n   print *, 'are all values true?', bool\n   bool = all([ T,F,T ])\n   print *, 'are all values true now?', bool\n\n  ! compare matrices, even by a dimension\n   ARRAYS: block\n   integer :: a(2,3), b(2,3)\n    ! set everything to one except one value in b\n    a = 1\n    b = 1\n    b(2,2) = 2\n    ! now compare those two arrays\n    print *,'entire array :', all(a ==  b )\n    print *,'compare columns:', all(a ==  b, dim=1)\n    print *,'compare rows:', all(a ==  b, dim=2)\n  end block ARRAYS\n\nend program demo_all\n```\nResults:\n```text\n >  T\n >  F\n >  entire array : F\n >  compare columns: T F T\n >  compare rows: T F\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**any**(3)](#any)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ALLOCATED": "## allocated\n\n### **Name**\n\n**allocated** - \\[ARRAY:INQUIRY\\] Allocation status of an allocatable entity\n\n### **Synopsis**\n```fortran\n    result = allocated(array|scalar)\n```\n```fortran\n     logical function allocated(array,scalar)\n\n      type(TYPE(kind=**)),allocatable,optional :: array(..)\n      type(TYPE(kind=**)),allocatable,optional :: scalar\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n - **array** may be any allocatable array object of any type.\n - **scalar** may be any allocatable scalar of any type.\n - the result is a default logical scalar\n\n### **Description**\n\n  **allocated** checks the allocation status of both arrays\n  and scalars.\n\n At least one and only one of **array** or **scalar** must be specified.\n\n### **Options**\n\n- **entity**\n  : the _allocatable_ object to test.\n\n### **Result**\n\n  If the argument is allocated then the result is _.true._; otherwise,\n  it returns _.false._.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_allocated\nuse,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32\nimplicit none\nreal(kind=sp), allocatable :: x(:)\ncharacter(len=256) :: message\ninteger :: istat\n  ! basics\n   if( allocated(x)) then\n       write(*,*)'do things if allocated'\n   else\n       write(*,*)'do things if not allocated'\n   endif\n\n   ! if already allocated, deallocate\n   if ( allocated(x) ) deallocate(x,STAT=istat, ERRMSG=message )\n   if(istat.ne.0)then\n      write(*,*)trim(message)\n      stop\n   endif\n\n   ! only if not allocated, allocate\n   if ( .not. allocated(x) ) allocate(x(20))\n\n  ! allocation and intent(out)\n   call intentout(x)\n   write(*,*)'note it is deallocated!',allocated(x)\n\n   contains\n\n   subroutine intentout(arr)\n   ! note that if arr has intent(out) and is allocatable,\n   ! arr is deallocated on entry\n   real(kind=sp),intent(out),allocatable :: arr(:)\n       write(*,*)'note it was allocated in calling program',allocated(arr)\n   end subroutine intentout\n\nend program demo_allocated\n```\nResults:\n```text\n >  do things if not allocated\n >  note it was allocated in calling program F\n >  note it is deallocated! F\n```\n### **Standard**\n\n  Fortran 95. allocatable scalar entities were added in Fortran 2003.\n\n### **See Also**\n\n[**move_alloc**(3)](#move_alloc)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ANINT": "## anint\n\n### **Name**\n\n**anint** - \\[NUMERIC\\] Real nearest whole number\n\n### **Synopsis**\n```fortran\n    result = anint(a [,kind])\n```\n```fortran\n     elemental real(kind=KIND) function anint(x,KIND)\n\n      real(kind=**),intent(in)   :: x\n      integer,intent(in),optional :: KIND\n```\n### **Characteristics**\n\n- **a** is type _real_ of any kind\n- **KIND** is a scalar integer constant expression.\n- the result is type _real_. The kind of the result is the same as **x**\n  unless specified by **kind**.\n\n### **Description**\n\n  **anint** rounds its argument to the nearest whole number.\n\n  Unlike **nint**(3) which returns an _integer_ the full range or real\n  values can be returned (_integer_ types typically have a smaller range\n  of values than _real_ types).\n\n### **Options**\n\n- **a**\n  : the value to round\n\n- **kind**\n  : specifies the kind of the result. The default is the kind of **a**.\n\n### **Result**\n\nThe return value is the real whole number nearest **a**.\n\nIf **a** is greater than zero, **anint(a)**(3) returns **aint(a + 0.5)**.\n\nIf **a** is less than or equal to zero then it returns **aint(a - 0.5)**,\nexcept **aint** specifies that for |**a**| < 1 the result is zero (0).\n\nIt is processor-dependent whether anint(a) returns negative zero when\n-0.5 < a <= -0.0.  Compiler switches are often available which enable\nor disable support of negative zero.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_anint\nuse, intrinsic :: iso_fortran_env, only : real32, real64, real128\nimplicit none\nreal,allocatable :: arr(:)\n\n  ! basics\n   print *, 'ANINT (2.783) has the value 3.0 =>', anint(2.783)\n   print *, 'ANINT (-2.783) has the value -3.0 =>', anint(-2.783)\n\n   print *, 'by default the kind of the output is the kind of the input'\n   print *, anint(1234567890.1234567890e0)\n   print *, anint(1234567890.1234567890d0)\n\n   print *, 'sometimes specifying the result kind is useful when passing'\n   print *, 'results as an argument, for example.'\n   print *, 'do you know why the results are different?'\n   print *, anint(1234567890.1234567890,kind=real64)\n   print *, anint(1234567890.1234567890d0,kind=real64)\n\n  ! elemental\n   print *, 'numbers on a cusp are always the most troublesome'\n   print *, anint([ -2.7, -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, 0.0 ])\n\n   print *, 'negative zero is processor dependent'\n   arr=[ 0.0, 0.1, 0.5, 1.0, 1.5, 2.0, 2.2, 2.5, 2.7 ]\n   print *, anint(arr)\n   arr=[ -0.0, -0.1, -0.5, -1.0, -1.5, -2.0, -2.2, -2.5, -2.7 ]\n   print *, anint(arr)\n\nend program demo_anint\n```\nResults:\n```text\n >  ANINT (2.783) has the value 3.0 =>   3.000000\n >  ANINT (-2.783) has the value -3.0 =>  -3.000000\n >  by default the kind of the output is the kind of the input\n >   1.2345679E+09\n >    1234567890.00000\n >  sometimes specifying the result kind is useful when passing\n >  results as an argument, for example.\n >  do you know why the results are different?\n >    1234567936.00000\n >    1234567890.00000\n >  numbers on a cusp are always the most troublesome\n >   -3.000000      -3.000000      -2.000000      -2.000000      -2.000000\n >   -1.000000      -1.000000      0.0000000E+00\n >  negative zero is processor dependent\n >   0.0000000E+00  0.0000000E+00   1.000000       1.000000       2.000000\n >    2.000000       2.000000       3.000000       3.000000\n >   0.0000000E+00  0.0000000E+00  -1.000000      -1.000000      -2.000000\n >   -2.000000      -2.000000      -3.000000      -3.000000\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n[**aint**(3)](#aint),\n[**int**(3)](#int),\n[**nint**(3)](#nint),\n[**selected_int_kind**(3)](#selected_int_kind),\n[**ceiling**(3)](#ceiling),\n[**floor**(3)](#floor)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n\n",
  "ANY": "## any\n\n### **Name**\n\n**any** - \\[ARRAY:REDUCTION\\] Determines if any of the values in the logical array are _.true._\n\n### **Synopsis**\n```fortran\n    result = any(mask [,dim])\n```\n```fortran\n     function any(mask, dim)\n\n      logical(kind=KIND),intent(in) :: mask(..)\n      integer,intent(in),optional   :: dim\n      logical(kind=KIND)            :: any(..)\n```\n### **Characteristics**\n\n- **mask** is a _logical_ array\n- **dim** is a scalar integer\n- the result is a logical array if **dim** is supplied,\n  otherwise it is a logical scalar.\n\n### **Description**\n\n  **any** determines if any of the values in the logical\n  array **mask** along dimension **dim** are _.true._.\n\n### **Options**\n\n- **mask**\n  : an array of _logical_ expressions or values to be tested in groups\n  or in total for a _.true._ value.\n\n- **dim**\n  : a whole number value that lies between one and **rank(mask)** that\n  indicates to return an array of values along the indicated dimension\n  instead of a scalar answer.\n\n### **Result**\n\n**any(mask)** returns a scalar value of type _logical_ where the kind type\nparameter is the same as the kind type parameter of **mask**. If **dim**\nis present, then **any(mask, dim)** returns an array with the rank of\n**mask** minus 1. The shape is determined from the shape of **mask**\nwhere the **dim** dimension is elided.\n\n1.  **any(mask)** is _.true._ if any element of **mask** is _.true._;\n    otherwise, it is _.false._. It also is _.false._ if **mask** has\n    zero size.\n\n2.  If the rank of **mask** is one, then **any(mask, dim)** is\n    equivalent to **any(mask)**. If the rank is greater than one, then\n    **any(mask, dim)** is determined by applying **any(mask)** to the\n    array sections.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_any\nimplicit none\nlogical,parameter :: T=.true., F=.false.\ninteger           :: a(2,3), b(2,3)\nlogical           :: bool\n  ! basic usage\n   bool = any([F,F,T,F])\n   print *,bool\n   bool = any([F,F,F,F])\n   print *,bool\n  ! fill two integer arrays with values for testing\n   a = 1\n   b = 1\n   b(:,2) = 2\n   b(:,3) = 3\n  ! using any(3) with logical expressions you can compare two arrays\n  ! in a myriad of ways\n   ! first, print where elements of b are bigger than in a\n   call printl( 'first print b > a             ', b > a         )\n   ! now use any() to test\n   call printl( 'any true values?  any(b > a)  ', any(b > a )   )\n   call printl( 'again by columns? any(b > a,1)', any(b > a, 1) )\n   call printl( 'again by rows?    any(b > a,2)', any(b > a, 2) )\ncontains\n! CONVENIENCE ROUTINE. this is not specific to ANY()\nsubroutine printl(title,a)\nuse, intrinsic :: iso_fortran_env, only : &\n & stderr=>ERROR_UNIT,&\n & stdin=>INPUT_UNIT,&\n & stdout=>OUTPUT_UNIT\nimplicit none\n\n!@(#) print small 2d logical scalar, vector, or matrix\n\ncharacter(len=*),parameter   :: all='(*(g0,1x))'\ncharacter(len=*),parameter   :: row='(\" > [ \",*(l1:,\",\"))'\ncharacter(len=*),intent(in)  :: title\nlogical,intent(in)           :: a(..)\ninteger                      :: i\n   write(*,*)\n   write(*,all,advance='no')trim(title),&\n    & ' : shape=',shape(a),',rank=',rank(a),',size=',size(a)\n   ! get size and shape of input\n   select rank(a)\n   rank (0); write(*,'(a)')'(a scalar)'\n      write(*,fmt=row,advance='no')a\n      write(*,'(\" ]\")')\n   rank (1); write(*,'(a)')'(a vector)'\n      do i=1,size(a)\n         write(*,fmt=row,advance='no')a(i)\n         write(*,'(\" ]\")')\n      enddo\n   rank (2); write(*,'(a)')'(a matrix) '\n      do i=1,size(a,dim=1)\n         write(*,fmt=row,advance='no')a(i,:)\n         write(*,'(\" ]\")')\n      enddo\n   rank default\n      write(stderr,*)'*printl* did not expect rank=', rank(a), &\n       & 'shape=', shape(a),'size=',size(a)\n      stop '*printl* unexpected rank'\n   end select\n\nend subroutine printl\n\nend program demo_any\n```\nResults:\n```text\n >  T\n >  F\n >\n > first print b > a : shape=23,rank=2,size=6(a matrix)\n >  > [ F,T,T ]\n >  > [ F,T,T ]\n >\n > any true values?  any(b > a) : shape=,rank=0,size=1(a scalar)\n >  > [ T ]\n >\n > again by columns? any(b > a,1) : shape=3,rank=1,size=3(a vector)\n >  > [ F ]\n >  > [ T ]\n >  > [ T ]\n >\n > again by rows?    any(b > a,2) : shape=2,rank=1,size=2(a vector)\n >  > [ T ]\n >  > [ T ]\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**all**(3)](#all)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ASIN": "## asin\n\n### **Name**\n\n**asin** - \\[MATHEMATICS:TRIGONOMETRIC\\] Arcsine function\n\n### **Synopsis**\n```fortran\n    result = asin(x)\n```\n```fortran\n     elemental TYPE(kind=KIND) function asin(x)\n\n      TYPE(kind=KIND) :: x\n```\n### **Characteristics**\n\n - **TYPE** may be _real_ or _complex_\n - **KIND** may be any kind supported by the associated type.\n - The returned value will be of the same type and kind as the argument.\n\n### **Description**\n\n**asin** computes the arcsine of its argument **x**.\n\nThe arcsine is the inverse function of the sine function. It is commonly\nused in trigonometry when trying to find the angle when the lengths of\nthe hypotenuse and the opposite side of a right triangle are known.\n\n### **Options**\n\n- **x**\n  : The value to compute the arcsine of\n  : The type shall be either _real_ and a magnitude that is less than or\n  equal to one; or be _complex_.\n\n### **Result**\n\n  The result has a value equal to a processor-dependent approximation\n  to arcsin(x).\n\n  If **x** is real the result is _real_ and it is expressed in radians\n  and lies in the range\n```fortran\n        PI/2 <= ASIN (X) <= PI/2.\n```\n  If the argument (and therefore the result) is imaginary the real part\n  of the result is in radians and lies in the range\n```fortran\n    -PI/2 <= real(asin(x)) <= PI/2\n```\n### **Examples**\n\nThe arcsine will allow you to find the measure of a right angle when you\nknow the ratio of the side opposite the angle to the hypotenuse.\n\nSo if you knew that a train track rose 1.25 vertical miles on a track\nthat was 50 miles long, you could determine the average angle of incline\nof the track using the arcsine. Given\n\n     sin(theta) = 1.25 miles/50 miles (opposite/hypotenuse)\n\nSample program:\n```fortran\nprogram demo_asin\nuse, intrinsic :: iso_fortran_env, only : dp=>real64\nimplicit none\n! value to convert degrees to radians\nreal(kind=dp),parameter :: D2R=acos(-1.0_dp)/180.0_dp\nreal(kind=dp)           :: angle, rise, run\ncharacter(len=*),parameter :: all='(*(g0,1x))'\n  ! given sine(theta) = 1.25 miles/50 miles (opposite/hypotenuse)\n  ! then taking the arcsine of both sides of the equality yields\n  ! theta = arcsine(1.25 miles/50 miles) ie. arcsine(opposite/hypotenuse)\n  rise=1.250_dp\n  run=50.00_dp\n  angle = asin(rise/run)\n  print all, 'angle of incline(radians) = ', angle\n  angle = angle/D2R\n  print all, 'angle of incline(degrees) = ', angle\n\n  print all, 'percent grade=',rise/run*100.0_dp\nend program demo_asin\n```\nResults:\n```\n    angle of incline(radians) =    2.5002604899361139E-002\n    angle of incline(degrees) =    1.4325437375665075\n    percent grade=   2.5000000000000000\n```\nThe percentage grade is the slope, written as a percent. To calculate\nthe slope you divide the rise by the run. In the example the rise is\n1.25 mile over a run of 50 miles so the slope is 1.25/50 = 0.025.\nWritten as a percent this is 2.5 %.\n\nFor the US, two and 1/2 percent is generally thought of as the upper\nlimit. This means a rise of 2.5 feet when going 100 feet forward. In\nthe US this was the maximum grade on the first major US railroad, the\nBaltimore and Ohio. Note curves increase the frictional drag on a\ntrain reducing the allowable grade.\n\n### **Standard**\n\nFORTRAN 77 , for a _complex_ argument Fortran 2008\n\n### **See Also**\n\nInverse function: [**sin**(3)](#sin)\n\n### **Resources**\n\n- [wikipedia: inverse trigonometric functions](https://en.wikipedia.org/wiki/Inverse_trigonometric_functions)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ASINH": "## asinh\n\n### **Name**\n\n**asinh** - \\[MATHEMATICS:TRIGONOMETRIC\\] Inverse hyperbolic sine function\n\n### **Synopsis**\n```fortran\n    result = asinh(x)\n```\n```fortran\n     elemental TYPE(kind=KIND) function asinh(x)\n\n      TYPE(kind=KIND) :: x\n```\n### **Characteristics**\n\n - **x** may be any _real_ or _complex_ type\n - **KIND** may be any kind supported by the associated type\n - The returned value will be of the same type and kind as the argument **x**\n\n### **Description**\n\n**asinh** computes the inverse hyperbolic sine of **x**.\n\n### **Options**\n\n- **x**\n  : The value to compute the inverse hyperbolic sine of\n\n### **Result**\n\n  The result has a value equal to a processor-dependent approximation\n  to the inverse hyperbolic sine function of **x**.\n\n  If **x** is _complex_, the imaginary part of the result is in radians and lies\nbetween **-PI/2 \\<= aimag(asinh(x)) \\<= PI/2**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_asinh\nuse,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32\nimplicit none\nreal(kind=dp), dimension(3) :: x = [ -1.0d0, 0.0d0, 1.0d0 ]\n\n   ! elemental\n    write (*,*) asinh(x)\n\nend program demo_asinh\n```\nResults:\n```text\n  -0.88137358701954305  0.0000000000000000  0.88137358701954305\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\nInverse function: [**sinh**(3)](#sinh)\n\n### **Resources**\n\n- [Wikipedia:hyperbolic functions](https://en.wikipedia.org/wiki/Hyperbolic_functions)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ASSOCIATED": "## associated\n\n### **Name**\n\n**associated** - \\[STATE:INQUIRY\\] Association status of a pointer or pointer/target pair\n\n### **Synopsis**\n```fortran\n    result = associated(pointer [,target])\n```\n```fortran\n     logical function associated(pointer,target)\n\n      type(TYPE(kind=KIND)),pointer :: pointer\n      type(TYPE(kind=KIND)),pointer,optional :: target\n```\n### **Characteristics**\n\n - **pointer** shall have the _pointer_ attribute and it can be any type\n   or may be a procedure pointer\n - **target** shall be a pointer or a target. It must have the\n   same type, kind type parameter, and array rank as **pointer**.\n - The association status of neither **pointer** nor **target** shall\n   be undefined.\n - the result is a default _logical_ value\n\n### **Description**\n\n  **associated** determines the status of the pointer **pointer**\n  or if **pointer** is associated with the target **target**.\n\n### **Options**\n\n- **pointer**\n  : A pointer to test for association.\n    Its pointer association status shall not be undefined.\n\n- **target**\n  : A target that is to be tested for occupying the same storage\n  units as the pointer **pointer**. That is, it is tested as to whether it\n  is pointed to by **pointer**.\n\n### **Result**\n\n**associated**(3f) returns a scalar value of type _logical_.\nThere are several cases:\n\n1.  When the optional **target** is not present then **associated(pointer)**\n    is _.true._ if **pointer** is associated with a target; otherwise, it\n    returns _.false._.\n\n2.  If **target** is present and a scalar target, the result is _.true._ if\n    **target** is not a zero-sized storage sequence and the target\n    associated with **pointer** occupies the same storage units. If **pointer**\n    is disassociated, the result is _.false._.\n\n3.  If **target** is present and an array target, the result is _.true._ if\n    **target** and **pointer** have the same shape, are not zero-sized arrays,\n    are arrays whose elements are not zero-sized storage sequences, and\n    **target** and **pointer** occupy the same storage units in array element\n    order.\n\n    As in case 2, the result is _.false._, if **pointer** is disassociated.\n\n4.  If **target** is present and an scalar pointer, the result is _.true._ if\n    **target** is associated with **pointer**, the target associated with **target**\n    are not zero-sized storage sequences and occupy the same storage\n    units.\n\n    The result is _.false._, if either **target** or **pointer** is disassociated.\n\n5.  If **target** is present and an array pointer, the result is _.true._ if\n    target associated with **pointer** and the target associated with **target**\n    have the same shape, are not zero-sized arrays, are arrays whose\n    elements are not zero-sized storage sequences, and **target** and\n    **pointer** occupy the same storage units in array element order.\n\n6.  If **target** is present and is a procedure, the result is true if and\n    only if **pointer** is associated with **target** and, if **target** is an\n    internal procedure, they have the same host instance.\n\n7.  If **target** is present and is a procedure pointer, the result is true\n    if and only if **pointer** and **target** are associated with the same\n    procedure and, if the procedure is an internal procedure, they have\n    the same host instance.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_associated\nimplicit none\nreal, target  :: tgt(2) = [1., 2.]\nreal, pointer :: ptr(:)\n   ptr => tgt\n   if (associated(ptr)     .eqv. .false.) &\n   & stop 'POINTER NOT ASSOCIATED'\n   if (associated(ptr,tgt) .eqv. .false.) &\n   & stop 'POINTER NOT ASSOCIATED TO TARGET'\nend program demo_associated\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**null**(3)](#null)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ATAN": "## atan\n\n### **Name**\n\n**atan** - \\[MATHEMATICS:TRIGONOMETRIC\\] Arctangent AKA inverse tangent function\n\n### **Synopsis**\n```fortran\n    result = atan([x) | atan(y, x)\n```\n```fortran\n     elemental TYPE(kind=KIND) function atan(y,x)\n\n      TYPE(kind=KIND),intent(in) :: x\n      TYPE(kind=**),intent(in),optional :: y\n```\n### **Characteristics**\n\n - If **y** is present **x** and **y** must both be _real_.\n   Otherwise, **x** may be _complex_.\n - **KIND** can be any kind supported by the associated type.\n - The returned value is of the same type and kind as **x**.\n\n### **Description**\n\n**atan** computes the arctangent of **x**.\n\n### **Options**\n\n- **x**\n  : The value to compute the arctangent of.\n  if **y** is present, **x** shall be _real_.\n\n- **y**\n  : is of the same type and kind as **x**. If **x** is zero, **y**\n  must not be zero.\n\n### **Result**\n\nThe returned value is of the same type and kind as **x**. If **y** is\npresent, the result is identical to **atan2(y,x)**. Otherwise, it is the\narc tangent of **x**, where the real part of the result is in radians\nand lies in the range\n**-PI/2 \\<= atan(x) \\<= PI/2**\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_atan\nuse, intrinsic :: iso_fortran_env, only : real_kinds, &\n & real32, real64, real128\nimplicit none\ncharacter(len=*),parameter :: all='(*(g0,1x))'\nreal(kind=real64),parameter :: &\n Deg_Per_Rad = 57.2957795130823208767981548_real64\nreal(kind=real64) :: x\n    x=2.866_real64\n    print all, atan(x)\n\n    print all, atan( 2.0d0, 2.0d0),atan( 2.0d0, 2.0d0)*Deg_Per_Rad\n    print all, atan( 2.0d0,-2.0d0),atan( 2.0d0,-2.0d0)*Deg_Per_Rad\n    print all, atan(-2.0d0, 2.0d0),atan(-2.0d0, 2.0d0)*Deg_Per_Rad\n    print all, atan(-2.0d0,-2.0d0),atan(-2.0d0,-2.0d0)*Deg_Per_Rad\n\nend program demo_atan\n```\nResults:\n```text\n   1.235085437457879\n   .7853981633974483 45.00000000000000\n   2.356194490192345 135.0000000000000\n   -.7853981633974483 -45.00000000000000\n   -2.356194490192345 -135.0000000000000\n```\n### **Standard**\n\nFORTRAN 77  for a complex argument; and for two\narguments Fortran 2008\n\n### **See Also**\n\n[**atan2**(3)](#atan2), [**tan**(3)](#tan)\n\n### **Resources**\n\n- [wikipedia: inverse trigonometric functions](https://en.wikipedia.org/wiki/Inverse_trigonometric_functions)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ATAN2": "## atan2\n\n### **Name**\n\n**atan2** - \\[MATHEMATICS:TRIGONOMETRIC\\] Arctangent (inverse tangent)\nfunction\n\n### **Synopsis**\n```fortran\n    result = atan2(y, x)\n```\n```fortran\n     elemental real(kind=KIND) function atan2(y, x)\n\n      real,kind=KIND) :: atan2\n      real,kind=KIND),intent(in) :: y, x\n```\n### **Characteristics**\n\n - **x** and **y** must be reals of the same kind.\n - The return value has the same type and kind as **y** and **x**.\n\n### **Description**\n\n  **atan2** computes in radians a processor-dependent approximation of\n  the arctangent of the complex number ( **x**, **y** ) or equivalently the\n  principal value of the arctangent of the value **y/x** (which determines\n  a unique angle).\n\n  If **y** has the value zero, **x** shall not have the value zero.\n\n  The resulting phase lies in the range -PI <= ATAN2 (Y,X) <= PI and is equal to a\n  processor-dependent approximation to a value of arctan(Y/X).\n\n### **Options**\n\n- **y**\n  : The imaginary component of the complex value **(x,y)** or the **y**\n  component of the point **\\<x,y\\>**.\n\n- **x**\n  : The real component of the complex value **(x,y)** or the **x**\n  component of the point **\\<x,y\\>**.\n\n### **Result**\n\nThe value returned is by definition the principal value of the complex\nnumber **(x, y)**, or in other terms, the phase of the phasor x+i*y.\n\nThe principal value is simply what we get when we adjust a radian value\nto lie between **-PI** and **PI** inclusive,\n\nThe classic definition of the arctangent is the angle that is formed\nin Cartesian coordinates of the line from the origin point **\\<0,0\\>**\nto the point **\\<x,y\\>** .\n\nPictured as a vector it is easy to see that if **x** and **y** are both\nzero the angle is indeterminate because it sits directly over the origin,\nso **atan(0.0,0.0)** will produce an error.\n\nRange of returned values by quadrant:\n```text\n>                   +PI/2\n>                     |\n>                     |\n>     PI/2 < z < PI   |   0 > z < PI/2\n>                     |\n>   +-PI -------------+---------------- +-0\n>                     |\n>     PI/2 < -z < PI  |   0 < -z < PI/2\n>                     |\n>                     |\n>                   -PI/2\n>\n     NOTES:\n\n     If the processor distinguishes -0 and +0 then the sign of the\n     returned value is that of Y when Y is zero, else when Y is zero\n     the returned value is always positive.\n```\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_atan2\nreal :: z\ncomplex :: c\n !\n ! basic usage\n  ! ATAN2 (1.5574077, 1.0) has the value 1.0 (approximately).\n  z=atan2(1.5574077, 1.0)\n  write(*,*) 'radians=',z,'degrees=',r2d(z)\n !\n ! elemental arrays\n  write(*,*)'elemental',atan2( [10.0, 20.0], [30.0,40.0] )\n !\n ! elemental arrays and scalars\n  write(*,*)'elemental',atan2( [10.0, 20.0], 50.0 )\n !\n ! break complex values into real and imaginary components\n ! (note TAN2() can take a complex type value )\n  c=(0.0,1.0)\n  write(*,*)'complex',c,atan2( x=c%re, y=c%im )\n !\n ! extended sample converting cartesian coordinates to polar\n  COMPLEX_VALS: block\n  real                :: ang, radius\n  complex,allocatable :: vals(:)\n  integer             :: i\n !\n  vals=[ &\n    ( 1.0, 0.0 ), & ! 0\n    ( 1.0, 1.0 ), & ! 45\n    ( 0.0, 1.0 ), & ! 90\n    (-1.0, 1.0 ), & ! 135\n    (-1.0, 0.0 ), & ! 180\n    (-1.0,-1.0 ), & ! 225\n    ( 0.0,-1.0 )]   ! 270\n  do i=1,size(vals)\n     call cartesian_to_polar(vals(i)%re, vals(i)%im, radius,ang)\n     write(*,101)vals(i),ang,r2d(ang),radius\n  enddo\n  101 format(             &\n  & 'X= ',f5.2,           &\n  & ' Y= ',f5.2,          &\n  & ' ANGLE= ',g0,        &\n  & T38,'DEGREES= ',g0.4, &\n  & T54,'DISTANCE=',g0)\n endblock COMPLEX_VALS\n!\ncontains\n!\nelemental real function r2d(radians)\n! input radians to convert to degrees\ndoubleprecision,parameter :: DEGREE=0.017453292519943d0 ! radians\nreal,intent(in)           :: radians\n   r2d=radians / DEGREE ! do the conversion\nend function r2d\n!\nsubroutine cartesian_to_polar(x,y,radius,inclination)\n! return angle in radians in range 0 to 2*PI\nimplicit none\nreal,intent(in)  :: x,y\nreal,intent(out) :: radius,inclination\n   radius=sqrt(x**2+y**2)\n   if(radius.eq.0)then\n      inclination=0.0\n   else\n      inclination=atan2(y,x)\n      if(inclination < 0.0)inclination=inclination+2*atan2(0.0d0,-1.0d0)\n   endif\nend subroutine cartesian_to_polar\n!\nend program demo_atan2\n```\nResults:\n```text\n >  radians=   1.000000     degrees=   57.29578\n >  elemental  0.3217506      0.4636476\n >  elemental  0.1973956      0.3805064\n >  complex (0.0000000E+00,1.000000)   1.570796\n > X=  1.00 Y=  0.00 ANGLE= .000000     DEGREES= .000   DISTANCE=1.000000\n > X=  1.00 Y=  1.00 ANGLE= .7853982    DEGREES= 45.00  DISTANCE=1.414214\n > X=  0.00 Y=  1.00 ANGLE= 1.570796    DEGREES= 90.00  DISTANCE=1.000000\n > X= -1.00 Y=  1.00 ANGLE= 2.356194    DEGREES= 135.0  DISTANCE=1.414214\n > X= -1.00 Y=  0.00 ANGLE= 3.141593    DEGREES= 180.0  DISTANCE=1.000000\n > X= -1.00 Y= -1.00 ANGLE= 3.926991    DEGREES= 225.0  DISTANCE=1.414214\n > X=  0.00 Y= -1.00 ANGLE= 4.712389    DEGREES= 270.0  DISTANCE=1.000000\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n- [**atan**(3)](#atan)\n\n### **Resources**\n\n- [arctan:wikipedia](https://en.wikipedia.org/wiki/Inverse_trigonometric_functions)\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ATANH": "## atanh\n\n### **Name**\n\n**atanh** - \\[MATHEMATICS:TRIGONOMETRIC\\] Inverse hyperbolic tangent function\n\n### **Synopsis**\n```fortran\n    result = atanh(x)\n```\n```fortran\n     elemental TYPE(kind=KIND) function atanh(x)\n\n      TYPE(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **x** may be _real_ or _complex_ of any associated type\n - The returned value will be of the same type and kind as the argument.\n\n### **Description**\n\n  **atanh** computes the inverse hyperbolic tangent of **x**.\n\n### **Options**\n\n- **x**\n  : The type shall be _real_ or _complex_.\n\n### **Result**\n\n  The return value has same type and kind as **x**. If **x** is _complex_, the\n  imaginary part of the result is in radians and lies between\n```fortran\n       **-PI/2 <= aimag(atanh(x)) <= PI/2**\n```\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_atanh\nimplicit none\nreal, dimension(3) :: x = [ -1.0, 0.0, 1.0 ]\n\n   write (*,*) atanh(x)\n\nend program demo_atanh\n```\nResults:\n```text\n >       -Infinity  0.0000000E+00       Infinity\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\nInverse function: [**tanh**(3)](#tanh)\n\n### **Resources**\n\n- [Wikipedia:hyperbolic functions](https://en.wikipedia.org/wiki/Hyperbolic_functions)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ATOMIC_ADD": "## atomic_add\n\n### **Name**\n\n**atomic_add** - \\[ATOMIC\\] Atomic ADD operation\n\n### **Synopsis**\n```fortran\n    call atomic_add (atom, value [,stat] )\n```\n```fortran\n     subroutine atomic_add(atom,value,stat)\n\n      integer(atomic_int_kind)            :: atom[*]\n      integer(atomic_int_kind),intent(in) :: value\n      integer,intent(out),intent(out)     :: stat\n```\n### **Characteristics**\n\n- **atom** is a scalar coarray or coindexed variable of integer type with\n  atomic_int_kind kind.\n\n- **value** is a scalar of the same type as **atom**. If the kind is different, the value\n  is converted to the kind of **atom**.\n\n- **stat** is a Scalar default-kind integer variable.\n\n### **Description**\n\n**atomic_add** atomically adds the value of VAR to the\nvariable **atom**. When **stat** is present and the invocation was successful,\nit is assigned the value 0. If it is present and the invocation has\nfailed, it is assigned a positive value; in particular, for a coindexed\nATOM, if the remote image has stopped, it is assigned the value of\niso_fortran_env's STAT_STOPPED_IMAGE and if the remote image has\nfailed, the value STAT_FAILED_IMAGE.\n\n### **Options**\n\n- **atom**\n  : Scalar coarray or coindexed variable of integer type with\n  atomic_int_kind kind.\n\n- **value**\n  : Scalar of the same type as **atom**. If the kind is different, the value\n  is converted to the kind of **atom**.\n\n- **stat**\n  : (optional) Scalar default-kind integer variable.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_atomic_add\nuse iso_fortran_env\nimplicit none\ninteger(atomic_int_kind) :: atom[*]\n   call atomic_add (atom[1], this_image())\nend program demo_atomic_add\n```\n### **Standard**\n\nTS 18508\n\n### **See Also**\n\n[**atomic_define**(3)](#atomic_define),\n[**atomic_fetch_add**(3)](#atomic_fetch),\n[**atomic_and**(3)](#atomic_and),\n[**atomic_or**(3)](#atomic_or),\n[**atomic_xor**(3)](#atomic_xor)\n**iso_fortran_env**(3),\n\n _fortran-lang intrinsic descriptions_\n",
  "ATOMIC_AND": "## atomic_and\n\n### **Name**\n\n**atomic_and** - \\[ATOMIC:BIT MANIPULATION\\] Atomic bitwise AND operation\n\n### **Synopsis**\n```fortran\n    call atomic_and(atom, value [,stat])\n```\n```fortran\n     subroutine atomic_and(atom,value,stat)\n\n      integer(atomic_int_kind)            :: atom[*]\n      integer(atomic_int_kind),intent(in) :: value\n      integer,intent(out),intent(out)     :: stat\n```\n### **Characteristics**\n\n- **atom** is a scalar coarray or coindexed variable of integer type with\n  atomic_int_kind kind.\n\n- **value** is a scalar of the same type as **atom**. If the kind is different, the value\n  is converted to the kind of **atom**.\n\n- **stat** is a Scalar default-kind integer variable.\n\n### **Description**\n\n**atomic_and** atomically defines **atom** with the bitwise\n**and** between the values of **atom** and **value**. When **stat** is present and the\ninvocation was successful, it is assigned the value 0. If it is present\nand the invocation has failed, it is assigned a positive value; in\nparticular, for a coindexed **atom**, if the remote image has stopped, it is\nassigned the value of iso_fortran_env's stat_stopped_image and if\nthe remote image has failed, the value stat_failed_image.\n\n### **Options**\n\n- **atom**\n  : Scalar coarray or coindexed variable of integer type with\n  atomic_int_kind kind.\n\n- **value**\n  : Scalar of the same type as **atom**. If the kind is different, the value\n  is converted to the kind of **atom**.\n\n- **stat**\n  : (optional) Scalar default-kind integer variable.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_atomic_and\nuse iso_fortran_env\nimplicit none\ninteger(atomic_int_kind) :: atom[*]\n   call atomic_and(atom[1], int(b'10100011101'))\nend program demo_atomic_and\n```\n\n### **Standard**\n\nTS 18508\n\n### **See Also**\n\n[**atomic_fetch_and**(3)](#atomic_fetch_and),\n[**atomic_define**(3)](#atomic_define),\n[**atomic_ref**(3)](#atomic_ref),\n[**atomic_cas**(3)](#atomic_cas),\n**iso_fortran_env**(3),\n[**atomic_add**(3)](#atomic_add),\n[**atomic_or**(3)](#atomic_or),\n[**atomic_xor**(3)](#atomic_xor)\n\n _fortran-lang intrinsic descriptions_\n",
  "ATOMIC_CAS": "## atomic_cas\n\n### **Name**\n\n**atomic_cas** - \\[ATOMIC\\] Atomic compare and swap\n\n### **Synopsis**\n```fortran\n    call atomic_cas (atom, old, compare, new [,stat] )\n```\n```fortran\n     subroutine atomic_cas (atom, old, compare, new, stat)\n```\n### **Characteristics**\n\n### **Description**\n\n**atomic_cas** compares the variable **atom** with the value of\n**compare**; if the value is the same, **atom** is set to the value of\n**new**. Additionally, **old** is set to the value of **atom** that was\nused for the comparison. When **stat** is present and the invocation\nwas successful, it is assigned the value 0. If it is present and the\ninvocation has failed, it is assigned a positive value; in particular,\nfor a coindexed **atom**, if the remote image has stopped, it is assigned\nthe value of iso_fortran_env's stat_stopped_image and if the remote\nimage has failed, the value stat_failed_image.\n\n### **Options**\n\n- **atom**\n  : Scalar coarray or coindexed variable of either integer type with\n  atomic_int_kind kind or logical type with atomic_logical_kind\n  kind.\n\n- **old**\n  : Scalar of the same type and kind as **atom**.\n\n- **compare**\n  : Scalar variable of the same type and kind as **atom**.\n\n- **new**\n  : Scalar variable of the same type as **atom**. If kind is different, the\n  value is converted to the kind of **atom**.\n\n- **stat**\n  : (optional) Scalar default-kind integer variable.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_atomic_cas\nuse iso_fortran_env\nimplicit none\nlogical(atomic_logical_kind) :: atom[*], prev\n   call atomic_cas(atom[1], prev, .false., .true.)\nend program demo_atomic_cas\n```\n\n### **Standard**\n\nTS 18508\n\n### **See Also**\n\n[**atomic_define**(3)](#atomic_define),\n[**atomic_ref**(3)](#atomic_ref),\n[**iso_fortran_env**(3)](#)\n\n _fortran-lang intrinsic descriptions_\n",
  "ATOMIC_DEFINE": "## atomic_define\n\n### **Name**\n\n**atomic_define** - \\[ATOMIC\\] Setting a variable atomically\n\n### **Synopsis**\n```fortran\n    call atomic_define (atom, value [,stat] )\n```\n```fortran\n     subroutine atomic_define(atom, value, stat)\n\n      TYPE(kind=atomic_KIND_kind) :: atom[*]\n      TYPE(kind=KIND) :: value\n      integer,intent(out),optional :: stat\n```\n### **Characteristics**\n\n- **atom**\n  : Scalar coarray or coindexed variable of either integer type with\n  atomic_int_kind kind or logical type with atomic_logical_kind\n  kind.\n\n- **value**\n  : Scalar of the same type as **atom**. If the kind is different, the value\n  is converted to the kind of **atom**.\n\n- **stat**\n  : (optional) Scalar default-kind integer variable.\n\n### **Description**\n\n**atomic_define** defines the variable **atom** with the value\n**value** atomically.\n\n### **Options**\n\n- **atom**\n  : Scalar coarray or coindexed variable to atomically assign the\n  value **value** to.\n  kind.\n\n- **value**\n  : value to assign to **atom**\n\n- **stat**\n  : When **stat** is present and the invocation was\n  successful, it is assigned the value **0**. If it is present and the\n  invocation has failed, it is assigned a positive value; in particular,\n  for a coindexed **atom**, if the remote image has stopped, it is assigned\n  the value of iso_fortran_env's stat_stopped_image and if the remote\n  image has failed, the value stat_failed_image.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_atomic_define\nuse iso_fortran_env\nimplicit none\ninteger(atomic_int_kind) :: atom[*]\n    call atomic_define(atom[1], this_image())\nend program demo_atomic_define\n```\n\n### **Standard**\n\nFortran 2008 ; with **stat**, TS 18508\n\n### **See Also**\n\n[**atomic_ref**(3)](#atomic_ref),\n[**atomic_cas**(3)](#atomic_cas),\n**iso_fortran_env**(3),\n[**atomic_add**(3)](#atomic_add),\n[**atomic_and**(3)](#atomic_and),\n[**atomic_or**(3)](#atomic_or),\n[**atomic_xor**(3)](#atomic_xor)\n\n _fortran-lang intrinsic descriptions_\n",
  "ATOMIC_FETCH_ADD": "## atomic_fetch_add\n\n### **Name**\n\n**atomic_fetch_add** - \\[ATOMIC\\] Atomic ADD operation with prior fetch\n\n### **Synopsis**\n```fortran\n    call atomic_fetch_add(atom, value, old [,stat] )\n```\n```fortran\n     subroutine atomic_fetch_add(atom, value, old, stat)\n```\n### **Characteristics**\n\n### **Description**\n\n**atomic_fetch_add** atomically stores the value of **atom** in **old**\nand adds the value of **var** to the variable **atom**. When **stat** is\npresent and the invocation was successful, it is assigned the value **0**.\nIf it is present and the invocation has failed, it is assigned a positive\nvalue; in particular, for a coindexed **atom**, if the remote image has\nstopped, it is assigned the value of iso_fortran_env's stat_stopped_image\nand if the remote image has failed, the value stat_failed_image.\n\n### **Options**\n\n- **atom**\n  : Scalar coarray or coindexed variable of integer type with\n  atomic_int_kind kind. atomic_logical_kind kind.\n\n- **value**\n  : Scalar of the same type as **atom**. If the kind is different, the value\n  is converted to the kind of **atom**.\n\n- **old**\n  : Scalar of the same type and kind as **atom**.\n\n- **stat**\n  : (optional) Scalar default-kind integer variable.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_atomic_fetch_add\nuse iso_fortran_env\nimplicit none\ninteger(atomic_int_kind) :: atom[*], old\n   call atomic_add(atom[1], this_image(), old)\nend program demo_atomic_fetch_add\n```\n\n### **Standard**\n\nTS 18508\n\n### **See Also**\n\n[**atomic_define**(3)](#atomic_define),\n[**atomic_add**(3)](#atomic_add),\n**iso_fortran_env**(3),\n\n[**atomic_fetch_and**(3)](#atomic_fetch_and),\n[**atomic_fetch_or**(3)](#atomic_fetch_or),\n\n[**atomic_fetch_xor**(3)](#atomic_fetch_xor)\n\n _fortran-lang intrinsic descriptions_\n",
  "ATOMIC_FETCH_AND": "## atomic_fetch_and\n\n### **Name**\n\n**atomic_fetch_and** - \\[ATOMIC:BIT MANIPULATION\\] Atomic bitwise AND operation with prior fetch\n\n### **Synopsis**\n```fortran\n    call atomic_fetch_and(atom, value, old [,stat] )\n```\n```fortran\n     subroutine atomic_fetch_and(atom, value, old, stat)\n```\n### **Characteristics**\n\n### **Description**\n\n**atomic_fetch_and** atomically stores the value of\n**atom** in **old** and defines **atom** with the bitwise AND between the values of\n**atom** and **value**. When **stat** is present and the invocation was successful,\nit is assigned the value **0**. If it is present and the invocation has\nfailed, it is assigned a positive value; in particular, for a coindexed\n**atom**, if the remote image has stopped, it is assigned the value of\niso_fortran_env's stat_stopped_image and if the remote image has\nfailed, the value stat_failed_image.\n\n### **Options**\n\n- **atom**\n  : Scalar coarray or coindexed variable of integer type with\n  atomic_int_kind kind.\n\n- **value**\n  : Scalar of the same type as **atom**. If the kind is different, the value\n  is converted to the kind of **atom**.\n\n- **old**\n  : Scalar of the same type and kind as **atom**.\n\n- **stat**\n  : (optional) Scalar default-kind integer variable.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_atomic_fetch_and\nuse iso_fortran_env\nimplicit none\ninteger(atomic_int_kind) :: atom[*], old\n   call atomic_fetch_and (atom[1], int(b'10100011101'), old)\nend program demo_atomic_fetch_and\n```\n\n### **Standard**\n\nTS 18508\n\n### **See Also**\n\n[**atomic_define**(3)](#atomic_define),\n[**atomic_and**(3)](#atomic_and),\n[**iso_fortran_env**(3)](#),\n\n[**atomic_fetch_add**(3)](#atomic_fetch_add),\n[**atomic_fetch_or**(3)](#atomic_fetch_or),\n\n[**atomic_fetch_xor**(3)](#atomic_fetch_xor)\n\n _fortran-lang intrinsic descriptions_\n",
  "ATOMIC_FETCH_OR": "## atomic_fetch_or\n\n### **Name**\n\n**atomic_fetch_or** - \\[ATOMIC:BIT MANIPULATION\\] Atomic bitwise OR operation with prior fetch\n\n### **Synopsis**\n```fortran\n    call atomic_fetch_or(atom, value, old [,stat] )\n```\n```fortran\n     subroutine atomic_fetch_or(atom, value, old, stat)\n```\n### **Characteristics**\n\n### **Description**\n\n**atomic_fetch_or** atomically stores the value of\n**atom** in **old** and defines **atom** with the bitwise OR between the values of\n**atom** and **value**. When **stat** is present and the invocation was successful,\nit is assigned the value **0**. If it is present and the invocation has\nfailed, it is assigned a positive value; in particular, for a coindexed\n**atom**, if the remote image has stopped, it is assigned the value of\niso_fortran_env's stat_stopped_image and if the remote image has\nfailed, the value stat_failed_image.\n\n### **Options**\n\n- **atom**\n  : Scalar coarray or coindexed variable of integer type with\n  atomic_int_kind kind.\n\n- **value**\n  : Scalar of the same type as **atom**. If the kind is different, the value\n  is converted to the kind of **atom**.\n\n- **old**\n  : Scalar of the same type and kind as **atom**.\n\n- **stat**\n  : (optional) Scalar default-kind integer variable.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_atomic_fetch_or\nuse iso_fortran_env\nimplicit none\ninteger(atomic_int_kind) :: atom[*], old\n   call atomic_fetch_or(atom[1], int(b'10100011101'), old)\nend program demo_atomic_fetch_or\n```\n\n### **Standard**\n\nTS 18508\n\n### **See Also**\n\n[**atomic_define**(3)](#atomic_define),\n[**atomic_or**(3)](#atomic_or),\n[**iso_fortran_env**(3)](#),\n\n[**atomic_fetch_add**(3)](#atomic_fetch_add),\n[**atomic_fetch_and**(3)](#atomic_fetch_and),\n\n[**atomic_fetch_xor**(3)](#atomic_fetch_xor)\n\n _fortran-lang intrinsic descriptions_\n",
  "ATOMIC_FETCH_XOR": "## atomic_fetch_xor\n\n### **Name**\n\n**atomic_fetch_xor** - \\[ATOMIC:BIT MANIPULATION\\] Atomic bitwise XOR operation with prior fetch\n\n### **Synopsis**\n```fortran\n    call atomic_fetch_xor (atom, value, old [,stat] )\n```\n```fortran\n     subroutine atomic_fetch_xor (atom, value, old, stat)\n```\n### **Characteristics**\n\n### **Description**\n\n**atomic_fetch_xor** atomically stores the value of\n**atom** in **old** and defines **atom** with the bitwise **xor** between the values of\n**atom** and **value**. When **stat** is present and the invocation was successful,\nit is assigned the value **0**. If it is present and the invocation has\nfailed, it is assigned a positive value; in particular, for a coindexed\n**atom**, if the remote image has stopped, it is assigned the value of\niso_fortran_env's stat_stopped_image and if the remote image has\nfailed, the value stat_failed_image.\n\n### **Options**\n\n- **atom**\n  : Scalar coarray or coindexed variable of integer type with\n  atomic_int_kind kind.\n\n- **value**\n  : Scalar of the same type as **atom**. If the kind is different, the value\n  is converted to the kind of **atom**.\n\n- **old**\n  : Scalar of the same type and kind as **atom**.\n\n- **stat**\n  : (optional) Scalar default-kind integer variable.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_atomic_fetch_xor\nuse iso_fortran_env\nimplicit none\ninteger(atomic_int_kind) :: atom[*], old\n   call atomic_fetch_xor (atom[1], int(b'10100011101'), old)\nend program demo_atomic_fetch_xor\n```\n\n### **Standard**\n\nTS 18508\n\n### **See Also**\n\n[**atomic_define**(3)](#atomic_define),\n[**atomic_xor**(3)](#atomic_xor),\n[**iso_fortran_env**(3)](#),\n\n[**atomic_fetch_add**(3)](#atomic_fetch_add),\n[**atomic_fetch_and**(3)](#atomic_fetch_and),\n\n[**atomic_fetch_or**(3)](#atomic_fetch_or)\n\n _fortran-lang intrinsic descriptions_\n",
  "ATOMIC_OR": "## atomic_or\n\n### **Name**\n\n**atomic_or** - \\[ATOMIC:BIT MANIPULATION\\] Atomic bitwise OR operation\n\n### **Synopsis**\n```fortran\n    call atomic_or(atom, value [,stat] )\n```\n```fortran\n     subroutine atomic_or(atom,value,stat)\n\n      integer(atomic_int_kind)            :: atom[*]\n      integer(atomic_int_kind),intent(in) :: value\n      integer,intent(out),intent(out)     :: stat\n```\n### **Characteristics**\n\n- **atom** is a scalar coarray or coindexed variable of integer type with\n  atomic_int_kind kind.\n\n- **value** is a scalar of the same type as **atom**. If the kind is different, the value\n  is converted to the kind of **atom**.\n\n- **stat** is a Scalar default-kind integer variable.\n\n### **Description**\n\n**atomic_or** atomically defines **atom** with the bitwise **or**\nbetween the values of **atom** and **value**. When **stat** is present and the\ninvocation was successful, it is assigned the value **0**. If it is present\nand the invocation has failed, it is assigned a positive value; in\nparticular, for a coindexed **atom**, if the remote image has stopped, it is\nassigned the value of iso_fortran_env's stat_stopped_image and if\nthe remote image has failed, the value stat_failed_image.\n\n### **Options**\n\n- **atom**\n  : Scalar coarray or coindexed variable of integer type with\n  atomic_int_kind kind.\n\n- **value**\n  : Scalar of the same type as **atom**. If the kind is different, the value\n  is converted to the kind of **atom**.\n\n- **stat**\n  : (optional) Scalar default-kind integer variable.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_atomic_or\nuse iso_fortran_env\nimplicit none\ninteger(atomic_int_kind) :: atom[*]\n   call atomic_or(atom[1], int(b'10100011101'))\nend program demo_atomic_or\n```\n\n### **Standard**\n\nTS 18508\n\n### **See Also**\n\n[**atomic_define**(3)](#atomic_define),\n[**atomic_fetch_or**(3)](#atomic_fetch),\n\n[**iso_fortran_env**(3)](#),\n[**atomic_add**(3)](#atomic_add),\n[**atomic_or**](#atomic_or),\n\n[**atomic_xor**(3)](#atomic_xor)\n\n _fortran-lang intrinsic descriptions_\n",
  "ATOMIC_REF": "## atomic_ref\n\n### **Name**\n\n**atomic_ref** - \\[ATOMIC\\] Obtaining the value of a variable atomically\n\n### **Synopsis**\n```fortran\n    call atomic_ref(value, atom [,stat] )\n```\n```fortran\n     subroutine atomic_ref(value,atom,stat)\n\n      integer(atomic_int_kind),intent(in) :: value\n      integer(atomic_int_kind)            :: atom[*]\n      integer,intent(out),intent(out)     :: stat\n```\n### **Characteristics**\n\n- **atom** is a scalar coarray or coindexed variable of either integer\n  type with atomic_int_kind kind or logical type with atomic_logical_kind\n  kind.\n\n- **value** is a scalar of the same type as **atom**. If the kind is\n  different, the value is converted to the kind of **atom**.\n\n- **stat** is a Scalar default-kind integer variable.\n\n### **Description**\n\n**atomic_ref** atomically assigns the value of the\nvariable **atom** to **value**. When **stat** is present and the invocation was\nsuccessful, it is assigned the value **0**. If it is present and the\ninvocation has failed, it is assigned a positive value; in particular,\nfor a coindexed **atom**, if the remote image has stopped, it is assigned\nthe value of iso_fortran_env's **stat_stopped_image** and if the remote\nimage has failed, the value **stat_failed_image**.\n\n### **Options**\n\n- **value**\n  : Scalar of the same type as **atom**. If the kind is different, the value\n  is converted to the kind of **atom**.\n\n- **atom**\n  : Scalar coarray or coindexed variable of either integer type with\n  atomic_int_kind kind or logical type with atomic_logical_kind\n  kind.\n\n- **stat**\n  : (optional) Scalar default-kind integer variable.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_atomic_ref\nuse iso_fortran_env\nimplicit none\nlogical(atomic_logical_kind) :: atom[*]\nlogical :: val\n   call atomic_ref( val, atom[1] )\n   if (val) then\n      print *, \"Obtained\"\n   endif\nend program demo_atomic_ref\n```\n\n### **Standard**\n\nFortran 2008 ; with STAT, TS 18508\n\n### **See Also**\n\n[**atomic_define**(3)](#atomic_define),\n[**atomic_cas**(3)](#atomic_cas),\n[**iso_fortran_env**(3)](#),\n\n[**atomic_fetch_add**(3)](#atomic_add),\n[**atomic_fetch_and**(3)](#atomic_and),\n\n[**atomic_fetch_or**(3)](#atomic_or),\n[**atomic_fetch_xor**(3)](#atomic_xor)\n\n _fortran-lang intrinsic descriptions_\n",
  "ATOMIC_XOR": "## atomic_xor\n\n### **Name**\n\n**atomic_xor** - \\[ATOMIC:BIT MANIPULATION\\] Atomic bitwise OR operation\n\n### **Synopsis**\n```fortran\n    call atomic_xor(atom, value [,stat] )\n```\n```fortran\n     subroutine atomic_xor(atom,value,stat)\n\n      integer(atomic_int_kind)            :: atom[*]\n      integer(atomic_int_kind),intent(in) :: value\n      integer,intent(out),intent(out)     :: stat\n```\n### **Characteristics**\n\n- **atom** is a scalar coarray or coindexed variable of integer type with\n  atomic_int_kind kind.\n\n- **value** is a scalar of the same type as **atom**. If the kind is different, the value\n  is converted to the kind of **atom**.\n\n- **stat** is a Scalar default-kind integer variable.\n\n### **Characteristics**\n\n### **Description**\n\n**atomic_xor** atomically defines **atom** with the bitwise\n**xor** between the values of **atom** and **value**. When **stat** is present and the\ninvocation was successful, it is assigned the value **0**. If it is present\nand the invocation has failed, it is assigned a positive value; in\nparticular, for a coindexed **atom**, if the remote image has stopped, it is\nassigned the value of iso_fortran_env's stat_stopped_image and if\nthe remote image has failed, the value stat_failed_image.\n\n### **Options**\n\n- **atom**\n  : Scalar coarray or coindexed variable of integer type with\n  atomic_int_kind kind.\n\n- **value**\n  : Scalar of the same type as **atom**. If the kind is different, the value\n  is converted to the kind of **atom**.\n\n- **stat**\n  : (optional) Scalar default-kind integer variable.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_atomic_xor\nuse iso_fortran_env\nimplicit none\ninteger(atomic_int_kind) :: atom[*]\n   call atomic_xor(atom[1], int(b'10100011101'))\nend program demo_atomic_xor\n```\n\n### **Standard**\n\nTS 18508\n\n### **See Also**\n\n[**atomic_define**(3)](#atomic_define),\n[**atomic_fetch_xor**(3)](#atomic_fetch),\n[**iso_fortran_env**(3)](#),\n[**atomic_add**(3)](#atomic_add),\n[**atomic_or**(3)](#atomic_or),\n[**atomic_xor**](#atomic_xor)\n\n _fortran-lang intrinsic descriptions_\n",
  "BESSEL_J0": "## bessel_j0\n\n### **Name**\n\n**bessel_j0** - \\[MATHEMATICS\\] Bessel function of the first kind of order 0\n\n### **Synopsis**\n```fortran\n    result = bessel_j0(x)\n```\n```fortran\n     elemental real(kind=KIND) function bessel_j0(x)\n\n      real(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - KIND may be any KIND supported by the _real_ type.\n - The result is the same type and kind as **x**.\n\n### **Description**\n\n**bessel_j0** computes the Bessel function of the first kind\nof order **0** of **x**.\n\n### **Options**\n\n- **x**\n  : The value to operate on.\n\n### **Result**\n\nthe Bessel function of the first kind of order **0** of **x**.\nThe result lies in the range **-0.4027 \\<= bessel(0,x) \\<= 1**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_bessel_j0\nuse, intrinsic :: iso_fortran_env, only : real_kinds, &\n& real32, real64, real128\n   implicit none\n   real(kind=real64) :: x\n   x = 0.0_real64\n   x = bessel_j0(x)\n   write(*,*)x\nend program demo_bessel_j0\n```\nResults:\n\n```text\n      1.0000000000000000\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**bessel_j1**(3)](#bessel_j1),\n[**bessel_jn**(3)](#bessel_jn),\n[**bessel_y0**(3)](#bessel_y0),\n[**bessel_y1**(3)](#bessel_y1),\n[**bessel_yn**(3)](#bessel_yn)\n\n _fortran-lang intrinsic descriptions_\n",
  "BESSEL_J1": "## bessel_j1\n\n### **Name**\n\n**bessel_j1** - \\[MATHEMATICS\\] Bessel function of the first kind of order 1\n\n### **Synopsis**\n```fortran\n    result = bessel_j1(x)\n```\n```fortran\n     elemental real(kind=KIND) function bessel_j1(x)\n\n      real(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n -  KIND may be any supported _real_ KIND.\n -  the result is of the same type and kind as **x**\n\n### **Description**\n\n**bessel_j1** computes the Bessel function of the first kind\nof order **1** of **x**.\n\n### **Options**\n\n- **x**\n  : The type shall be _real_.\n\n### **Result**\n\nThe return value is of type _real_ and lies in the range\n**-0.5818 \\<= bessel(0,x) \\<= 0.5818** . It has the same kind as **x**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_bessel_j1\nuse, intrinsic :: iso_fortran_env, only : real_kinds, &\n & real32, real64, real128\nimplicit none\nreal(kind=real64) :: x = 1.0_real64\n   x = bessel_j1(x)\n   write(*,*)x\nend program demo_bessel_j1\n```\nResults:\n```text\n     0.44005058574493350\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**bessel_j0**(3)](#bessel_j0),\n[**bessel_jn**(3)](#bessel_jn),\n[**bessel_y0**(3)](#bessel_y0),\n[**bessel_y1**(3)](#bessel_y1),\n[**bessel_yn**(3)](#bessel_yn)\n\n _fortran-lang intrinsic descriptions_\n",
  "BESSEL_JN": "## bessel_jn\n\n### **Name**\n\n**bessel_jn** - \\[MATHEMATICS\\] Bessel function of the first kind\n\n### **Synopsis**\n```fortran\n    result = bessel_jn(n, x)\n```\n```fortran\n     elemental real(kind=KIND) function bessel_jn(n,x)\n\n      integer(kind=**),intent(in) :: n\n      real(kind=KIND),intent(in) :: x\n```\n - KIND may be any valid value for type _real_\n - **x** is _real_\n - The return value has the same type and kind as **x**.\n\n```fortran\n    result = bessel_jn(n1, n2, x)\n```\n```fortran\n     real(kind=KIND) function bessel_jn(n1, n2, ,x)\n\n     integer(kind=**),intent(in) :: n1\n     integer(kind=**),intent(in) :: n2\n     real(kind=KIND),intent(in) :: x\n```\n  - **n1** is _integer_\n  - **n2** is _integer_\n  - **x** is _real_\n  - The return value has the same type and kind as **x**.\n\n### **Description**\n\n  **bessel_jn( n, x )** computes the Bessel function of the first kind of\n  order **n** of **x**.\n\n  **bessel_jn(n1, n2, x)** returns an array with the Bessel\n  function\\|Bessel functions of the first kind of the orders **n1**\n  to **n2**.\n\n### **Options**\n\n- **n**\n  : a non-negative scalar integer..\n\n- **n1**\n  : a non-negative scalar _integer_.\n\n- **n2**\n  : a non-negative scalar _integer_.\n\n- **x**\n  : Shall be a scalar for **bessel\\_jn(n,x)** or an array\n  For **bessel_jn(n1, n2, x)**.\n\n### **Result**\n\n  The result value of BESSEL_JN (N, X) is a processor-dependent\n  approximation to the Bessel function of the first kind and order N\n  of X.\n\n  The result of BESSEL_JN (N1, N2, X) is a rank-one array with extent\n  MAX (N2-N1+1, 0). Element i of the result value of BESSEL_JN (N1,\n  N2, X) is a processor-dependent approximation to the Bessel function\n  of the first kind and order N1+i-1 of X.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_bessel_jn\nuse, intrinsic :: iso_fortran_env, only : real_kinds, &\n   & real32, real64, real128\nimplicit none\nreal(kind=real64) :: x = 1.0_real64\n    x = bessel_jn(5,x)\n    write(*,*)x\nend program demo_bessel_jn\n```\nResults:\n\n```text\n      2.4975773021123450E-004\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**bessel_j0**(3)](#bessel_j0),\n[**bessel_j1**(3)](#bessel_j1),\n[**bessel_y0**(3)](#bessel_y0),\n[**bessel_y1**(3)](#bessel_y1),\n[**bessel_yn**(3)](#bessel_yn)\n\n _fortran-lang intrinsic descriptions_\n",
  "BESSEL_Y0": "## bessel_y0\n\n### **Name**\n\n**bessel_y0** - \\[MATHEMATICS\\] Bessel function of the second kind of order 0\n\n### **Synopsis**\n```fortran\n    result = bessel_y0(x)\n```\n```fortran\n     elemental real(kind=KIND) function bessel_y0(x)\n\n      real(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - KIND may be any supported _real_ KIND.\n - the result characteristics (type, kind)  are the same as **x**\n\n### **Description**\n\n**bessel_y0** computes the Bessel function of the second\nkind of order 0 of **x**.\n\n### **Options**\n\n- **x**\n  : The type shall be _real_.\n    Its value shall be greater than zero.\n\n### **Result**\n\nThe return value is of type _real_. It has the same kind as **x**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_bessel_y0\nuse, intrinsic :: iso_fortran_env, only : real_kinds, &\n& real32, real64, real128\nimplicit none\n  real(kind=real64) :: x = 0.0_real64\n  x = bessel_y0(x)\n  write(*,*)x\nend program demo_bessel_y0\n```\nResults:\n```text\n                    -Infinity\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**bessel_j0**(3)](#bessel_j0),\n[**bessel_j1**(3)](#bessel_j1),\n[**bessel_jn**(3)](#bessel_jn),\n[**bessel_y1**(3)](#bessel_y1),\n[**bessel_yn**(3)](#bessel_yn)\n\n _fortran-lang intrinsic descriptions_\n",
  "BESSEL_Y1": "## bessel_y1\n\n### **Name**\n\n**bessel_y1** - \\[MATHEMATICS\\] Bessel function of the second kind of order 1\n\n### **Synopsis**\n```fortran\n    result = bessel_y1(x)\n```\n```fortran\n     elemental real(kind=KIND) function bessel_y1(x)\n\n      real(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - KIND may be any supported _real_ KIND.\n - the characteristics (type, kind)  of the result are the same as **x**\n\n### **Description**\n\n**bessel_y1** computes the Bessel function of the second\nkind of order 1 of **x**.\n\n### **Options**\n\n- **x**\n  : The type shall be _real_.\n  Its value shall be greater than zero.\n\n### **Result**\n\nThe return value is _real_. It has the same kind as **x**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_bessel_y1\nuse, intrinsic :: iso_fortran_env, only : real_kinds, &\n& real32, real64, real128\nimplicit none\n  real(kind=real64) :: x = 1.0_real64\n  write(*,*)x, bessel_y1(x)\nend program demo_bessel_y1\n```\nResults:\n```text\n >    1.00000000000000      -0.781212821300289\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**bessel_j0**(3)](#bessel_j0),\n[**bessel_j1**(3)](#bessel_j1),\n[**bessel_jn**(3)](#bessel_jn),\n[**bessel_y0**(3)](#bessel_y0),\n[**bessel_yn**(3)](#bessel_yn)\n\n _fortran-lang intrinsic descriptions_\n",
  "BESSEL_YN": "## bessel_yn\n\n### **Name**\n\n**bessel_yn** - \\[MATHEMATICS\\] Bessel function of the second kind\n\n### **Synopsis**\n```fortran\n    result = bessel_yn(n, x)\n```\n```fortran\n     elemental real(kind=KIND) function bessel_yn(n,x)\n\n      integer(kind=**),intent(in) :: n\n      real(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n - **n** is _integer_\n - **x** is _real_\n - The return value has the same type and kind as **x**.\n\n```fortran\n    result = bessel_yn(n1, n2, x)\n```\n```fortran\n     real(kind=KIND) function bessel_yn(n1, n2, ,x)\n\n      integer(kind=**),intent(in) :: n1\n      integer(kind=**),intent(in) :: n2\n      real(kind=KIND),intent(in) :: x\n```\n - **n1** is _integer_\n - **n2** is _integer_\n - **x** is _real_\n - The return value has the same type and kind as **x**.\n\n### **Description**\n\n  **bessel_yn(n, x)** computes the Bessel function of the second kind\n  of order **n** of **x**.\n\n  **bessel_yn(n1, n2, x)** returns an array with the Bessel\n  function\\|Bessel functions of the first kind of the orders **n1**\n  to **n2**.\n\n### **Options**\n\n- **n**\n  : Shall be a scalar or an array of type _integer_ and non-negative.\n\n- **n1**\n  : Shall be a non-negative scalar of type _integer_ and non-negative.\n\n- **n2**\n  : Shall be a non-negative scalar of type _integer_ and non-negative.\n\n- **x**\n  : A _real_ non-negative value. Note **bessel_yn(n1, n2, x)** is not\n  elemental, in which case it must be a scalar.\n\n### **Result**\n\n  The result value of BESSEL_YN (N, X) is a processor-dependent\n  approximation to the Bessel function of the second kind and order N\n  of X.\n\n  The result of **BESSEL_YN (N1, N2, X)** is a rank-one array with extent\n  **MAX (N2-N1+1, 0)**. Element i of the result value of BESSEL_YN\n  (N1, N2, X) is a processor-dependent approximation to the Bessel\n  function of the second kind and order N1+i-1 of X.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_bessel_yn\nuse, intrinsic :: iso_fortran_env, only : real_kinds, &\n& real32, real64, real128\nimplicit none\nreal(kind=real64) :: x = 1.0_real64\n  write(*,*) x,bessel_yn(5,x)\nend program demo_bessel_yn\n```\nResults:\n\n```text\n      1.0000000000000000       -260.40586662581222\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**bessel_j0**(3)](#bessel_j0),\n[**bessel_j1**(3)](#bessel_j1),\n[**bessel_jn**(3)](#bessel_jn),\n[**bessel_y0**(3)](#bessel_y0),\n[**bessel_y1**(3)](#bessel_y1)\n\n _fortran-lang intrinsic descriptions_\n",
  "BGE": "## bge\n\n### **Name**\n\n**bge** - \\[BIT:COMPARE\\] Bitwise greater than or equal to\n\n### **Synopsis**\n```fortran\n    result = bge(i,j)\n```\n```fortran\n      elemental logical function bge(i, j)\n\n       integer(kind=**),intent(in) :: i\n       integer(kind=**),intent(in) :: j\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n\n - the _integer_ _kind_ of **i** and **j** may not necessarily be\n   the same. In addition, values may be a BOZ constant with a value\n   valid for the _integer_ kind available with the most bits on the\n   current platform.\n\n - The return value is of type default _logical_.\n\n### **Description**\n\n  **bge** Determines whether one _integer_ is bitwise greater than\n  or equal to another.\n\n  The bit-level representation of a value is platform dependent. The\n  endian-ness of a system and whether the system uses a \"two's complement\"\n  representation of signs can affect the results, for example.\n\n  A BOZ constant (Binary, Octal, Hexadecimal) does not have a _kind_\n  or _type_ of its own, so be aware it is subject to truncation when\n  transferred to an _integer_ type. The most bits the constant may\n  contain is limited by the most bits representable by any _integer_\n  kind supported by the compilation.\n\n#### Bit Sequence Comparison\n\n  When bit sequences of unequal length are compared, the shorter sequence\n  is padded with zero bits on the left to the same length as the longer\n  sequence (up to the largest number of bits any available _integer_ kind\n  supports).\n\n  Bit sequences are compared from left to right, one bit at a time,\n  until unequal bits are found or until all bits have been compared and\n  found to be equal.\n\n  The bits are always evaluated in this order, not necessarily from MSB\n  to LSB (most significant bit to least significant bit).\n\n  If unequal bits are found the sequence with zero in the unequal\n  position is considered to be less than the sequence with one in the\n  unequal position.\n\n### **Options**\n\n- **i**\n  : The value to test if >= **j** based on the bit representation\n    of the values.\n\n- **j**\n  : The value to test **i** against.\n\n### **Result**\n\n  Returns _.true._ if **i** is bit-wise greater than **j** and _.false._\n  otherwise.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_bge\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger            :: i\ninteger(kind=int8) :: byte\ninteger(kind=int8),allocatable :: arr1(:), arr2(:)\n\n  ! BASIC USAGE\n   write(*,*)'bge(-127,127)=',bge( -127, 127 )\n   ! on (very common) \"two's complement\" machines that are\n   ! little-endian -127 will be greater than 127\n\n   ! BOZ constants\n   ! BOZ constants are subject to truncation, so make sure\n   ! your values are valid for the integer kind being compared to\n   write(*,*)'bge(b\"0001\",2)=',bge( b\"1\", 2)\n\n  ! ELEMENTAL\n   ! an array and scalar\n   write(*, *)'compare array of values [-128, -0, +0, 127] to 127'\n   write(*, *)bge(int([-128, -0, +0, 127], kind=int8), 127_int8)\n\n   ! two arrays\n   write(*, *)'compare two arrays'\n   arr1=int( [ -127, -0, +0,  127], kind=int8 )\n   arr2=int( [  127,  0,  0, -127], kind=int8 )\n   write(*,*)'arr1=',arr1\n   write(*,*)'arr2=',arr2\n   write(*, *)'bge(arr1,arr2)=',bge( arr1, arr2 )\n\n  ! SHOW TESTS AND BITS\n   ! actually looking at the bit patterns should clarify what affect\n   ! signs have ...\n   write(*,*)'Compare some one-byte values to 64.'\n   write(*,*)'Notice that the values are tested as bits not as integers'\n   write(*,*)'so the results are as if values are unsigned integers.'\n   do i=-128,127,32\n      byte=i\n      write(*,'(sp,i0.4,*(1x,1l,1x,b0.8))')i,bge(byte,64_int8),byte\n   enddo\n\n  ! SIGNED ZERO\n   ! are +0 and -0 the same on your platform? When comparing at the\n   ! bit level this is important\n   write(*,'(\"plus zero=\",b0)')  +0\n   write(*,'(\"minus zero=\",b0)') -0\n\nend program demo_bge\n```\nResults:\n\n  How an integer value is represented at the bit level can vary. These\n  are just the values expected on Today's most common platforms ...\n\n```text\n    > bge(-127,127)= T\n    > bge(b\"0001\",2)= F\n    > compare array of values [-128, -0, +0, 127] to 127\n    > T F F T\n    > compare two arrays\n    > arr1= -127    0    0  127\n    > arr2=  127    0    0 -127\n    > bge(arr1,arr2)= T T T F\n    > Compare some one-byte values to 64.\n    > Notice that the values are tested as bits not as integers\n    > so the results are as if values are unsigned integers.\n    > -0128  T 10000000\n    > -0096  T 10100000\n    > -0064  T 11000000\n    > -0032  T 11100000\n    > +0000  F 00000000\n    > +0032  F 00100000\n    > +0064  T 01000000\n    > +0096  T 01100000\n    > plus zero=0\n    > minus zero=0\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**bgt**(3)](#bgt),\n[**ble**(3)](#ble),\n[**blt**(3)](#blt)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "BGT": "## bgt\n\n### **Name**\n\n**bgt** - \\[BIT:COMPARE\\] Bitwise greater than\n\n### **Synopsis**\n```fortran\n    result = bgt(i, j)\n```\n```fortran\n      elemental logical function bgt(i, j)\n\n       integer(kind=**),intent(in) :: i\n       integer(kind=**),intent(in) :: j\n```\n### **Characteristics**\n\n - **i** is an _integer_ or a boz-literal-constant.\n - **j** is an _integer_ or a boz-literal-constant.\n - a kind designated as ** may be any supported kind for the type\n   The _integer_ _kind_ of **i** and **j** may not necessarily be the same.\n   kind. In addition, values may be a BOZ constant with a value valid\n   for the _integer_ kind available with the most bits on the current\n   platform.\n - The return value is of type _logical_ and of the default kind.\n\n### **Description**\n\n  **bgt** determines whether an integer is bitwise greater than another.\n  Bit-level representations of values are platform-dependent.\n\n### **Options**\n\n- **i**\n  : reference value to compare against\n\n- **j**\n  : value to compare to **i**\n\n### **Result**\n\n  The return value is of type _logical_ and of the default kind. The\n  result is true if the sequence of bits represented by _i_ is greater\n  than the sequence of bits represented by _j_, otherwise the result\n  is false.\n\n  Bits are compared from right to left.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_bgt\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger            :: i\ninteger(kind=int8) :: byte\n  ! Compare some one-byte values to 64.\n   ! Notice that the values are tested as bits not as integers\n   ! so sign bits in the integer are treated just like any other\n   write(*,'(a)') 'we will compare other values to 64'\n   i=64\n   byte=i\n   write(*,'(sp,i0.4,*(1x,1l,1x,b0.8))')i,bgt(byte,64_int8),byte\n\n   write(*,'(a)') \"comparing at the bit level, not as whole numbers.\"\n   write(*,'(a)') \"so pay particular attention to the negative\"\n   write(*,'(a)') \"values on this two's complement platform ...\"\n   do i=-128,127,32\n      byte=i\n      write(*,'(sp,i0.4,*(1x,1l,1x,b0.8))')i,bgt(byte,64_int8),byte\n   enddo\n\n   ! see the BGE() description for an extended description\n   ! of related information\n\nend program demo_bgt\n```\nResults:\n```text\n > we will compare other values to 64\n > +0064  F 01000000\n > comparing at the bit level, not as whole numbers.\n > so pay particular attention to the negative\n > values on this two's complement platform ...\n > -0128  T 10000000\n > -0096  T 10100000\n > -0064  T 11000000\n > -0032  T 11100000\n > +0000  F 00000000\n > +0032  F 00100000\n > +0064  F 01000000\n > +0096  T 01100000\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**bge**(3)](#bge),\n[**ble**(3)](#ble),\n[**blt**(3)](#blt)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "BIT_SIZE": "## bit_size\n\n### **Name**\n\n**bit_size** - \\[BIT:INQUIRY\\] Bit size inquiry function\n\n### **Synopsis**\n```fortran\n    result = bit_size(i)\n```\n```fortran\n     integer(kind=KIND) function bit_size(i)\n\n      integer(kind=KIND),intent(in) :: i(..)\n```\n### **Characteristics**\n\n - **i** shall be of type integer. It may be a scalar or an array.\n - the value of **KIND** is any valid value for an _integer_ kind\n   parameter on the processor.\n - the return value is a scalar of the same kind as the input value.\n\n### **Description**\n\n  **bit_size** returns the number of bits (integer precision plus\n  sign bit) represented by the type of the _integer_ **i**.\n\n### **Options**\n\n- **i**\n  : An _integer_ value of any kind whose size in bits is to be determined.\n  Because only the type of the argument is examined, the argument need not\n  be defined; **i** can be a scalar or an array, but a scalar representing\n  just a single element is always returned.\n\n### **Result**\n\nThe number of bits used to represent a value of the type and kind\nof _i_. The result is a _integer_ scalar of the same kind as _i_.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_bit_size\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nuse,intrinsic :: iso_fortran_env, only : integer_kinds\nimplicit none\ncharacter(len=*),parameter   :: fmt=&\n& '(a,\": bit size is \",i3,\" which is kind=\",i3,\" on this platform\")'\n\n    ! default integer bit size on this platform\n    write(*,fmt) \"default\", bit_size(0), kind(0)\n\n    write(*,fmt) \"int8   \", bit_size(0_int8),   kind(0_int8)\n    write(*,fmt) \"int16  \", bit_size(0_int16),  kind(0_int16)\n    write(*,fmt) \"int32  \", bit_size(0_int32),  kind(0_int32)\n    write(*,fmt) \"int64  \", bit_size(0_int64),  kind(0_int64)\n\n    write(*,'(a,*(i0:,\", \"))') \"The available kinds are \",integer_kinds\n\nend program demo_bit_size\n```\nTypical Results:\n```text\n    default: bit size is  32 which is kind=  4 on this platform\n    int8   : bit size is   8 which is kind=  1 on this platform\n    int16  : bit size is  16 which is kind=  2 on this platform\n    int32  : bit size is  32 which is kind=  4 on this platform\n    int64  : bit size is  64 which is kind=  8 on this platform\n    The available kinds are 1, 2, 4, 8, 16\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[****(3)](#)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "BLE": "## ble\n\n### **Name**\n\n**ble** - \\[BIT:COMPARE\\] Bitwise less than or equal to\n\n### **Synopsis**\n```fortran\n    result = ble(i,j)\n```\n```fortran\n     elemental logical function ble(i, j)\n\n      integer(kind=**),intent(in) :: i\n      integer(kind=**),intent(in) :: j\n```\n### **Characteristics**\n\n - **i** and **j** may be of any supported _integer_ kind, not\n   necessarily the same. An exception is that values may be a\n   BOZ constant with a value valid for the _integer_ kind available with\n   the most bits on the current platform.\n - the returned value is a logical scalar of default kind\n\n### **Description**\n\n  **ble** determines whether an integer is bitwise less than or\n  equal to another, assuming any shorter value is padded on the left\n  with zeros to the length of the longer value.\n\n### **Options**\n\n- **i**\n  : the value to compare **j** to\n\n- **j**\n  : the value to be tested for being less than or equal to **i**\n\n### **Result**\n\nThe return value is _.true._ if any bit in **j** is less than any bit\nin **i** starting with the rightmost bit and continuing tests leftward.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_ble\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger            :: i\ninteger(kind=int8) :: byte\n  ! Compare some one-byte values to 64.\n   ! Notice that the values are tested as bits not as integers\n   ! so sign bits in the integer are treated just like any other\n   do i=-128,127,32\n      byte=i\n      write(*,'(sp,i0.4,*(1x,1l,1x,b0.8))')i,ble(byte,64_int8),byte\n      write(*,'(sp,i0.4,*(4x,b0.8))')64_int8,64_int8\n   enddo\n\n   ! see the BGE() description for an extended description\n   ! of related information\n\nend program demo_ble\n```\nResults:\n```text\n   -0128  F 10000000\n   +0064    01000000\n   -0096  F 10100000\n   +0064    01000000\n   -0064  F 11000000\n   +0064    01000000\n   -0032  F 11100000\n   +0064    01000000\n   +0000  T 00000000\n   +0064    01000000\n   +0032  T 00100000\n   +0064    01000000\n   +0064  T 01000000\n   +0064    01000000\n   +0096  F 01100000\n   +0064    01000000\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**bge**(3)](#bge),\n[**bgt**(3)](#bgt),\n[**blt**(3)](#blt)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "BLT": "## blt\n\n### **Name**\n\n**blt** - \\[BIT:COMPARE\\] Bitwise less than\n\n### **Synopsis**\n```fortran\n    result = blt(i,j)\n```\n```fortran\n     elemental logical function blt(i, j)\n\n      integer(kind=**),intent(in) :: i\n      integer(kind=**),intent(in) :: j\n```\n### **Characteristics**\n\n  - **i** is an _integer_ of any kind or a BOZ-literal-constant\n  - **j** is an _integer_ of any kind or a BOZ-literal-constant, not\n    necessarily the same as **i**.\n  - the result is of default logical kind\n\n  BOZ constants must have a value valid for the _integer_ kind available\n  with the most bits on the current platform.\n\n### **Description**\n\n  **blt** determines whether an _integer_ is bitwise less than another.\n\n\n### **Options**\n\n- **i**\n  : Shall be of _integer_ type or a BOZ literal constant.\n\n- **j**\n  : Shall be of _integer_ type or a BOZ constant.\n\n### **Result**\n\nThe return value is of type _logical_ and of the default kind.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_blt\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger            :: i\ninteger(kind=int8) :: byte\n  ! Compare some one-byte values to 64.\n   ! Notice that the values are tested as bits not as integers\n   ! so sign bits in the integer are treated just like any other\n   do i=-128,127,32\n      byte=i\n      write(*,'(sp,i0.4,*(1x,1l,1x,b0.8))')i,blt(byte,64_int8),byte\n   enddo\n  ! BOZ literals\n   write(*,*)blt(z'1000', z'101011010')\n   ! see the BGE() description for an extended description\n   ! of related information\n\nend program demo_blt\n```\nResults:\n```text\n   > -0128  F 10000000\n   > -0096  F 10100000\n   > -0064  F 11000000\n   > -0032  F 11100000\n   > +0000  T 00000000\n   > +0032  T 00100000\n   > +0064  F 01000000\n   > +0096  F 01100000\n   > T\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**bge**(3)](#bge),\n[**bgt**(3)](#bgt),\n[**ble**(3)](#ble)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "BTEST": "## btest\n\n### **Name**\n\n**btest** - \\[BIT:INQUIRY\\] Tests a bit of an _integer_ value.\n\n### **Synopsis**\n```fortran\n    result = btest(i,pos)\n```\n```fortran\n     elemental logical function btest(i,pos)\n\n      integer(kind=**),intent(in)  :: i\n      integer(kind=**),intent(in)  :: pos\n```\n### **Characteristics**\n\n - **i** is an _integer_ of any kind\n - **pos** is a _integer_ of any kind\n - the result is a default logical\n\n### **Description**\n\n  **btest** returns logical _.true._ if the bit at **pos** in **i** is\n  set to 1.  Position zero is the right-most bit. Bit position increases\n  from right to left up to **bitsize(i)-1**.\n\n### **Options**\n\n- **i**\n  : The _integer_ containing the bit to be tested\n\n- **pos**\n  : The position of the bit to query. it must be a valid position for the\n  value **i**; ie. **0 <= pos <= bit_size(i)**.\n\n### **Result**\n\n  The result is a _logical_ that has the value _.true._ if bit position\n  **pos** of **i** has the value **1** and the value _.false._ if bit\n  **pos** of **i** has the value **0**.\n\n  Positions of bits in the sequence are numbered from right to left,\n  with the position of the rightmost bit being zero.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_btest\nimplicit none\ninteger :: i, j, pos, a(2,2)\nlogical :: bool\ncharacter(len=*),parameter :: g='(*(g0))'\n\n     i = 32768 + 1024 + 64\n    write(*,'(a,i0,\"=>\",b32.32,/)')'Looking at the integer: ',i\n\n    ! looking one bit at a time from LOW BIT TO HIGH BIT\n    write(*,g)'from bit 0 to bit ',bit_size(i),'==>'\n    do pos=0,bit_size(i)-1\n        bool = btest(i, pos)\n        write(*,'(l1)',advance='no')bool\n    enddo\n    write(*,*)\n\n    ! a binary format the hard way.\n    ! Note going from bit_size(i) to zero.\n    write(*,*)\n    write(*,g)'so for ',i,' with a bit size of ',bit_size(i)\n    write(*,'(b32.32)')i\n    write(*,g)merge('^','_',[(btest(i,j),j=bit_size(i)-1,0,-1)])\n    write(*,*)\n    write(*,g)'and for ',-i,' with a bit size of ',bit_size(i)\n    write(*,'(b32.32)')-i\n    write(*,g)merge('^','_',[(btest(-i,j),j=bit_size(i)-1,0,-1)])\n\n    ! elemental:\n    !\n    a(1,:)=[ 1, 2 ]\n    a(2,:)=[ 3, 4 ]\n    write(*,*)\n    write(*,'(a,/,*(i2,1x,i2,/))')'given the array a ...',a\n    ! the second bit of all the values in a\n    write(*,'(a,/,*(l2,1x,l2,/))')'the value of btest (a, 2)',btest(a,2)\n    ! bits 1,2,3,4 of the value 2\n    write(*,'(a,/,*(l2,1x,l2,/))')'the value of btest (2, a)',btest(2,a)\nend program demo_btest\n```\nResults:\n```text\n  > Looking at the integer: 33856=>11111111111111110111101111000000\n  >\n  > 00000000000000001000010001000000\n  > 11111111111111110111101111000000\n  > 1000010001000000\n  > 11111111111111110111101111000000\n  > from bit 0 to bit 32==>\n  > FFFFFFTFFFTFFFFTFFFFFFFFFFFFFFFF\n  >\n  > so for 33856 with a bit size of 32\n  > 00000000000000001000010001000000\n  > ________________^____^___^______\n  >\n  > and for -33856 with a bit size of 32\n  > 11111111111111110111101111000000\n  > ^^^^^^^^^^^^^^^^_^^^^_^^^^______\n  >\n  > given the array a ...\n  >  1  3\n  >  2  4\n  >\n  > the value of btest (a, 2)\n  >  F  F\n  >  F  T\n  >\n  > the value of btest (2, a)\n  >  T  F\n  >  F  F\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**iand**(3)](#iand),\n[**ibclr**(3)](#ibclr),\n[**ibits**(3)](#ibits),\n[**ibset**(3)](#ibset),\n[**ieor**(3)](#ieor),\n[**ior**(3)](#ior),\n[**mvbits**(3)](#mvbits),\n[**not**(3)](#not)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "CEILING": "## ceiling\n\n### **Name**\n\n**ceiling** - \\[NUMERIC\\] Integer ceiling function\n\n### **Synopsis**\n```fortran\n    result = ceiling(a [,kind])\n```\n```fortran\n     elemental integer(KIND) function ceiling(a,KIND)\n\n      real(kind=**),intent(in)  :: a\n      integer,intent(in),optional :: KIND\n```\n### **Characteristics**\n\n - ** a is of type _real_\n - **KIND** shall be a scalar integer constant expression.\n   It specifies the kind of the result if present.\n - the result is _integer_. It is default kind if **KIND** is not\n   specified\n\n### **Description**\n\n  **ceiling** returns the least integer greater than or equal to **a**.\n\n  On the number line -n <-- 0 -> +n the value returned is always at or\n  to the right of the input value.\n\n### **Options**\n\n- **a**\n  : A _real_ value to produce a ceiling for.\n\n- **kind**\n  : indicates the kind parameter of the result.\n\n### **Result**\n\n  The result will be the _integer_ value equal to **a** or the least\n  integer greater than **a** if the input value is not equal to a\n  whole number.\n\n  If **a** is equal to a whole number, the returned value is **int(a)**.\n\n  The result is undefined if it cannot be represented in the specified\n  _integer_ type.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_ceiling\nimplicit none\n! just a convenient format for a list of integers\ncharacter(len=*),parameter :: ints='(*(\"   > \",5(i0:,\",\",1x),/))'\nreal :: x\nreal :: y\n  ! basic usage\n   x = 63.29\n   y = -63.59\n   print ints, ceiling(x)\n   print ints, ceiling(y)\n   ! note the result was the next integer larger to the right\n\n  ! real values equal to whole numbers\n   x = 63.0\n   y = -63.0\n   print ints, ceiling(x)\n   print ints, ceiling(y)\n\n  ! elemental (so an array argument is allowed)\n   print ints , &\n   & ceiling([ &\n   &  -2.7,  -2.5, -2.2, -2.0, -1.5, &\n   &  -1.0,  -0.5,  0.0, +0.5, +1.0, &\n   &  +1.5,  +2.0, +2.2, +2.5, +2.7  ])\n\nend program demo_ceiling\n```\nResults:\n```text\n   > 64\n   > -63\n   > 63\n   > -63\n   > -2, -2, -2, -2, -1,\n   > -1, 0, 0, 1, 1,\n   > 2, 2, 3, 3, 3\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**floor**(3)](#floor),\n[**nint**(3)](#nint)\n\n[**aint**(3)](#aint),\n[**anint**(3)](#anint),\n[**int**(3)](#int),\n[**selected_int_kind**(3)](#selected_int_kind)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "CHAR": "## char\n\n### **Name**\n\n**char** - \\[CHARACTER\\] Generate a character from a code value\n\n### **Synopsis**\n```fortran\n    result = char(i [,kind])\n```\n```fortran\n     elemental character(kind=KIND) function char(i,KIND)\n\n      integer(kind=**),intent(in) :: i\n      integer(kind=**),intent(in),optional :: KIND\n```\n### **Characteristics**\n\n  - a kind designated as ** may be any supported kind for the type\n  - **i** is an _integer_ of any kind\n  - **kind** is an _integer_ initialization expression indicating the kind\n    parameter of the result.\n  - The returned value is a character with the kind specified by **kind**\n    or if **kind** is not present, the default _character_ kind.\n\n### **Description**\n  Generates a _character_ value given a numeric code representing the\n  position **i** in the collating sequence associated with the specified\n  kind **kind**.\n\n  Note that **achar**(3) is a similar function specifically for ASCII\n  characters that is preferred when only ASCII is being processed,\n  which is equivalent to **char(i,kind=selected_char_kind(\"ascii\") )**\n\n  The **ichar**(3) function is the reverse of **char**, converting\n  characters to their collating sequence value.\n\n<!--\n   ICHAR (CHAR (I, KIND (C))) shall have the value I for 0 <= I <= n - 1 and\n  CHAR (ICHAR (C), KIND (C)) shall have the value C for any character C capable of representation in the\n  processor.\n-->\n\n### **Options**\n\n- **i**\n  : a value in the range **0 <= I <= n-1**, where **n** is the number of characters\n  in the collating sequence associated with the specified kind type parameter.\n  : For ASCII, **n** is 127. The default character set may or may not allow higher\n  values.\n\n- **kind**\n  : A constant _integer_ initialization expression indicating the kind\n  parameter of the result. If not present, the default kind is assumed.\n\n### **Result**\n\nThe return value is a single _character_ of the specified kind, determined by the\nposition of **i** in the collating sequence associated with the specified **kind**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_char\nimplicit none\ninteger, parameter :: ascii =  selected_char_kind (\"ascii\")\ncharacter(len=1, kind=ascii ) :: c\ninteger :: i\n  ! basic\n   i=74\n   c=char(i)\n   write(*,*)'ASCII character ',i,'is ',c\n  !\n   print *, 'a selection of ASCII characters (shows hex if not printable)'\n   do i=0,127,10\n      c = char(i,kind=ascii)\n      select case(i)\n      case(32:126)\n         write(*,'(i3,1x,a)')i,c\n      case(0:31,127)\n         ! print hexadecimal value for unprintable characters\n         write(*,'(i3,1x,z2.2)')i,c\n      case default\n         write(*,'(i3,1x,a,1x,a)')i,c,'non-standard ASCII'\n      end select\n   enddo\n\nend program demo_char\n```\nResults:\n```text\n    ASCII character           74 is J\n    a selection of ASCII characters (shows hex if not printable)\n     0 00\n    10 0A\n    20 14\n    30 1E\n    40 (\n    50 2\n    60 <\n    70 F\n    80 P\n    90 Z\n   100 d\n   110 n\n   120 x\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n[**achar**(3)](#achar),\n[**iachar**(3)](#iachar),\n[**ichar**(3)](#ichar)\n\nFunctions that perform operations on character strings, return lengths\nof arguments, and search for certain arguments:\n\n- **Elemental:**\n  [**adjustl**(3)](#adjustl), [**adjustr**(3)](#adjustr), [**index**(3)](#index),\n  [**scan**(3)](#scan), [**verify**(3)](#verify)\n\n- **Nonelemental:**\n  [**len_trim**(3)](#len_trim),\n  [**len**(3)](#len),\n  [**repeat**(3)](#repeat), [**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "CMPLX": "## cmplx\n\n### **Name**\n\n**cmplx** - \\[TYPE:NUMERIC\\] Conversion to a complex type\n\n### **Synopsis**\n```fortran\n    result = cmplx(x [,kind]) | cmplx(x [,y] [,kind])\n```\n```fortran\n     elemental complex(kind=KIND) function cmplx( x, y, kind )\n\n      type(TYPE(kind=**)),intent(in)          :: x\n      type(TYPE(kind=**)),intent(in),optional :: y\n      integer(kind=**),intent(in),optional    :: KIND\n```\n### **Characteristics**\n\n- **x** may be _integer_, _real_, or _complex_.\n- **y** may be _integer_ or _real_.\n  **y** is allowed only if **x** is not _complex_.\n- **KIND** is a constant _integer_ initialization expression indicating the kind\n  parameter of the result.\n\nThe type of the arguments does not affect the kind of the result except\nfor a _complex_ **x** value.\n\n- if **kind** is not present and **x** is _complex_ the result is of the kind\n  of **x**.\n\n- if **kind** is not present and **x** is not _complex_ the result if of default\n  _complex_ kind.\n\nNOTE: a kind designated as ** may be any supported kind for the type\n\n### **Description**\n\nThe **cmplx** function converts numeric values to a _complex_ value.\n\nEven though constants can be used to define a complex variable using syntax like\n```fortran\n      z = (1.23456789, 9.87654321)\n```\nthis will not work for variables. So you cannot enter\n```fortran\n      z = (a, b)  ! NO ! (unless a and b are constants, not variables)\n```\nso to construct a _complex_ value using non-complex values you must use\nthe **cmplx** function:\n```fortran\n      z = cmplx(a, b)\n```\nor assign values separately to the imaginary and real components using\nthe **%IM** and **%RE** designators:\n```fortran\n      z%re = a\n      z%im = b\n```\nIf **x** is complex **y** is not allowed and **cmplx** essentially\nreturns the input value except for an optional change of kind, which can be\nuseful when passing a value to a procedure that requires the arguments\nto have a different kind (and does not return an altered value):\n```fortran\n      call something(cmplx(z,kind=real64))\n```\nwould pass a copy of a value with kind=real64 even if z had a different kind\n\nbut otherwise is equivalent to a simple assign. So if z1 and z2 were _complex_:\n```fortran\n      z2 = z1        ! equivalent statements\n      z2 = cmplx(z1)\n```\nIf **x** is not _complex_ **x** is only used to define the real component\nof the result but **y** is still optional -- the imaginary part of the\nresult will just be assigned a value of zero.\n\nIf **y** is present it is converted to the imaginary component.\n\n#### **cmplx(3) and double precision**\n\nPrimarily in order to maintain upward compatibility you need to be careful\nwhen working with complex values of higher precision that the default.\n\nIt was necessary for Fortran to continue to specify that **cmplx**\nalways return a result of the default kind if the **kind** option\nis absent, since that is the behavior mandated by FORTRAN 77.\n\nIt might have been preferable to use the highest precision of the\narguments for determining the return kind, but that is not the case. So\nwith arguments with greater precision than default values you are\nrequired to use the **kind** argument or the greater precision values\nwill be reduced to default precision.\n\nThis means **cmplx(d1,d2)**, where **d1** and **d2** are\n_doubleprecision_, is treated as:\n```fortran\n      cmplx(sngl(d1), sngl(d2))\n```\nwhich looses precision.\n\nSo Fortran 90 extends the **cmplx** intrinsic by adding an extra\nargument used to specify the desired kind of the complex result.\n\n```fortran\n      integer,parameter :: dp=kind(0.0d0)\n      complex(kind=dp) :: z8\n     ! wrong ways to specify constant values\n      ! note this was stored with default real precision !\n      z8 = cmplx(1.2345678901234567d0, 1.2345678901234567d0)\n      print *, 'NO, Z8=',z8,real(z8),aimag(z8)\n\n      z8 = cmplx(1.2345678901234567e0_dp, 1.2345678901234567e0_dp)\n      ! again, note output components are just real\n      print *, 'NO, Z8=',z8,real(z8),aimag(z8)\n      !\n      ! YES\n      !\n      ! kind= makes it work\n      z8 = cmplx(1.2345678901234567d0, 1.2345678901234567d0,kind=dp)\n      print *, 'YES, Z8=',z8,real(z8),aimag(z8)\n```\nA more recent alternative to using **cmplx** is \"F2018 component\nsyntax\" where real and imaginary parts of a complex entity can be\naccessed independently:\n\n```fortran\nvalue%RE     ! %RE specifies the real part\nor\nvalue%IM     ! %IM specifies the imaginary part\n\n```\nWhere the designator value is of course of complex type.\n\nThe type of a complex-part-designator is _real_, and its kind and shape\nare those of the designator. That is, you retain the precision of the\ncomplex value by default, unlike with **cmplx**.\n\nThe following are examples of complex part designators:\n\n```fortran\n       impedance%re           !-- Same value as real(impedance)\n       fft%im                 !-- Same value as AIMAG(fft)\n       x%im = 0.0             !-- Sets the imaginary part of x to zero\n       x(1:2)%re=[10,20]      !-- even if x is an array\n```\n\n#### NOTE for I/O\n  Note that if format statements are specified a complex value is\n  treated as two real values.\n\n  For list-directed I/O (ie. using an asterisk for a format) and NAMELIST\n  output the values are expected to be delimited by \"(\" and \")\" and of\n  the form \"(real_part,imaginary_part)\". For NAMELIST input parenthesized\n  values or lists of multiple _real_ values are acceptable.\n\n### **Options**\n\n- **x**\n  : The value assigned to the _real_ component of the result when **x** is\n  not complex.\n\n  If **x** is complex, the result is the same as if the real part of the\n  input was passed as **x** and the imaginary part as **y**.\n```fortran\n     result = CMPLX (REAL (X), AIMAG (X), KIND).\n```\n   That is, a complex **x** value is copied to the result value with a\n   possible change of kind.\n\n- **y**\n  : **y** is only allowed if **x** is not _complex_. Its value\n  is assigned to the imaginary component of the result and defaults\n  to a value of zero if absent.\n\n- **kind**\n  : An _integer_ initialization expression indicating the kind\n  parameter of the result.\n\n### **Result**\n\nThe return value is of _complex_ type, with magnitudes determined by the\nvalues **x** and **y**.\n\nThe common case when **x** is not complex is that the real\ncomponent of the result is assigned the value of **x** and the imaginary\npart is zero or the value of **y** if **y** is present.\n\nWhen **x** is complex **y** is not allowed and the result is the same\nvalue as **x** with a possible change of kind. That is, the real part\nis **real(x, kind)** and the imaginary part is **real(y, kind)**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_aimag\nimplicit none\ninteger,parameter :: dp=kind(0.0d0)\nreal(kind=dp)     :: precise\ncomplex(kind=dp)  :: z8\ncomplex           :: z4, zthree(3)\n   precise=1.2345678901234567d0\n\n  ! basic\n   z4 = cmplx(-3)\n   print *, 'Z4=',z4\n   z4 = cmplx(1.23456789, 1.23456789)\n   print *, 'Z4=',z4\n   ! with a format treat a complex as two real values\n   print '(1x,g0,1x,g0,1x,g0)','Z4=',z4\n\n  ! working with higher precision values\n   ! using kind=dp makes it keep DOUBLEPRECISION precision\n   ! otherwise the result would be of default kind\n   z8 = cmplx(precise, -precise )\n   print *, 'lost precision Z8=',z8\n   z8 = cmplx(precise, -precise ,kind=dp)\n   print *, 'kept precision Z8=',z8\n\n  ! assignment of constant values does not require cmplx(3)00\n   ! The following is intuitive and works without calling cmplx(3)\n   ! but does not work for variables just constants\n   z8 = (1.1111111111111111d0, 2.2222222222222222d0 )\n   print *, 'Z8 defined with constants=',z8\n\n  ! what happens when you assign a complex to a real?\n   precise=z8\n   print *, 'LHS=',precise,'RHS=',z8\n\n  ! elemental\n   zthree=cmplx([10,20,30],-1)\n   print *, 'zthree=',zthree\n\n  ! descriptors are an alternative\n   zthree(1:2)%re=[100,200]\n   print *, 'zthree=',zthree\n\nend program demo_aimag\n```\nResults:\n```text\n    Z4= (-3.000000,0.0000000E+00)\n    Z4= (1.234568,1.234568)\n    Z4= 1.234568 1.234568\n    lost precision Z8= (1.23456788063049,-1.23456788063049)\n    kept precision Z8= (1.23456789012346,-1.23456789012346)\n    Z8 defined with constants= (1.11111111111111,2.22222222222222)\n    LHS=   1.11111111111111      RHS= (1.11111111111111,2.22222222222222)\n    zthree= (10.00000,-1.000000) (20.00000,-1.000000) (30.00000,-1.000000)\n    zthree= (100.0000,-1.000000) (200.0000,-1.000000) (30.00000,-1.000000)\n```\n### **Standard**\n\nFORTRAN 77, KIND added in Fortran 90.\n\n### **See Also**\n\n- [**aimag**(3)](#aimag) - Imaginary part of complex number\n- [**conjg**(3)](#conjg) - Complex conjugate function\n- [**real**(3)](#real) - Convert to real type\n\nFortran has strong support for _complex_ values, including many intrinsics\nthat take or produce _complex_ values in addition to algebraic and\nlogical expressions:\n\n[**abs**(3)](#abs),\n[**acosh**(3)](#acosh),\n[**acos**(3)](#acos),\n[**asinh**(3)](#asinh),\n[**asin**(3)](#asin),\n[**atan2**(3)](#atan2),\n[**atanh**(3)](#atanh),\n[**atan**(3)](#atan),\n[**cosh**(3)](#cosh),\n[**cos**(3)](#cos),\n[**co_sum**(3)](#co_sum),\n[**dble**(3)](#dble),\n[**dot_product**(3)](#dot_product),\n[**exp**(3)](#exp),\n[**int**(3)](#int),\n[**is_contiguous**(3)](#is_contiguous),\n[**kind**(3)](#kind),\n[**log**(3)](#log),\n[**matmul**(3)](#matmul),\n[**precision**(3)](#precision),\n[**product**(3)](#product),\n[**range**(3)](#range),\n[**rank**(3)](#rank),\n[**sinh**(3)](#sinh),\n[**sin**(3)](#sin),\n[**sqrt**(3)](#sqrt),\n[**storage_size**(3)](#storage_size),\n[**sum**(3)](#sum),\n[**tanh**(3)](#tanh),\n[**tan**(3)](#tan),\n[**unpack**(3)](#unpack),\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "COMMAND_ARGUMENT_COUNT": "## command_argument_count\n\n### **Name**\n\n**command_argument_count** - \\[SYSTEM:COMMAND LINE\\] Get number of command line arguments\n\n### **Synopsis**\n```fortran\n    result = command_argument_count()\n```\n```fortran\n     integer function command_argument_count()\n```\n### **Characteristics**\n\n - the result is of default integer scalar.\n\n### **Description**\n\n**command_argument_count** returns the number of arguments passed\non the command line when the containing program was invoked.\n\n### **Options**\n\nNone\n\n### **Result**\n\n  : The return value is of type default _integer_. It is the number of\n  arguments passed on the command line when the program was invoked.\n\n  If there are no command arguments available or if the processor does\n  not support command arguments, then the result has the value zero.\n\n  If the processor has a concept of a command name, the command name\n  does not count as one of the command arguments.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_command_argument_count\nimplicit none\ninteger :: count\n   count = command_argument_count()\n   print *, count\nend program demo_command_argument_count\n```\nSample output:\n\n```bash\n   # the command verb does not count\n   ./test_command_argument_count\n       0\n   # quoted strings may count as one argument\n   ./test_command_argument_count count arguments\n       2\n   ./test_command_argument_count 'count arguments'\n       1\n```\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**get_command**(3)](#get_command),\n[**get_command_argument**(3)](#get_command_argument)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "COMPILER_OPTIONS": "## compiler_options\n\n### **Name**\n\n**compiler_options** - \\[COMPILER:INQUIRY\\] Options passed to the compiler\n\n### **Synopsis**\n```fortran\n    result = compiler_options()\n```\n```fortran\n     character(len=:) function compiler_options()\n```\n### **Characteristics**\n\n - the return value is a default-kind _character_ variable with\n   system-dependent length.\n\n### **Description**\n\n  **compiler_options** returns a string with the options used for\n  compiling.\n\n### **Options**\n\n  None.\n\n### **Result**\n\n  The result contains the compiler flags used to compile the file\n  containing the **compiler_options** call.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_compiler_version\nuse, intrinsic :: iso_fortran_env, only : compiler_version\nuse, intrinsic :: iso_fortran_env, only : compiler_options\nimplicit none\n   print '(4a)', &\n      'This file was compiled by ', &\n      compiler_version(),           &\n      ' using the options ',        &\n      compiler_options()\nend program demo_compiler_version\n```\nResults:\n```text\nThis file was compiled by GCC version 10.3.0 using\nthe options -I build/gfortran_2A42023B310FA28D\n-mtune=generic -march=x86-64 -auxbase-strip\nbuild/gfortran_2A42023B310FA28D/compiler_options/app_main.f90.o\n-g -Wall -Wextra -Wimplicit-interface -fPIC -fmax-errors=1\n-fcheck=bounds -fcheck=array-temps -fbacktrace\n-fcoarray=single -J build/gfortran_2A42023B310FA28D\n-fpre-include=/usr/include/finclude/math-vector-fortran.h\n\nThis file was compiled by nvfortran 21.5-0 LLVM\nusing the options app/main.f90 -c -Minform=inform\n-Mbackslash -Mbounds -Mchkptr -Mchkstk -traceback -module\nbuild/nvfortran_78229DCE997517A4 -Ibuild/nvfortran_78229DCE997517A4 -o\nbuild/nvfortran_78229DCE997517A4/compiler_options/app_main.f90.o\n\nThis file was compiled by Intel(R) Fortran Intel(R) 64 Compiler Classic\nfor applications running on Intel(R) 64, Version 2021.3.0 Build\n20210609_000000 using the options -Ibuild/ifort_5C58216731706F11\n-c -warn all -check all -error-limit 1 -O0 -g -assume\nbyterecl -traceback -module build/ifort_5C58216731706F11 -o\nbuild/ifort_5C58216731706F11/compiler_options/app_main.f90.o\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**compiler_version**(3)](#compiler_version),\n**iso_fortran_env**(7)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "COMPILER_VERSION": "## compiler_version\n\n### **Name**\n\n**compiler_version** - \\[COMPILER:INQUIRY\\] Compiler version string\n\n### **Synopsis**\n```fortran\n    result = compiler_version()\n```\n```fortran\n     character(len=:) function compiler_version()\n```\n### **Characteristics**\n\n- The return value is a default-kind scalar _character_  with\n  system-dependent length.\n\n### **Description**\n\n  **compiler_version** returns a string containing the name and\n  version of the compiler.\n\n### **Options**\n\n  None.\n\n### **Result**\n\n  The return value contains the name of the compiler and its version\n  number used to compile the file containing the **compiler_version**\n  call.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_compiler_version\nuse, intrinsic :: iso_fortran_env, only : compiler_version\nimplicit none\n   print '(2a)', &\n      'This file was compiled by ', &\n      compiler_version()\nend program demo_compiler_version\n```\nResults:\n```text\nThis file was compiled by GCC version 10.3.0\n\nThis file was compiled by Intel(R) Fortran Intel(R) 64 Compiler\nClassic for applications running on Intel(R) 64, Version 2021.3.0 Build\n20210609_000000\n\nThis file was compiled by nvfortran 21.5-0 LLVM\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**compiler_options**(3)](#compiler_options),\n**iso_fortran_env**(7)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "CONJG": "## conjg\n\n### **Name**\n\n**conjg** - \\[NUMERIC\\] Complex conjugate of a complex value\n\n### **Synopsis**\n```fortran\n    result = conjg(z)\n```\n```fortran\n     elemental complex(kind=KIND) function conjg(z)\n\n      complex(kind=**),intent(in) :: z\n```\n### **Characteristics**\n\n- **z** is a _complex_ value of any valid kind.\n- The returned value has the same _complex_ type as the input.\n\n### **Description**\n\n**conjg** returns the complex conjugate of the _complex_ value **z**.\n\nThat is, If **z** is the _complex_ value **(x, y)** then the result is\n**(x, -y)**.\n\nIn mathematics, the complex conjugate of a complex number is a value\nwhose real and imaginary part are equal parts are equal in magnitude to\neach other but the **y** value has opposite sign.\n\nFor matrices of complex numbers, **conjg(array)** represents the\nelement-by-element conjugation of **array**; not the conjugate transpose\nof the **array** .\n\n### **Options**\n\n- **z**\n  : The value to create the conjugate of.\n\n### **Result**\n\nReturns a value equal to the input value except the sign of\nthe imaginary component is the opposite of the input value.\n\nThat is, if **z** has the value **(x,y)**, the result has the value\n**(x, -y)**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_conjg\nuse, intrinsic :: iso_fortran_env, only : real_kinds, &\n& real32, real64, real128\nimplicit none\ncomplex :: z = (2.0, 3.0)\ncomplex(kind=real64) :: dz = (   &\n   &  1.2345678901234567_real64, -1.2345678901234567_real64)\ncomplex :: arr(3,3)\ninteger :: i\n   ! basics\n    ! notice the sine of the imaginary component changes\n    print *, z, conjg(z)\n\n    ! any complex kind is supported. z is of default kind but\n    ! dz is kind=real64.\n    print *, dz\n    dz = conjg(dz)\n    print *, dz\n    print *\n\n    ! the function is elemental so it can take arrays\n    arr(1,:)=[(-1.0, 2.0),( 3.0, 4.0),( 5.0,-6.0)]\n    arr(2,:)=[( 7.0,-8.0),( 8.0, 9.0),( 9.0, 9.0)]\n    arr(3,:)=[( 1.0, 9.0),( 2.0, 0.0),(-3.0,-7.0)]\n\n    write(*,*)'original'\n    write(*,'(3(\"(\",g8.2,\",\",g8.2,\")\",1x))')(arr(i,:),i=1,3)\n    arr = conjg(arr)\n    write(*,*)'conjugate'\n    write(*,'(3(\"(\",g8.2,\",\",g8.2,\")\",1x))')(arr(i,:),i=1,3)\n\nend program demo_conjg\n```\nResults:\n```fortran\n >  (2.000000,3.000000) (2.000000,-3.000000)\n >\n >  (1.23456789012346,-1.23456789012346)\n >  (1.23456789012346,1.23456789012346)\n >\n >  original\n > (-1.0    , 2.0    ) ( 3.0    , 4.0    ) ( 5.0    ,-6.0    )\n > ( 7.0    ,-8.0    ) ( 8.0    , 9.0    ) ( 9.0    , 9.0    )\n > ( 1.0    , 9.0    ) ( 2.0    , 0.0    ) (-3.0    ,-7.0    )\n >\n >  conjugate\n > (-1.0    ,-2.0    ) ( 3.0    ,-4.0    ) ( 5.0    , 6.0    )\n > ( 7.0    , 8.0    ) ( 8.0    ,-9.0    ) ( 9.0    ,-9.0    )\n > ( 1.0    ,-9.0    ) ( 2.0    , 0.0    ) (-3.0    , 7.0    )\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n- [**aimag**(3)](#aimag) - Imaginary part of complex number\n- [**cmplx**(3)](#cmplx) - Complex conversion function\n- [**real**(3)](#real) - Convert to real type\n\nFortran has strong support for _complex_ values, including many intrinsics\nthat take or produce _complex_ values in addition to algebraic and\nlogical expressions:\n\n[**abs**(3)](#abs),\n[**acosh**(3)](#acosh),\n[**acos**(3)](#acos),\n[**asinh**(3)](#asinh),\n[**asin**(3)](#asin),\n[**atan2**(3)](#atan2),\n[**atanh**(3)](#atanh),\n[**atan**(3)](#atan),\n[**cosh**(3)](#cosh),\n[**cos**(3)](#cos),\n[**co_sum**(3)](#co_sum),\n[**dble**(3)](#dble),\n[**dot_product**(3)](#dot_product),\n[**exp**(3)](#exp),\n[**int**(3)](#int),\n[**is_contiguous**(3)](#is_contiguous),\n[**kind**(3)](#kind),\n[**log**(3)](#log),\n[**matmul**(3)](#matmul),\n[**precision**(3)](#precision),\n[**product**(3)](#product),\n[**range**(3)](#range),\n[**rank**(3)](#rank),\n[**sinh**(3)](#sinh),\n[**sin**(3)](#sin),\n[**sqrt**(3)](#sqrt),\n[**storage_size**(3)](#storage_size),\n[**sum**(3)](#sum),\n[**tanh**(3)](#tanh),\n[**tan**(3)](#tan),\n[**unpack**(3)](#unpack),\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "COS": "## cos\n\n### **Name**\n\n**cos** - \\[MATHEMATICS:TRIGONOMETRIC\\] Cosine function\n\n### **Synopsis**\n```fortran\n    result = cos(x)\n```\n```fortran\n     elemental TYPE(kind=KIND) function cos(x)\n\n      TYPE(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **x** is of type _real_ or _complex_ of any valid kind.\n - **KIND** may be any kind supported by the associated type of **x**.\n - The returned value will be of the same type and kind as the argument\n   **x**.\n\n### **Description**\n\n  **cos** computes the cosine of an angle **x** given the size of\n  the angle in radians.\n\n  The cosine of a _real_ value is the ratio of the adjacent side to the\n  hypotenuse of a right-angled triangle.\n\n### **Options**\n\n- **x**\n  : The angle in radians to compute the cosine of.\n\n### **Result**\n\n  The return value is the tangent of **x**.\n\n  If **x** is of the type _real_, the return value is in radians and lies in\n  the range **-1 \\<= cos(x) \\<= 1** .\n\n  If **x** is of type complex, its real part is regarded as a value in\n  radians, often called the phase.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_cos\nimplicit none\ncharacter(len=*),parameter :: g2='(a,t20,g0)'\ndoubleprecision,parameter :: PI=atan(1.0d0)*4.0d0\n   write(*,g2)'COS(0.0)=',cos(0.0)\n   write(*,g2)'COS(PI)=',cos(PI)\n   write(*,g2)'COS(PI/2.0d0)=',cos(PI/2.0d0),'EPSILON=',epsilon(PI)\n   write(*,g2)'COS(2*PI)=',cos(2*PI)\n   write(*,g2)'COS(-2*PI)=',cos(-2*PI)\n   write(*,g2)'COS(-2000*PI)=',cos(-2000*PI)\n   write(*,g2)'COS(3000*PI)=',cos(3000*PI)\nend program demo_cos\n```\nResults:\n```text\n > COS(0.0)=          1.000000\n > COS(PI)=           -1.000000000000000\n > COS(PI/2.0d0)=     .6123233995736766E-16\n > EPSILON=           .2220446049250313E-15\n > COS(2*PI)=         1.000000000000000\n > COS(-2*PI)=        1.000000000000000\n > COS(-2000*PI)=     1.000000000000000\n > COS(3000*PI)=      1.000000000000000\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n[**acos**(3)](#acos),\n[**sin**(3)](#sin),\n[**tan**(3)](#tan)\n\n### **Resources**\n\n- [Wikipedia:sine and cosine](https://en.wikipedia.org/wiki/Sine_and_cosine)\n\n _fortran-lang intrinsic descriptions_\n",
  "COSH": "## cosh\n\n### **Name**\n\n**cosh** - \\[MATHEMATICS:TRIGONOMETRIC\\] Hyperbolic cosine function\n\n### **Synopsis**\n```fortran\n    result = cosh(x)\n```\n```fortran\n     elemental TYPE(kind=KIND) function cosh(x)\n\n      TYPE(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **TYPE** may be _real_ or _complex_ of any kind.\n - The returned value will be of the same type and kind as the argument.\n\n### **Description**\n\n**cosh** computes the hyperbolic cosine of **x**.\n\nIf **x** is of type complex its imaginary part is regarded as a value\nin radians.\n\n### **Options**\n\n- **x**\n  : the value to compute the hyperbolic cosine of\n\n### **Result**\n\n  If **x** is _complex_, the imaginary part of the result is in radians.\n\n  If **x** is _real_, the return value has a lower bound of one,\n  **cosh(x) \\>= 1**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_cosh\nuse, intrinsic :: iso_fortran_env, only : &\n & real_kinds, real32, real64, real128\nimplicit none\nreal(kind=real64) :: x = 1.0_real64\n    write(*,*)'X=',x,'COSH(X=)',cosh(x)\nend program demo_cosh\n```\nResults:\n```text\n >  X=   1.00000000000000      COSH(X=)   1.54308063481524\n```\n### **Standard**\n\nFORTRAN 77 , for a complex argument - Fortran 2008\n\n### **See Also**\n\nInverse function: [**acosh**(3)](#acosh)\n\n### **Resources**\n\n- [Wikipedia:hyperbolic functions](https://en.wikipedia.org/wiki/Hyperbolic_functions)\n\n _fortran-lang intrinsic descriptions_\n",
  "COUNT": "## count\n\n### **Name**\n\n**count** - \\[ARRAY:REDUCTION\\] Count true values in an array\n\n### **Synopsis**\n```fortran\n    result = count(mask [,dim] [,kind] )\n```\n```fortran\n     integer(kind=KIND) function count(mask, dim, KIND )\n\n      logical(kind=**),intent(in) :: mask(..)\n      integer(kind=**),intent(in),optional :: dim\n      integer(kind=**),intent(in),optional :: KIND\n```\n### **Characteristics**\n\n  - a kind designated as ** may be any supported kind for the type\n  - **mask** is a _logical_ array of any shape and kind.\n  - If **dim** is present, the result is an array with the specified rank\n    removed.\n  - **KIND** is a scalar integer constant expression valid as an _integer_ kind\n  - The return value is of default _integer_ type unless **kind** is specified\n    to declare the kind of the result.\n\n### **Description**\n\n  **count** counts the number of _.true._ elements in a logical\n  **mask**, or, if the **dim** argument is supplied, counts the number\n  of elements along each row of the array in the **dim** direction. If\n  the array has zero size or all of the elements of **mask** are false,\n  then the result is **0**.\n\n### **Options**\n\n- **mask**\n  : an array to count the number of _.true._ values in\n\n- **dim**\n  : specifies to remove this dimension from the result and produce an\n    array of counts of _.true._ values along the removed dimension.\n    If not present, the result is a scalar count of the true elements in **mask**\n    the value must be in the range 1 <= dim <= n, where n is the\n    rank(number of dimensions) of **mask**.\n\n    The corresponding actual argument shall not be an optional dummy\n    argument, a disassociated pointer, or an unallocated allocatable.\n\n- **kind**\n  : An _integer_ initialization expression indicating the kind\n  parameter of the result.\n\n### **Result**\n\n  The return value is the number of _.true_. values in **mask** if **dim**\n  is not present.\n\n  If **dim** is present, the result is an array with a rank one less\n  than the rank of the input array **mask**, and a size corresponding\n  to the shape of **array** with the **dim** dimension removed, with the\n  remaining elements containing the number of _.true._ elements along the\n  removed dimension.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_count\nimplicit none\ncharacter(len=*),parameter :: ints='(*(i2,1x))'\n! two arrays and a mask all with the same shape\ninteger, dimension(2,3) :: a, b\nlogical, dimension(2,3) :: mymask\ninteger :: i\ninteger :: c(2,3,4)\n\nprint *,'the numeric arrays we will compare'\na = reshape( [ 1, 2, 3, 4, 5, 6 ], [ 2, 3 ])\nb = reshape( [ 0, 7, 3, 4, 5, 8 ], [ 2, 3 ])\nc = reshape( [( i,i=1,24)], [ 2, 3 ,4])\nprint '(3i3)', a(1,:)\nprint '(3i3)', a(2,:)\nprint *\nprint '(3i3)', b(1,:)\nprint '(3i3)', b(2,:)\n!\n! basic calls\nprint *, 'count a few basic things creating a mask from an expression'\nprint *, 'count a>b',count(a>b)\nprint *, 'count b<a',count(a<b)\nprint *, 'count b==a',count(a==b)\nprint *, 'check sum = ',count(a>b) + &\n                      & count(a<b) + &\n                      & count(a==b).eq.size(a)\n!\n! The common usage is just getting a count, but if you want\n! to specify the DIM argument and get back reduced arrays\n! of counts this is easier to visualize if we look at a mask.\nprint *, 'make a mask identifying unequal elements ...'\nmymask = a.ne.b\nprint *, 'the mask generated from a.ne.b'\nprint '(3l3)', mymask(1,:)\nprint '(3l3)', mymask(2,:)\n!\nprint *,'count total and along rows and columns ...'\n!\nprint '(a)', 'number of elements not equal'\nprint '(a)', '(ie. total true elements in the mask)'\nprint '(3i3)', count(mymask)\n!\nprint '(a)', 'count of elements not equal in each column'\nprint '(a)', '(ie. total true elements in each column)'\nprint '(3i3)', count(mymask, dim=1)\n!\nprint '(a)', 'count of elements not equal in each row'\nprint '(a)', '(ie. total true elements in each row)'\nprint '(3i3)', count(mymask, dim=2)\n!\n! working with rank=3 ...\nprint *, 'lets try this with c(2,3,4)'\nprint *,'  taking the result of the modulo   '\nprint *,'   z=1      z=2      z=3      z=4   '\nprint *,'  1 3 0 || 2 4 1 || 3 0 2 || 4 1 3 |'\nprint *,'  2 4 1 || 3 0 2 || 4 1 3 || 0 2 4 |'\nprint *,'                                    '\nprint *,'  would result in the mask ..       '\nprint *,'  F F T || F F F || F T F || F F F |'\nprint *,'  F F F || F T F || F F F || T F F |'\nprint *,'                                    '\nprint *,' the total number of .true.values is'\nprint ints, count(modulo(c,5).eq.0)\ncall printi('counting up along a row and removing rows',&\ncount(modulo(c,5).eq.0,dim=1))\ncall printi('counting up along a column and removing columns',&\ncount(modulo(c,5).eq.0,dim=2))\ncall printi('counting up along a depth and removing depths',&\ncount(modulo(c,5).eq.0,dim=3))\n!\ncontains\n!\n! CONVENIENCE ROUTINE FOR PRINTING SMALL INTEGER MATRICES\nsubroutine printi(title,arr)\nimplicit none\n!\n!@(#) print small 2d integer arrays in row-column format\n!\ncharacter(len=*),parameter :: all='(*(g0,1x))' ! a handy format\ncharacter(len=*),intent(in)  :: title\ninteger,intent(in)           :: arr(:,:)\ninteger                      :: i\ncharacter(len=:),allocatable :: biggest\n   !\n   print all\n   print all, trim(title),':(',shape(arr),')'  ! print title\n   biggest='           '  ! make buffer to write integer into\n   ! find how many characters to use for integers\n   write(biggest,'(i0)')ceiling(log10(max(1.0,real(maxval(abs(arr))))))+2\n   ! use this format to write a row\n   biggest='(\" > [\",*(i'//trim(biggest)//':,\",\"))'\n   ! print one row of array at a time\n   do i=1,size(arr,dim=1)\n      write(*,fmt=biggest,advance='no')arr(i,:)\n      write(*,'(\" ]\")')\n   enddo\n   !\nend subroutine printi\nend program demo_count\n```\nResults:\n```text\n >   the numeric arrays we will compare\n >    1  3  5\n >    2  4  6\n >\n >    0  3  5\n >    7  4  8\n >   count a few basic things creating a mask from an expression\n >   count a>b           1\n >   count b<a           2\n >   count b==a           3\n >   check sum =  T\n >   make a mask identifying unequal elements ...\n >   the mask generated from a.ne.b\n >    T  F  F\n >    T  F  T\n >   count total and along rows and columns ...\n >  number of elements not equal\n >  (ie. total true elements in the mask)\n >    3\n >  count of elements not equal in each column\n >  (ie. total true elements in each column)\n >    2  0  1\n >  count of elements not equal in each row\n >  (ie. total true elements in each row)\n >    1  2\n >   lets try this with c(2,3,4)\n >     taking the result of the modulo\n >      z=1      z=2      z=3      z=4\n >     1 3 0 || 2 4 1 || 3 0 2 || 4 1 3 |\n >     2 4 1 || 3 0 2 || 4 1 3 || 0 2 4 |\n >\n >     would result in the mask ..\n >     F F T || F F F || F T F || F F F |\n >     F F F || F T F || F F F || T F F |\n >\n >    the total number of .true.values is\n >   4\n >\n >  counting up along a row and removing rows :( 3 4 )\n >   > [ 0, 0, 0, 1 ]\n >   > [ 0, 1, 1, 0 ]\n >   > [ 1, 0, 0, 0 ]\n >\n >  counting up along a column and removing columns :( 2 4 )\n >   > [ 1, 0, 1, 0 ]\n >   > [ 0, 1, 0, 1 ]\n >\n >  counting up along a depth and removing depths :( 2 3 )\n >   > [ 0, 1, 1 ]\n >   > [ 1, 1, 0 ]\n```\n### **Standard**\n\nFortran 95 , with KIND argument - Fortran 2003\n\n### **See Also**\n\n[**any**(3)](#any),\n[**all**(3)](#all),\n[**sum**(3)](#sum),\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "CO_BROADCAST": "## co_broadcast\n\n### **Name**\n\n**co_broadcast** - \\[COLLECTIVE\\] Copy a value to all images the current set of images\n\n### **Synopsis**\n```fortran\n    call co_broadcast(a, source_image [,stat] [,errmsg] )\n```\n```fortran\n```\n### **Characteristics**\n\n### **Description**\n\n**co_broadcast** copies the value of argument **a** on the image with image\nindex source_image to all images in the current team. **a** becomes defined\nas if by intrinsic assignment. If the execution was successful and **stat**\nis present, it is assigned the value zero. If the execution failed, **stat**\ngets assigned a nonzero value and, if present, **errmsg** gets assigned a\nvalue describing the occurred error.\n\n### **Options**\n\n- **a**\n  : **intent(inout)** argument; shall have the same dynamic type and\n  type parameters on all images of the current team. If it is an\n  array, it shall have the same shape on all images.\n\n- **source_image**\n  : a scalar integer expression. It shall have the same the same value\n  on all images and refer to an image of the current team.\n\n- **stat**\n  : (optional) a scalar integer variable\n\n- **errmsg**\n  : (optional) a scalar character variable\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_co_broadcast\nimplicit none\ninteger :: val(3)\n   if (this_image() == 1) then\n      val = [1, 5, 3]\n   endif\n   call co_broadcast (val, source_image=1)\n   print *, this_image(), \":\", val\nend program demo_co_broadcast\n```\n### **Standard**\n\nFortran xx\n\n### **See Also**\n\n[**co_max**(3)](#co_max),\n[**co_min**(3)](#co_min),\n[**co_sum**(3)](#co_sum),\n[**co_reduce**(3)](#co_reduce)\n\n _fortran-lang intrinsic descriptions_\n",
  "CO_MAX": "## co_max\n\n### **Name**\n\n**co_max** - \\[COLLECTIVE\\] Maximal value on the current set of images\n\n### **Synopsis**\n```fortran\n     call co_max(a, result_image [,stat] [,errmsg] )\n```\n```fortran\n```\n### **Characteristics**\n\n### **Description**\n\n**co_max** determines element-wise the maximal value of **a** on all\nimages of the current team. If result_image is present, the maximum values\nare returned in **a** on the specified image only and the value of **a**\non the other images become undefined. If result_image is not present,\nthe value is returned on all images. If the execution was successful\nand **stat** is present, it is assigned the value zero. If the execution\nfailed, **stat** gets assigned a nonzero value and, if present, **errmsg**\ngets assigned a value describing the occurred error.\n\n### **Options**\n\n- **a**\n  : shall be an integer, real or character variable, which has the same\n  type and type parameters on all images of the team.\n\n- **result_image**\n  : (optional) a scalar integer expression; if present, it shall have\n  the same the same value on all images and refer to an image of the\n  current team.\n\n- **stat**\n  : (optional) a scalar integer variable\n\n- **errmsg**\n  : (optional) a scalar character variable\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_co_max\nimplicit none\ninteger :: val\n   val = this_image()\n   call co_max(val, result_image=1)\n   if (this_image() == 1) then\n     write(*,*) \"Maximal value\", val  ! prints num_images()\n   endif\nend program demo_co_max\n```\n\nResults:\n\n```text\n    Maximal value           2\n```\n\n### **Standard**\n\nTS 18508\n\n### **See Also**\n\n[**co_min**(3)](#co_min),\n[**co_sum**(3)](#co_sum),\n[**co_reduce**(3)](#co_reduce),\n[**co_broadcast**(3)](#co_broadcast)\n\n _fortran-lang intrinsic descriptions_\n",
  "CO_MIN": "## co_min\n\n### **Name**\n\n**co_min** - \\[COLLECTIVE\\] Minimal value on the current set of images\n\n### **Synopsis**\n```fortran\n     call co_min(a, result_image [,stat] [,errmsg] )\n```\n```fortran\n```\n### **Characteristics**\n\n### **Description**\n\n**co_min** determines element-wise the minimal value of **a** on all\nimages of the current team. If result_image is present, the minimal values\nare returned in **a** on the specified image only and the value of **a**\non the other images become undefined. If result_image is not present,\nthe value is returned on all images. If the execution was successful\nand **stat** is present, it is assigned the value zero. If the execution\nfailed, **stat** gets assigned a nonzero value and, if present, **errmsg**\ngets assigned a value describing the occurred error.\n\n### **Options**\n\n- **a**\n  : shall be an integer, real or character variable, which has the same\n  type and type parameters on all images of the team.\n\n- **result_image**\n  : (optional) a scalar integer expression; if present, it shall have\n  the same the same value on all images and refer to an image of the\n  current team.\n\n- **stat**\n  : (optional) a scalar integer variable\n\n- **errmsg**\n  : (optional) a scalar character variable\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_co_min\nimplicit none\ninteger :: val\n   val = this_image()\n   call co_min(val, result_image=1)\n   if (this_image() == 1) then\n     write(*,*) \"Minimal value\", val  ! prints 1\n   endif\nend program demo_co_min\n```\n\n### **Standard**\n\nTS 18508\n\n### **See Also**\n\n[**co_max**(3)](#co_max),\n[**co_sum**(3)](#co_sum),\n[**co_reduce**(3)](#co_reduce),\n[**co_broadcast**(3)](#co_broadcast)\n\n _fortran-lang intrinsic descriptions_\n",
  "CO_REDUCE": "## co_reduce\n\n### **Name**\n\n**co_reduce** - \\[COLLECTIVE\\] Reduction of values on the current set of images\n\n### **Synopsis**\n```fortran\n    call co_reduce(a, operation, result_image [,stat] [,errmsg] )\n```\n```fortran\n```\n### **Characteristics**\n\n### **Description**\n\n**co_reduce** determines element-wise the reduction of the value of **a** on\nall images of the current team. The pure function passed as **operation** is\nused to pairwise reduce the values of **a** by passing either the value of **a**\nof different images or the result values of such a reduction as\nargument. If **a** is an array, the reduction is done element wise. If\nresult_image is present, the result values are returned in **a** on the\nspecified image only and the value of **a** on the other images become\nundefined. If result_image is not present, the value is returned on all\nimages. If the execution was successful and **stat** is present, it is\nassigned the value zero. If the execution failed, **stat** gets assigned a\nnonzero value and, if present, **errmsg** gets assigned a value describing\nthe occurred error.\n\n### **Options**\n\n- **a**\n  : is an **intent(inout)** argument and shall be nonpolymorphic. If it\n  is allocatable, it shall be allocated; if it is a pointer, it shall\n  be associated. **a** shall have the same type and type parameters on all\n  images of the team; if it is an array, it shall have the same shape\n  on all images.\n\n- **operation**\n  : pure function with two scalar nonallocatable arguments, which shall\n  be nonpolymorphic and have the same type and type parameters as **a**.\n  The function shall return a nonallocatable scalar of the same type\n  and type parameters as **a**. The function shall be the same on all\n  images and with regards to the arguments mathematically commutative\n  and associative. Note that OPERATION may not be an elemental unless\n  it is an intrinsic function.\n\n- **result_image**\n\n  : (optional) a scalar integer expression; if present, it shall\n  have the same the same value on all images and refer to an image\n  of the current team.\n\n- **stat**\n  : (optional) a scalar integer variable\n\n- **errmsg**\n  : (optional) a scalar character variable\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_co_reduce\nimplicit none\ninteger :: val\n\n   val = this_image()\n   call co_reduce(val, myprod, 1)\n   if (this_image() == 1) then\n      write(*,*) \"Product value\", val  ! prints num_images() factorial\n   endif\n\ncontains\n\npure function myprod(a, b)\n   integer, value :: a, b\n   integer :: myprod\n   myprod = a * b\nend function myprod\n\nend program demo_co_reduce\n```\n\n### **Note**\n\nWhile the rules permit in principle an intrinsic function, none of the\nintrinsics in the standard fulfill the criteria of having a specific\nfunction, which takes two arguments of the same type and returning that\ntype as a result.\n\n### **Standard**\n\nTS 18508\n\n### **See Also**\n\n[**co_min**(3)](#co_min),\n[**co_max**(3)](#co_max),\n[**co_sum**(3)](#co_sum),\n[**co_broadcast**(3)](#co_broadcast)\n\n _fortran-lang intrinsic descriptions_\n",
  "CO_SUM": "## co_sum\n\n### **Name**\n\n**co_sum** - \\[COLLECTIVE\\] Sum of values on the current set of images\n\n### **Synopsis**\n```fortran\n    call co_sum(a, result_image [,stat] [,errmsg] )\n```\n```fortran\n```\n### **Characteristics**\n\n### **Description**\n\n**co_sum** sums up the values of each element of **a** on all images\nof the current team.\n\nIf result_image is present, the summed-up values are returned in **a**\non the specified image only and the value of **a** on the other images\nbecome undefined.\n\nIf result_image is not present, the value is returned on all images. If\nthe execution was successful and **stat** is present, it is assigned the\nvalue zero. If the execution failed, **stat** gets assigned a nonzero\nvalue and, if present, **errmsg** gets assigned a value describing the\noccurred error.\n\n### **Options**\n\n- **a**\n  : shall be an integer, real or complex variable, which has the same\n  type and type parameters on all images of the team.\n\n- **result_image**\n  : (optional) a scalar integer expression; if present, it shall have\n  the same the same value on all images and refer to an image of the\n  current team.\n\n- **stat**\n  : (optional) a scalar integer variable\n\n- **errmsg**\n  : (optional) a scalar character variable\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_co_sum\nimplicit none\ninteger :: val\n   val = this_image()\n   call co_sum(val, result_image=1)\n   if (this_image() == 1) then\n      ! prints (n**2 + n)/2, with n = num_images()\n      write(*,*) \"The sum is \", val\n   endif\nend program demo_co_sum\n```\n\nResults:\n\n```text\n    The sum is            1\n```\n\n### **Standard**\n\nTS 18508\n\n### **See Also**\n\n[**co_max**(3)](#co_max),\n[**co_min**(3)](#co_min),\n[**co_reduce**(3)](#co_reduce),\n[**co_broadcast**(3)](#co_broadcast)\n\n _fortran-lang intrinsic descriptions_\n",
  "CPU_TIME": "## cpu_time\n\n### **Name**\n\n**cpu_time** - \\[SYSTEM:TIME\\] Return CPU processor time used in seconds\n\n### **Synopsis**\n```fortran\n     call cpu_time(time)\n```\n```fortran\n      subroutine cpu_time(time)\n\n       real,intent(out) :: time\n```\n### **Characteristics**\n\n - **time** is a _real_ of any kind\n\n### **Description**\n\n  **cpu_time** returns a _real_ value representing the elapsed CPU time\n  in seconds. This is useful for testing segments of code to determine\n  execution time.\n\n  If no time source is available, **time** is set to a negative value.\n\n  The exact definition of time is left imprecise because of the variability\n  in what different processors are able to provide.\n\n  Note that **time** may contain a system dependent, arbitrary offset and may\n  not start with 0.0. For **cpu_time** the absolute value is meaningless.\n  Only differences between subsequent calls, as shown in the example below,\n  should be used.\n\n  PARALLEL PROCESSING\n\n  Whether the value assigned is an approximation to the amount of time used\n  by the invoking image, or the amount of time used by the whole program,\n  is processor dependent.\n\n  A processor for which a single result is inadequate (for example, a\n  parallel processor) might choose to provide an additional version for\n  which **time** is an array.\n\n### **Result**\n\n- **time**\n  : is assigned a processor-dependent approximation to the processor\n    time in seconds. If the processor cannot return a meaningful time,\n    a processor-dependent negative value is returned.\n\n  : The start time is left imprecise because the purpose is to time\n    sections of code, as in the example. This might or might not\n    include system overhead time.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_cpu_time\nuse, intrinsic :: iso_fortran_env, only : real_kinds,real32,real64,real128\nimplicit none\nreal :: start, finish\nreal(kind=real64) :: startd, finishd\n   !\n   call cpu_time(start)\n   call cpu_time(startd)\n   ! put code to time here\n   call cpu_time(finish)\n   call cpu_time(finishd)\n   !\n  ! writes processor time taken by the piece of code.\n\n  ! the accuracy of the clock and whether it includes system time\n  ! as well as user time is processor dependent. Accuracy up to\n  ! milliseconds is common but not guaranteed, and may be much\n  ! higher or lower\n   print '(\"Processor Time = \",f6.3,\" seconds.\")',finish-start\n\n   ! see your specific compiler documentation for how to measure\n   ! parallel jobs and for the precision of the time returned\n   print '(\"Processor Time = \",g0,\" seconds.\")',finish-start\n   print '(\"Processor Time = \",g0,\" seconds.\")',finishd-startd\nend program demo_cpu_time\n```\nResults:\n\n  The precision of the result, some aspects of what is returned,\n  and what if any options there are for parallel applications\n  may very from system to system. See compiler-specific for details.\n```text\n   Processor Time =  0.000 seconds.\n   Processor Time = .4000030E-05 seconds.\n   Processor Time = .2000000000000265E-05 seconds.\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**system_clock**(3)](#system_clock),\n[**date_and_time**(3)](#date_and_time)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "CSHIFT": "## cshift\n\n### **Name**\n\n**cshift** - \\[TRANSFORMATIONAL\\] Circular shift elements of an array\n\n### **Synopsis**\n```fortran\n   result = cshift(array, shift [,dim])\n```\n```fortran\n    type(TYPE(kind=KIND)) function cshift(array, shift, dim )\n\n     type(TYPE(kind=KIND)),intent(in) :: array(..)\n     integer(kind=**),intent(in)  :: shift\n     integer(kind=**),intent(in)  :: dim\n```\n### **Characteristics**\n\n - **array** may be any type and rank\n - **shift** an _integer_ scalar if **array** has rank one.\n   Otherwise, it shall be scalar or of rank n-1 and of shape [d1, d2,\n   ..., dDIM-1, dDIM+1, ..., dn] where [d1, d2, ..., dn] is the shape\n   of **array**.\n - **dim** is an _integer_ scalar with a value in the range 1 <= **dim**\n   <= n, where n is the rank of **array**.\n   If **dim** is absent, it is as if it were present with the value 1.\n - the result will automatically be of the same type, kind and shape as **array**.\n\n NOTE:\n :a kind designated as ** may be any supported kind for the type\n\n### **Description**\n\n  **cshift** performs a circular shift on elements\n  of **array** along the dimension of **dim**. If **dim** is omitted it is\n  taken to be **1**. **dim** is a scalar of type _integer_ in the range of\n  **1 \\<= dim \\<= n**, where \"n\" is the rank of **array**.\n\n  If the rank of\n  **array** is one, then all elements of **array** are shifted by **shift**\n  places. If rank is greater than one, then all complete rank one sections\n  of **array** along the given dimension are shifted. Elements shifted\n  out one end of each rank one section are shifted back in the other end.\n\n### **Options**\n\n- **array**\n  : An array of any type which is to be shifted\n\n- **shift**\n  : the number of positions to circularly shift. A negative value produces\n  a right shift, a positive value produces a left shift.\n\n- **dim**\n  : the dimension along which to shift a multi-rank **array**. Defaults\n  to 1.\n\n### **Result**\n\nReturns an array of same type and rank as the **array** argument.\n\nThe rows of an array of rank two may all be shifted by the same amount\nor by different amounts.\n\n## cshift\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_cshift\nimplicit none\ninteger, dimension(5)   :: i1,i2,i3\ninteger, dimension(3,4) :: a, b\n   !basics\n    i1=[10,20,30,40,50]\n    print *,'start with:'\n    print '(1x,5i3)', i1\n    print *,'shift -2'\n    print '(1x,5i3)', cshift(i1,-2)\n    print *,'shift +2'\n    print '(1x,5i3)', cshift(i1,+2)\n\n    print *,'start with a matrix'\n    a = reshape( [ 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ], [ 3, 4 ])\n    print '(4i3)', a(1,:)\n    print '(4i3)', a(2,:)\n    print '(4i3)', a(3,:)\n    print *,'matrix shifted along rows, each by its own amount [-1,0,1]'\n    b = cshift(a, SHIFT=[1, 0, -1], DIM=2)\n    print *\n    print '(4i3)', b(1,:)\n    print '(4i3)', b(2,:)\n    print '(4i3)', b(3,:)\nend program demo_cshift\n```\nResults:\n```text\n >  start with:\n >   10 20 30 40 50\n >  shift -2\n >   40 50 10 20 30\n >  shift +2\n >   30 40 50 10 20\n >  start with a matrix\n >   1  4  7 10\n >   2  5  8 11\n >   3  6  9 12\n >  matrix shifted along rows, each by its own amount\n >\n >   4  7 10  1\n >   2  5  8 11\n >  12  3  6  9\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n - [**eoshift**(3)](#eoshift)  -  End-off shift elements of an array\n <!--\n - [**cshift**](#cshift)   -  Circular shift elements of an array\n -->\n - [**sum**(3)](#sum)      -  sum the elements of an array\n - [**product**(3)](#product)  -  Product of array elements\n - [**findloc**(3)](#findloc)  -  Location of first element of ARRAY identified by MASK along dimension DIM having a value\n - [**maxloc**(3)](#maxloc)    -  Location of the maximum value within an array\n\n _fortran-lang intrinsic descriptions_\n",
  "C_ASSOCIATED": "## c_associated\n\n### **Name**\n\n**c_associated** - \\[ISO_C_BINDING\\] Status of a C pointer\n\n### **Synopsis**\n```fortran\n    result = c_associated(c_prt_1, [c_ptr_2] )\n```\n```fortran\n     logical function c_associated(c_prt_1, cptr_2)\n\n      TYPE,intent(in) ::c_ptr_1\n      TYPE,intent(in),optional ::c_ptr_2\n```\n### **Characteristics**\n\n- **c_ptr_1** is a scalar of the type c_ptr or c_funptr.\n- **c_ptr_2** is a scalar of the same type as c_ptr_1.\n- The return value is of type _logical_\n\n### **Description**\n\n**c_associated** determines the status of the\nC pointer c_ptr_1 or if c_ptr_1 is associated with the target\nc_ptr_2.\n\n### **Options**\n\n- **c_ptr_1**\n  : C pointer to test for being a C NULL pointer, or to test if\n  pointing to the same association as **c_ptr_2** when present.\n\n- **c_ptr_2**\n  : C pointer to test for shared association with **c_ptr_1**\n\n### **Result**\n\nThe return value is of type _logical_; it is _.false_. if either c_ptr_1\nis a C NULL pointer or if c_ptr1 and c_ptr_2 point to different\naddresses.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_c_associated\n\ncontains\n\nsubroutine association_test(a,b)\nuse iso_c_binding, only: c_associated, c_loc, c_ptr\nimplicit none\nreal, pointer :: a\ntype(c_ptr) :: b\n   if(c_associated(b, c_loc(a))) &\n      stop 'b and a do not point to same target'\nend subroutine association_test\n\nend program demo_c_associated\n```\n\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**c_loc**(3)](#c_loc),\n[**c_funloc**(3)](#c_funloc),\n**iso_c_binding**(3)\n\n _fortran-lang intrinsic descriptions_\n",
  "C_FUNLOC": "## c_funloc\n\n### **Name**\n\n**c_funloc** - \\[ISO_C_BINDING\\] Obtain the C address of a procedure\n\n### **Synopsis**\n```fortran\n    result = c_funloc(x)\n```\n```fortran\n```\n### **Characteristics**\n\n### **Description**\n\n**c_funloc** determines the C address of the argument.\n\n### **Options**\n\n- **x**\n  : Interoperable function or pointer to such function.\n\n### **Result**\n\nThe return value is of type c_funptr and contains the C address of the\nargument.\n\n### **Examples**\n\nSample program:\n\n```fortran\n! program demo_c_funloc and module\nmodule x\nuse iso_c_binding\nimplicit none\ncontains\nsubroutine sub(a) bind(c)\nreal(c_float) :: a\n   a = sqrt(a)+5.0\nend subroutine sub\nend module x\n!\nprogram demo_c_funloc\nuse iso_c_binding\nuse x\nimplicit none\ninterface\n   subroutine my_routine(p) bind(c,name='myC_func')\n     import :: c_funptr\n     type(c_funptr), intent(in) :: p\n   end subroutine\nend interface\n   call my_routine(c_funloc(sub))\n!\nend program demo_c_funloc\n```\n\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**c_associated**(3)](#c_associated),\n[**c_loc**(3)](#c_loc),\n[**c_f_pointer**(3)](#c_f_pointer),\n\n[**c_f_procpointer**(3)](#c_f_procpointer),\n**iso_c_binding**(3)\n\n _fortran-lang intrinsic descriptions_\n",
  "C_F_POINTER": "## c_f_pointer\n\n### **Name**\n\n**c_f_pointer** - \\[ISO_C_BINDING\\] Convert C into Fortran pointer\n\n### **Synopsis**\n```fortran\n    call c_f_pointer(cptr, fptr [,shape] )\n```\n```fortran\n     subroutine c_f_pointer(cptr, fptr ,shape )\n\n      type(c_ptr),intent(in) :: cprt\n      type(TYPE),pointer,intent(out) :: fprt\n      integer,intent(in),optional :: shape(:)\n```\n### **Characteristics**\n\nThe Fortran pointer **fprt** must be interoperable with **cptr**\n\n**shape** is only specified if **fptr** is an array.\n\n### **Description**\n\n**c_f_pointer** assigns the target (the C pointer **cptr**) to the\nFortran pointer **fptr** and specifies its shape if **fptr** points to\nan array.\n\n### **Options**\n\n- **cptr**\n  : scalar of the type c_ptr. It is **intent(in)**.\n\n- **fptr**\n  : pointer interoperable with **cptr**. it is **intent(out)**.\n\n- **shape**\n  : (Optional) Rank-one array of type _integer_ with **intent(in)** .\n  It shall be present if and only if **fptr** is an array. The size\n  must be equal to the rank of **fptr**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_c_f_pointer\nuse iso_c_binding\nimplicit none\ninterface\n   subroutine my_routine(p) bind(c,name='myC_func')\n      import :: c_ptr\n      type(c_ptr), intent(out) :: p\n   end subroutine\nend interface\ntype(c_ptr) :: cptr\nreal,pointer :: a(:)\n   call my_routine(cptr)\n   call c_f_pointer(cptr, a, [12])\nend program demo_c_f_pointer\n```\n\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**c_loc**(3)](#c_loc),\n[**c_f_procpointer**(3)](#c_f_procpointer),\n**iso_c_binding**(3)\n\n _fortran-lang intrinsic descriptions_\n",
  "C_F_PROCPOINTER": "## c_f_procpointer\n\n### **Name**\n\n**c_f_procpointer** - \\[ISO_C_BINDING\\] Convert C into Fortran procedure pointer\n\n### **Synopsis**\n```fortran\n    call c_f_procpointer(cptr, fptr)\n```\n```fortran\n     subroutine c_f_procpointer(cptr, fptr )\n\n      type(c_funptr),intent(in) :: cprt\n      type(TYPE),pointer,intent(out) :: fprt\n```\n### **Characteristics**\n\n### **Description**\n\n**c_f_procpointer** assigns the target of the C function\npointer **cptr** to the Fortran procedure pointer **fptr**.\n\n### **Options**\n\n- **cptr**\n  : scalar of the type c_funptr. It is **intent(in)**.\n\n- **fptr**\n  : procedure pointer interoperable with **cptr**. It is **intent(out)**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_c_f_procpointer\nuse iso_c_binding\nimplicit none\nabstract interface\n   function func(a)\n   import :: c_float\n   real(c_float), intent(in) :: a\n   real(c_float) :: func\n   end function\nend interface\ninterface\n   function getIterFunc() bind(c,name=\"getIterFunc\")\n   import :: c_funptr\n   type(c_funptr) :: getIterFunc\n   end function\nend interface\ntype(c_funptr) :: cfunptr\nprocedure(func), pointer :: myFunc\n   cfunptr = getIterFunc()\n   call c_f_procpointer(cfunptr, myFunc)\nend program demo_c_f_procpointer\n```\n\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**c_loc**(3)](#c_loc),\n[**c_f_pointer**(3)](#c_f_pointer),\n**iso_c_binding**(3)\n\n _fortran-lang intrinsic descriptions_\n",
  "C_LOC": "## c_loc\n\n### **Name**\n\n**c_loc** - \\[ISO_C_BINDING\\] Obtain the C address of an object\n\n### **Synopsis**\n```fortran\n    result = c_loc(x)\n```\n```fortran\n```\n### **Characteristics**\n\n### **Description**\n\n  **c_loc** determines the C address of the argument.\n\n### **Options**\n\n- **x**\n  : Shall have either the _pointer_ or _target_ attribute. It shall not be a\n  coindexed object. It shall either be a variable with interoperable\n  type and kind type parameters, or be a scalar, nonpolymorphic\n  variable with no length type parameters.\n\n### **Result**\n\nThe return value is of type c_ptr and contains the C address of the\nargument.\n\n### **Examples**\n\nSample program:\n\n```fortran\n   subroutine association_test(a,b)\n   use iso_c_binding, only: c_associated, c_loc, c_ptr\n   implicit none\n   real, pointer :: a\n   type(c_ptr) :: b\n     if(c_associated(b, c_loc(a))) &\n        stop 'b and a do not point to same target'\n   end subroutine association_test\n```\n\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**c_associated**(3)](#c_associated),\n[**c_funloc**(3)](#c_funloc),\n[**c_f_pointer**(3)](#c_f_pointer),\n\n[**c_f_procpointer**(3)](#c_f_procpointer),\n**iso_c_binding**(3)\n\n _fortran-lang intrinsic descriptions_\n",
  "C_SIZEOF": "## c_sizeof\n\n### **Name**\n\n**c_sizeof** - \\[ISO_C_BINDING\\] Size in bytes of an expression\n\n### **Synopsis**\n```fortran\n    result = c_sizeof(x)\n```\n```fortran\n```\n### **Characteristics**\n\n### **Description**\n\n**c_sizeof** calculates the number of bytes of storage the\nexpression **x** occupies.\n\n### **Options**\n\n- **x**\n  : The argument shall be an interoperable data entity.\n\n### **Result**\n\nThe return value is of type integer and of the system-dependent kind\nc*size_t (from the iso\\_c\\_binding* module). Its value is the\nnumber of bytes occupied by the argument. If the argument has the\n_pointer_ attribute, the number of bytes of the storage area pointed to is\nreturned. If the argument is of a derived type with _pointer_ or\n_allocatable_ components, the return value does not account for the sizes\nof the data pointed to by these components.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_c_sizeof\nuse iso_c_binding\nimplicit none\nreal(c_float) :: r, s(5)\n   print *, (c_sizeof(s)/c_sizeof(r) == 5)\nend program demo_c_sizeof\n```\n\nResults:\n\n```text\n    T\n```\n\nThe example will print _.true._ unless you are using a platform where\ndefault _real_ variables are unusually padded.\n\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**storage_size**(3)](#storage_size)\n\n _fortran-lang intrinsic descriptions_\n",
  "DATE_AND_TIME": "## date_and_time\n\n### **Name**\n\n**date_and_time** - \\[SYSTEM:TIME\\] Gets current date time\n\n### **Synopsis**\n```fortran\n    call date_and_time( [date] [,time] [,zone] [,values] )\n```\n```fortran\n     subroutine date_and_time(date, time, zone, values)\n\n      character(len=8),intent(out),optional :: date\n      character(len=10),intent(out),optional :: time\n      character(len=5),intent(out),optional :: zone\n      integer,intent(out),optional :: values(8)\n```\n### **Characteristics**\n\n - **date*, - **time*, and **zone* are default _character_ scalar types\n - **values** is a rank-one array of type integer with a decimal\n exponent range of at least four.\n\n### **Description**\n\n  **date_and_time** gets the corresponding date and time information\n  from the real-time system clock.\n\n  Unavailable time and date _character_ parameters return blanks.\n\n  Unavailable numeric parameters return **-huge(value)**.\n\n  These forms are compatible with the representations defined in ISO\n  8601:2004. UTC is established by the International Bureau of Weights\n  and Measures (BIPM, i.e. Bureau International des Poids et Mesures)\n  and the International Earth Rotation Service (IERS).\n\n### **Options**\n\n- **date**\n  : A character string of default kind of the form CCYYMMDD, of length\n    8 or larger, where\n\n      + CCYY is the year in the Gregorian calendar\n      + MM is the month within the year\n      + DD is the day within the month.\n\n    The characters of this value are all decimal digits.\n\n    If there is no date available, DATE is assigned all blanks.\n\n- **time**\n  : A character string of default kind of the form HHMMSS.SSS, of length\n    10 or larger, where\n\n     + hh is the hour of the day,\n     + mm is the minutes of the hour,\n     + and ss.sss is the seconds and milliseconds of the minute.\n\n    Except for the decimal point, the characters of this value shall\n    all be decimal digits.\n\n    If there is no clock available, TIME is assigned all blanks.\n\n- **zone**\n  : A string of the form (+-)HHMM, of length 5 or larger, representing\n    the difference with respect to Coordinated Universal Time (UTC), where\n\n     + hh and mm are the time difference with respect to Coordinated\n       Universal Time (UTC) in hours and minutes, respectively.\n\n   The characters of this value following the sign character are\n   all decimal digits.\n\n   If this information is not available, ZONE is assigned all blanks.\n\n- **values**\n  : An array of at least eight elements. If there is no data\n  available for a value it is set to **-huge(values)**. Otherwise,\n  it contains:\n\n  - **values**(1) : The year, including the century.\n  - **values**(2) : The month of the year\n  - **values**(3) : The day of the month\n  - **values**(4) : Time difference in minutes between the reported time\n                    and UTC time.\n  - **values**(5) : The hour of the day, in the range 0 to 23.\n  - **values**(6) : The minutes of the hour, in the range 0 to 59\n  - **values**(7) : The seconds of the minute, in the range 0 to 60\n  - **values**(8) : The milliseconds of the second, in the range 0 to 999.\n\n The date, clock, and time zone information might be available on some\n images and not others. If the date, clock, or time zone information is\n available on more than one image, it is processor dependent whether or\n not those images share the same information.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_date_and_time\n   implicit none\n   character(len=8)     :: date\n   character(len=10)    :: time\n   character(len=5)     :: zone\n   integer, dimension(8) :: values\n\n   call date_and_time(date, time, zone, values)\n\n   ! using keyword arguments\n   call date_and_time(DATE=date, TIME=time, ZONE=zone)\n   print '(*(g0))','DATE=\"',date,'\" TIME=\"',time,'\" ZONE=\"',zone,'\"'\n\n   call date_and_time(VALUES=values)\n   write (*, '(i5,a)') &\n    & values(1), ' - The year', &\n    & values(2), ' - The month', &\n    & values(3), ' - The day of the month', &\n    & values(4), ' - Time difference with UTC in minutes', &\n    & values(5), ' - The hour of the day', &\n    & values(6), ' - The minutes of the hour', &\n    & values(7), ' - The seconds of the minute', &\n    & values(8), ' - The milliseconds of the second'\n\n   write (*, '(a)') iso_8601()\ncontains\n   function iso_8601()\n   ! return date using ISO-8601 format at a resolution of seconds\n   character(len=8)  :: dt\n   character(len=10) :: tm\n   character(len=5)  :: zone\n   character(len=25) :: iso_8601\n   call date_and_time(dt, tm, zone)\n      ISO_8601 = dt(1:4)//'-'//dt(5:6)//'-'//dt(7:8) &\n               & //'T'//                             &\n               & tm(1:2)//':'//tm(3:4)//':'//tm(5:6) &\n               & //zone(1:3)//':'//zone(4:5)\n   end function iso_8601\nend program demo_date_and_time\n```\nResults:\n```text\n > DATE=\"20240426\" TIME=\"111545.335\" ZONE=\"-0400\"\n >  2024 - The year\n >     4 - The month\n >    26 - The day of the month\n >  -240 - Time difference with UTC in minutes\n >    11 - The hour of the day\n >    15 - The minutes of the hour\n >    45 - The seconds of the minute\n >   335 - The milliseconds of the second\n > 2024-04-26T11:15:45-04:00\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**cpu_time**(3)](#cpu_time),\n[**system_clock**(3)](#system_clock)\n\n### **Resources**\n\ndate and time conversion, formatting and computation\n\n- [M_time](https://github.com/urbanjost/M_time) - https://github.com/urbanjost/M_time\n- [fortran-datetime](https://github.com/dongli/fortran-datetime) - https://github.com/dongli/fortran-datetime\n- [datetime-fortran](https://github.com/wavebitscientific/datetime-fortran) - https://github.com/wavebitscientific/datetime-fortran\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "DBLE": "## dble\n\n### **Name**\n\n**dble** - \\[TYPE:NUMERIC\\] Converstion to double precision real\n\n### **Synopsis**\n```fortran\n    result = dble(a)\n```\n```fortran\n     elemental doubleprecision function dble(a)\n\n      doubleprecision :: dble\n      TYPE(kind=KIND),intent(in) :: a\n```\n### **Characteristics**\n\n - **a** my be _integer_, _real_, _complex_, or a BOZ-literal-constant\n - the result is a doubleprecision _real_.\n\n### **Description**\n\n**dble** Converts **a** to double precision _real_ type.\n\n### **Options**\n\n- **a**\n  : a value to convert to a doubleprecision _real_.\n\n### **Result**\n\nThe return value is of type _doubleprecision_. For _complex_ input,\nthe returned value has the magnitude and sign of the real component\nof the input value.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_dble\nimplicit none\nreal:: x = 2.18\ninteger :: i = 5\ncomplex :: z = (2.3,1.14)\n   print *, dble(x), dble(i), dble(z)\nend program demo_dble\n```\nResults:\n\n```text\n  2.1800000667572021  5.0000000000000000   2.2999999523162842\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See also**\n\n- [**aimag**(3)](#aimag) - Imaginary part of complex number\n- [**cmplx**(3)](#cmplx) - Convert values to a complex type\n- [**int**(3)](#int) - Truncate towards zero and convert to integer\n- [**nint**(3)](#nint) - Nearest whole number\n- [**out\\_of\\_range**(3)](#out_of_range) - Whether a value cannot be converted safely.\n- [**real**(3)](#real) - Convert to real type\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "DIGITS": "## digits\n\n### **Name**\n\n**digits** - \\[NUMERIC MODEL\\] Significant digits in the numeric model\n\n### **Synopsis**\n```fortran\n    result = digits(x)\n```\n```fortran\n     integer function digits(x)\n\n      TYPE(kind=KIND),intent(in) :: x(..)\n```\n### **Characteristics**\n\n - **x** an _integer_ or _real_ scalar or array\n\n - The return value is an _integer_ of default kind.\n\n### **Description**\n\n  **digits** returns the number of significant digits of the internal\n  model representation of **x**. For example, on a system using a 32-bit\n  floating point representation, a default real number would likely\n  return 24.\n\n### **Options**\n\n- **x**\n  : a value of the type and kind to query\n\n### **Result**\n\n  The number of significant digits in a variable of the type and kind\n  of **x**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_digits\nimplicit none\ninteger :: i = 12345\nreal :: x = 3.143\ndoubleprecision :: y = 2.33d0\n   print *,'default integer:', digits(i)\n   print *,'default real:   ', digits(x)\n   print *,'default doubleprecision:', digits(y)\nend program demo_digits\n```\nResults:\n```text\n >  default integer:          31\n >  default real:             24\n >  default doubleprecision:          53\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**epsilon**(3)](#epsilon),\n[**exponent**(3)](#exponent),\n[**fraction**(3)](#fraction),\n[**huge**(3)](#huge),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**nearest**(3)](#nearest),\n[**precision**(3)](#precision),\n[**radix**(3)](#radix),\n[**range**(3)](#range),\n[**rrspacing**(3)](#rrspacing),\n[**scale**(3)](#scale),\n[**set_exponent**(3)](#set_exponent),\n[**spacing**(3)](#spacing),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "DIM": "## dim\n\n### **Name**\n\n**dim** - \\[NUMERIC\\] Positive difference of X - Y\n\n### **Synopsis**\n```fortran\n    result = dim(x, y)\n```\n```fortran\n     elemental TYPE(kind=KIND) function dim(x, y )\n\n      TYPE(kind=KIND),intent(in) :: x, y\n```\n### **Characteristics**\n\n- **x** and **y** may be any _real_ or _integer_ but of the same type\n  and kind\n- the result is of the same type and kind as the arguments\n\n### **Description**\n\n  **dim** returns the maximum of **x - y** and zero.\n  That is, it returns the difference **x - y** if the result is positive;\n  otherwise it returns zero. It is equivalent to\n```fortran\n  max(0,x-y)\n```\n### **Options**\n\n- **x**\n  : the subtrahend, ie. the number being subtracted from.\n\n- **y**\n  : the minuend; ie. the number being subtracted\n\n### **Result**\n\nReturns the difference **x - y** or zero, whichever is larger.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_dim\nuse, intrinsic :: iso_fortran_env, only : real64\nimplicit none\ninteger           :: i\nreal(kind=real64) :: x\n\n   ! basic usage\n    i = dim(4, 15)\n    x = dim(4.321_real64, 1.111_real64)\n    print *, i\n    print *, x\n\n   ! elemental\n    print *, dim([1,2,3],2)\n    print *, dim([1,2,3],[3,2,1])\n    print *, dim(-10,[0,-10,-20])\n\nend program demo_dim\n```\nResults:\n```text\n >            0\n >    3.21000000000000\n >            0           0           1\n >            0           0           2\n >            0           0          10\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n[****(3)](#)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "DOT_PRODUCT": "## dot_product\n\n### **Name**\n\n**dot_product** - \\[TRANSFORMATIONAL\\] Dot product of two vectors\n\n### **Synopsis**\n```fortran\n    result = dot_product(vector_a, vector_b)\n```\n```fortran\n     TYPE(kind=KIND) function dot_product(vector_a, vector_b)\n\n      TYPE(kind=KIND),intent(in) :: vector_a(:)\n      TYPE(kind=KIND),intent(in) :: vector_b(:)\n```\n### **Characteristics**\n\n - **vector_a**, **vector_b**  may be any numeric or logical type array\n   of rank one of the same size\n - the two vectors need not be of the same kind, but both must be logical\n   or numeric for any given call.\n - the result is the same type and kind of the vector that is the higher\n   type that the other vector is optionally promoted to if they differ.\n\nThe two vectors may be either numeric or logical and must be arrays\nof rank one and of equal size.\n\n### **Description**\n\n**dot_product** computes the dot product\nmultiplication of two vectors **vector_a** and **vector_b**.\n\n### **Options**\n\n- **vector_a**\n  : A rank 1 vector of values\n\n- **vector_b**\n  : The type shall be numeric if **vector_a** is of numeric type\n  or _logical_ if vector_a is of type _logical_. vector_b shall be a\n  rank-one array of the same size as **vector_a**.\n\n### **Result**\n\nIf the arguments are numeric, the return value is a scalar of numeric\ntype.  If the arguments are _logical_, the\nreturn value is _.true._ or _.false._.\n\nIf the vectors are _integer_ or _real_, the result is\n```fortran\n     sum(vector_a*vector_b)\n```\nIf the vectors are _complex_, the result is\n```fortran\n     sum(conjg(vector_a)*vector_b)**\n```\nIf the vectors are _logical_, the result is\n```fortran\n     any(vector_a .and. vector_b)\n```\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_dot_prod\nimplicit none\n    integer, dimension(3) :: a, b\n    a = [ 1, 2, 3 ]\n    b = [ 4, 5, 6 ]\n    print '(3i3)', a\n    print *\n    print '(3i3)', b\n    print *\n    print *, dot_product(a,b)\nend program demo_dot_prod\n```\nResults:\n```text\n  >  1  2  3\n  >\n  >  4  5  6\n  >\n  >           32\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**sum**(3)](#sum),\n[**conjg**(3)](#conjg),\n[**any**(3)](#any)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "DPROD": "## dprod\n\n### **Name**\n\n**dprod** - \\[NUMERIC\\] Double precision real product\n\n### **Synopsis**\n```fortran\n    result = dprod(x,y)\n```\n```fortran\n     elemental function dprod(x,y)\n\n      real,intent(in) :: x\n      real,intent(in) :: y\n      doubleprecision :: dprod\n```\n### **Characteristics**\n\n - **x** is a default real.\n - **y** is a default real.\n - the result is a _doubleprecision_ real.\n\n  The setting of compiler options specifying the size of a default _real_\n  can affect this function.\n\n### **Description**\n\n  **dprod** produces a _doubleprecision_ product of default _real_\n  values **x** and **y**.\n\n  That is, it is expected to convert the arguments to double precision\n  before multiplying, which a simple expression **x\\*y** would not be\n  required to do. This can be significant in specialized computations\n  requiring high precision.\n\n  The result has a value equal to a processor-dependent approximation\n  to the product of **x** and **y**. Note it is recommended in the\n  standard that the processor compute the product in double precision,\n  rather than in single precision then converted to double precision;\n  but is only a recommendation.\n\n### **Options**\n\n- **x**\n  : the multiplier\n\n- **y**\n  : the multiplicand\n\n### **Result**\n\nThe returned value of the product should have the same value as\n**dble(x)\\*dble(y)**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_dprod\nimplicit none\ninteger,parameter :: dp=kind(0.0d0)\nreal :: x = 5.2\nreal :: y = 2.3\ndoubleprecision :: xx\nreal(kind=dp)   :: dd\n\n   print *,'algebraically 5.2 x 2.3 is exactly 11.96'\n   print *,'as floating point values results may differ slightly:'\n   ! basic usage\n   dd = dprod(x,y)\n   print *, 'compare dprod(xy)=',dd, &\n   & 'to x*y=',x*y, &\n   & 'to dble(x)*dble(y)=',dble(x)*dble(y)\n\n   print *,'test if an expected result is produced'\n   xx=-6.0d0\n   write(*,*)DPROD(-3.0, 2.0),xx\n   write(*,*)merge('PASSED','FAILED',DPROD(-3.0, 2.0) == xx)\n\n   print *,'elemental'\n   print *, dprod( [2.3,3.4,4.5], 10.0 )\n   print *, dprod( [2.3,3.4,4.5], [9.8,7.6,5.4] )\n\nend program demo_dprod\n```\nResults:\n(this can vary between programming environments):\n```text\n >  algebraically 5.2 x 2.3 is exactly 11.96\n >  as floating point values results may differ slightly:\n >  compare dprod(xy)=   11.9599993133545      to x*y=   11.96000\n >  to dble(x)*dble(y)=   11.9599993133545\n >  test if an expected result is produced\n >   -6.00000000000000       -6.00000000000000\n >  PASSED\n >  elemental\n >    22.9999995231628     34.0000009536743     45.0000000000000\n >    22.5399999713898     25.8400004005432     24.3000004291534\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n[**dble**(3)](#dble)\n[**real**(3)](#real)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "DSHIFTL": "## dshiftl\n\n### **Name**\n\n**dshiftl** - \\[BIT:COPY\\] Combined left shift of the bits of two integers\n\n### **Synopsis**\n```fortran\n    result = dshiftl(i, j, shift)\n```\n```fortran\n     elemental integer(kind=KIND) function dshiftl(i, j, shift)\n\n      integer(kind=KIND),intent(in) :: i\n      integer(kind=KIND),intent(in) :: j\n      integer(kind=**),intent(in) :: shift\n```\n### **Characteristics**\n\n  - the kind of **i**, **j**, and the return value are the same. An\n    exception is that one of **i** and **j** may be a BOZ literal constant\n    (A BOZ literal constant is a binary, octal or hex constant).\n\n  - If either I or J is a BOZ-literal-constant (but not both), it is\n    first converted as if by the intrinsic function **int**(3) to type\n    _integer_ with the kind type parameter of the other.\n\n  - a kind designated as ** may be any supported kind for the type\n\n### **Description**\n\n  **dshiftl** combines bits of **i** and **j**. The rightmost **shift**\n  bits of the result are the leftmost **shift** bits of **j**, and the\n  remaining bits are the rightmost **bitsize(i)-shift** of **i**.\n\n  Hence **dshiftl** is designated as a \"combined left shift\", because\n  it is like we appended **i** and **j** together, shifted it **shift**\n  bits to the left, and then kept the same number of bits as **i** or\n  **j** had.\n\n  For example, for two 16-bit values if **shift=6**\n```text\n      SHIFT=6\n      I =             1111111111111111\n      J =             0000000000000000\n      COMBINED        11111111111111110000000000000000\n      DROP LEFT BITS  11111111110000000000000000\n      KEEP LEFT 16    1111111111000000\n```\n#### NOTE\n  This is equivalent to\n```fortran\n     ior( shiftl(i, shift), shiftr(j, bit_size(j) - shift) )\n```\n  Also note that using this last representation of the operation is can\n  be derived that when both **i** and **j** have the same value as in\n```fortran\n      dshiftl(i, i, shift)\n```\n  the result has the same value as a circular shift:\n```fortran\n      ishftc(i, shift)\n```\n### **Options**\n\n- **i**\n  : used to define the left pattern of bits in the combined pattern\n\n- **j**\n  : used for the right pattern of bits in the combined pattern\n\n- **shift**\n  : shall be nonnegative and less than or equal to the number of bits\n    in an _integer_ input value (ie. the bit size of either one that is\n    not a BOZ literal constant).\n\n### **Result**\n\n  The leftmost **shift** bits of **j** are copied to the rightmost bits\n  of the result, and the remaining bits are the rightmost bits of **i**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_dshiftl\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger(kind=int32) :: i, j\ninteger             :: shift\n\n  ! basic usage\n   write(*,*) dshiftl (1, 2**30, 2) ! int32 values on little-endian => 5\n\n  ! print some simple calls as binary to better visual the results\n   i=-1\n   j=0\n   shift=5\n   call printit()\n\n   ! the leftmost SHIFT bits of J are copied to the rightmost result bits\n   j=int(b\"11111000000000000000000000000000\")\n   ! and the other bits are the rightmost bits of I\n   i=int(b\"00000000000000000000000000000000\")\n   call printit()\n\n   j=int(b\"11111000000000000000000000000000\")\n   i=int(b\"00000111111111111111111111111111\")\n   ! result should be all 1s\n   call printit()\n\ncontains\nsubroutine printit()\n   ! print i,j,shift and then i,j, and the result as binary values\n    write(*,'(*(g0))')'I=',i,' J=',j,' SHIFT=',shift\n    write(*,'(b32.32)') i,j, dshiftl (i, j, shift)\nend subroutine printit\n\nend program demo_dshiftl\n```\nResults:\n```text\n >            5\n > I=-1 J=0 SHIFT=5\n > 11111111111111111111111111111111\n > 00000000000000000000000000000000\n > 11111111111111111111111111100000\n > I=0 J=-134217728 SHIFT=5\n > 00000000000000000000000000000000\n > 11111000000000000000000000000000\n > 00000000000000000000000000011111\n > I=134217727 J=-134217728 SHIFT=5\n > 00000111111111111111111111111111\n > 11111000000000000000000000000000\n > 11111111111111111111111111111111\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**dshiftr**(3)](#dshiftr)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "DSHIFTR": "## dshiftr\n\n### **Name**\n\n**dshiftr** - \\[BIT:COPY\\] Combined right shift of the bits of two integers\n\n### **Synopsis**\n```fortran\n    result = dshiftr(i, j, shift)\n```\n```fortran\n     elemental integer(kind=KIND) function dshiftr(i, j, shift)\n\n      integer(kind=KIND),intent(in) :: i\n      integer(kind=KIND),intent(in) :: j\n      integer(kind=**),intent(in) :: shift\n```\n### **Characteristics**\n\n  - a kind designated as ** may be any kind value for the _integer_ type\n\n  - the kind of **i**, **j**, and the return value are the same. An\n    exception is that one of **i** and **j** may be a BOZ literal constant\n    (A BOZ literal constant is a binary, octal or hex constant).\n\n  - If either I or J is a BOZ-literal-constant, it is first converted\n    as if by the intrinsic function **int**(3) to type _integer_ with the\n    kind type parameter of the other.\n\n### **Description**\n\n  **dshiftr** combines bits of **i** and **j**. The leftmost **shift**\n  bits of the result are the rightmost **shift** bits of **i**, and the\n  remaining bits are the leftmost bits of **j**.\n\n  It may be thought of as appending the bits of **i** and **j**, dropping\n  off the **shift** rightmost bits, and then retaining the same number\n  of rightmost bits as an input value, hence the name \"combined right\n  shift\"...\n\nGiven two 16-bit values labeled alphabetically ...\n```text\n   i=ABCDEFGHIJKLMNOP\n   j=abcdefghijklmnop\n```\nAppend them together\n```text\n   ABCDEFGHIJKLMNOPabcdefghijklmnop\n```\nShift them N=6 bits to the right dropping off bits\n```text\n         ABCDEFGHIJKLMNOPabcdefghij\n```\nKeep the 16 right-most bits\n```text\n                   KLMNOPabcdefghij\n```\n#### NOTE\n\n**dshifr(i,j,shift)** is equivalent to\n```fortran\n     ior(shiftl (i, bit_size(i) - shift), shiftr(j, shift) )\n```\nit can also be seen that if **i** and **j** have the same\nvalue\n```fortran\n     dshiftr( i, i, shift )\n```\nthis has the same result as a negative circular shift\n```fortran\n     ishftc( i,   -shift ).\n```\n### **Options**\n\n- **i**\n  : left value of the pair of values to be combine-shifted right\n\n- **j**\n  : right value of the pair of values to be combine-shifted right\n\n- **shift**\n  : the shift value is non-negative and less than or equal to the number\n    of bits in an input value as can be computed by **bit_size**(3).\n\n### **Result**\n\nThe result is a combined right shift of **i** and **j** that is the\nsame as the bit patterns of the inputs being combined left to right,\ndropping off **shift** bits on the right and then retaining the same\nnumber of bits as an input value from the rightmost bits.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_dshiftr\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger(kind=int32) :: i, j\ninteger             :: shift\n\n  ! basic usage\n   write(*,*) dshiftr (1, 2**30, 2)\n\n  ! print some calls as binary to better visualize the results\n   i=-1\n   j=0\n   shift=5\n\n   ! print values\n    write(*,'(*(g0))')'I=',i,' J=',j,' SHIFT=',shift\n    write(*,'(b32.32)') i,j, dshiftr (i, j, shift)\n\n  ! visualizing a \"combined right shift\" ...\n   i=int(b\"00000000000000000000000000011111\")\n   j=int(b\"11111111111111111111111111100000\")\n   ! appended together ( i//j )\n   ! 0000000000000000000000000001111111111111111111111111111111100000\n   ! shifted right SHIFT values dropping off shifted values\n   !      00000000000000000000000000011111111111111111111111111111111\n   ! keep enough rightmost bits to fill the kind\n   !                                 11111111111111111111111111111111\n   ! so the result should be all 1s bits ...\n\n    write(*,'(*(g0))')'I=',i,' J=',j,' SHIFT=',shift\n    write(*,'(b32.32)') i,j, dshiftr (i, j, shift)\n\nend program demo_dshiftr\n```\nResults:\n```text\n >    1342177280\n >  I=-1 J=0 SHIFT=5\n >  11111111111111111111111111111111\n >  00000000000000000000000000000000\n >  11111000000000000000000000000000\n >  I=31 J=-32 SHIFT=5\n >  00000000000000000000000000011111\n >  11111111111111111111111111100000\n >  11111111111111111111111111111111\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**dshiftl**(3)](#dshiftl)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "EOSHIFT": "## eoshift\n\n### **Name**\n\n**eoshift** - \\[TRANSFORMATIONAL\\] End-off shift of elements of an array\n\n### **Synopsis**\n```fortran\n  result = eoshift( array, shift [,boundary] [,dim] )\n```\n```fortran\n   type(TYPE(kind=KIND)) function eoshift(array,shift,boundary,dim)\n\n    type(TYPE(kind=KIND)),intent(in) :: array(..)\n    integer(kind=**),intent(in)      :: shift(..)\n    type(TYPE(kind=KIND)),intent(in) :: boundary(..)\n    integer(kind=**),intent(in)      :: dim\n```\n### **Characteristics**\n\n - **array** an array of any type\n - **shift** is an integer of any kind. It may be a scalar.\n   If the rank of **array** is greater than one, and **dim** is\n   specified it is the same shape as **array** reduced by removing\n   dimension **dim**.\n - **boundary** May be a scalar of the same type and kind as **array**.\n   It must be a scalar when **array** has a rank of one. Otherwise, it\n   may be an array of the same shape as **array** reduced by dimension\n   **dim**. It may only be absent for certain types, as described below.\n - **dim** is an integer of any kind. It defaults to one.\n - the result has the same type, type parameters, and shape as **array**.\n - a kind designated as ** may be any supported kind for the type\n\n - The result is an array of same type, kind and rank as the **array**\n   argument.\n\n### **Description**\n\n  **eoshift** performs an end-off shift on elements of **array**\n  along the dimension of **dim**.\n\n  Elements shifted out one end of each rank one section are dropped.\n\n  If **boundary** is present then the corresponding value from\n  **boundary** is copied back in the other end, else default values\n  are used.\n\n### **Options**\n\n- **array**\n  : array of any type whose elements are to be shifted.\n  If the rank of **array** is one, then all elements of **array** are\n  shifted by **shift** places. If rank is greater than one, then all\n  complete rank one sections of **array** along the given dimension\n  are shifted.\n\n- **shift**\n  : the number of elements to shift. A negative value shifts to the\n  right, a positive value to the left of the vector(s) being shifted.\n\n- **boundary**\n  : the value to use to fill in the elements vacated by the shift.\n  If **boundary** is not present then the following are copied in\n  depending on the type of **array**.\n```text\n    Array Type    | Boundary Value\n    -----------------------------------------------------\n    Numeric       | 0, 0.0, or (0.0, 0.0) of the type and kind of \"array\"\n    Logical       | .false.\n    Character(len)|  LEN blanks\n```\n  These are the only types for which **boundary** may not be present.\n  For these types the kind is converted as neccessary to the kind of\n  **array**.\n- **dim**\n  :  **dim** is in the range of\n```fortran\n    1 <= DIM <= n\n```\n  where **\"n\"** is the rank of **array**. If **dim** is omitted it\n  is taken to be **1**.\n\n### **Result**\n\n Returns an array of the same characteristics as the input with the\n specified number of elements dropped off along the specified direction\n indicated, backfilling the vacated elements with a value indicated by\n the **boundary** value.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_eoshift\nimplicit none\ninteger, dimension(3,3) :: a\ninteger :: i\n\n    a = reshape( [ 1, 2, 3, 4, 5, 6, 7, 8, 9 ], [ 3, 3 ])\n    print '(3i3)', (a(i,:),i=1,3)\n\n    print *\n\n    ! shift it\n    a = eoshift(a, SHIFT=[1, 2, 1], BOUNDARY=-5, DIM=2)\n    print '(3i3)', (a(i,:),i=1,3)\n\nend program demo_eoshift\n```\nResults:\n\n```text\n  >  1  4  7\n  >  2  5  8\n  >  3  6  9\n  >\n  >  4  7 -5\n  >  8 -5 -5\n  >  6  9 -5\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**dshiftr**(3)](#dshiftr),\n[**dshiftl**(3)](#dshiftl)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "EPSILON": "## epsilon\n\n### **Name**\n\n**epsilon** - \\[NUMERIC MODEL\\] Epsilon function\n\n### **Synopsis**\n```fortran\n    result = epsilon(x)\n```\n```fortran\n     real(kind=kind(x)) function epsilon(x)\n\n      real(kind=kind(x),intent(in)   :: x(..)\n```\n### **Characteristics**\n\n - **x** shall be of type _real_. It may be a scalar or an array.\n - the result is a scalar of the same type and kind type parameter as **x**.\n\n### **Description**\n\n**epsilon** returns the floating point relative accuracy.\nIt is the nearly negligible number relative to **1**\nsuch that **1+ little_number** is not equal to **1**; or more\nprecisely\n```fortran\n   real( 1.0, kind(x)) + epsilon(x) /=  real( 1.0, kind(x))\n```\nIt may be thought of as the distance from 1.0 to the next largest\nfloating point number.\n\nOne use of **epsilon** is to select a _delta_ value for algorithms that\nsearch until the calculation is within _delta_ of an estimate.\n\nIf _delta_ is too small the algorithm might never halt, as a computation\nsumming values smaller than the decimal resolution of the data type does\nnot change.\n\n### **Options**\n\n- **x**\n  : The type shall be _real_.\n\n### **Result**\n\nThe return value is of the same type as the argument.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_epsilon\nuse,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32\nimplicit none\nreal(kind=sp) :: x = 3.143\nreal(kind=dp) :: y = 2.33d0\n\n   ! so if x is of type real32, epsilon(x) has the value 2**-23\n   print *, epsilon(x)\n   ! note just the type and kind of x matter, not the value\n   print *, epsilon(huge(x))\n   print *, epsilon(tiny(x))\n\n   ! the value changes with the kind of the real value though\n   print *, epsilon(y)\n\n   ! adding and subtracting epsilon(x) changes x\n   write(*,*)x == x + epsilon(x)\n   write(*,*)x == x - epsilon(x)\n\n   ! these next two comparisons will be .true. !\n   write(*,*)x == x + epsilon(x) * 0.999999\n   write(*,*)x == x - epsilon(x) * 0.999999\n\n   ! you can calculate epsilon(1.0d0)\n   write(*,*)my_dp_eps()\n\ncontains\n\n   function my_dp_eps()\n   ! calculate the epsilon value of a machine the hard way\n   real(kind=dp) :: t\n   real(kind=dp) :: my_dp_eps\n\n      ! starting with a value of 1, keep dividing the value\n      ! by 2 until no change is detected. Note that with\n      ! infinite precision this would be an infinite loop,\n      ! but floating point values in Fortran have a defined\n      ! and limited precision.\n      my_dp_eps = 1.0d0\n      SET_ST: do\n         my_dp_eps = my_dp_eps/2.0d0\n         t = 1.0d0 + my_dp_eps\n         if (t <= 1.0d0) exit\n      enddo SET_ST\n      my_dp_eps = 2.0d0*my_dp_eps\n\n   end function my_dp_eps\nend program demo_epsilon\n```\nResults:\n```text\n  1.1920929E-07\n  1.1920929E-07\n  1.1920929E-07\n  2.220446049250313E-016\n F\n F\n T\n T\n  2.220446049250313E-016\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**exponent**(3)](#exponent),\n[**fraction**(3)](#fraction),\n[**huge**(3)](#huge),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**nearest**(3)](#nearest),\n[**precision**(3)](#precision),\n[**radix**(3)](#radix),\n[**range**(3)](#range),\n[**rrspacing**(3)](#rrspacing),\n[**scale**(3)](#scale),\n[**set_exponent**(3)](#set_exponent),\n[**spacing**(3)](#spacing),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ERF": "## erf\n\n### **Name**\n\n**erf** - \\[MATHEMATICS\\] Error function\n\n### **Synopsis**\n```fortran\n    result = erf(x)\n```\n```fortran\n     elemental real(kind=KIND) function erf(x)\n\n      real(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **x** is of type _real_\n - The result is of the same _type_ and _kind_ as **x**.\n\n### **Description**\n\n**erf** computes the error function of **x**, defined as\n\n$$\n\\text{erf}(x) = \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{__-t__^2} dt.\n$$\n\n### **Options**\n\n- **x**\n  : The type shall be _real_.\n\n### **Result**\n\nThe return value is of type _real_, of the same kind as **x** and lies in the\nrange **-1** \\<= **erf**(x) \\<= 1 .\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_erf\nuse, intrinsic :: iso_fortran_env, only : real_kinds, &\n & real32, real64, real128\nimplicit none\nreal(kind=real64) :: x = 0.17_real64\n    write(*,*)x, erf(x)\nend program demo_erf\n```\nResults:\n```text\n     0.17000000000000001       0.18999246120180879\n```\n### **Standard**\n\nFortran 2008\n\n### **See also**\n\n[**erfc**(3)](#erfc),\n[**erf_scaled**(3)](#erfc_scaled)\n\n### **Resources**\n\n- [Wikipedia:error function](https://en.wikipedia.org/wiki/Error_function)\n\n _fortran-lang intrinsic descriptions_\n",
  "ERFC": "## erfc\n\n### **Name**\n\n**erfc** - \\[MATHEMATICS\\] Complementary error function\n\n### **Synopsis**\n```fortran\n    result = erfc(x)\n```\n```fortran\n     elemental real(kind=KIND) function erfc(x)\n\n      real(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **x** is of type _real_ and any valid kind\n - **KIND** is any value valid for type _real_\n - the result has the same characteristics as **x**\n\n### **Description**\n\n  **erfc** computes the complementary error function of **x**. Simply\n  put this is equivalent to **1 - erf(x)**, but **erfc** is provided\n  because of the extreme loss of relative accuracy if **erf(x)** is\n  called for large **x** and the result is subtracted from **1**.\n\n  **erfc(x)** is defined as\n\n<!--\n$$\n\\text{erfc}(x) = 1 - \\text{erf}(x) = 1 - \\frac{2}{\\sqrt{\\pi}} \\int_0^x e^{-t^2} dt.\n$$\n-->\n\n$$\n\\text{erfc}(x) = 1 - \\text{erf}(x) = 1 - \\frac{2}{\\sqrt{\\pi}} \\int_x^{\\infty} e^{-t^2} dt.\n$$\n\n### **Options**\n\n- **x**\n  : The type shall be _real_.\n\n### **Result**\n\n  The return value is of type _real_ and of the same kind as **x**. It lies in\n  the range\n```fortran\n     0 \\<= **erfc**(x) \\<= 2.\n```\nand is a  processor-dependent approximation to the complementary error\nfunction of **x** ( **1-erf(x) ).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_erfc\nuse, intrinsic :: iso_fortran_env, only : &\n & real_kinds, real32, real64, real128\nimplicit none\nreal(kind=real64) :: x = 0.17_real64\n   write(*,'(*(g0))')'X=',x, ' ERFC(X)=',erfc(x)\n   write(*,'(*(g0))')'equivalently 1-ERF(X)=',1-erf(x)\nend program demo_erfc\n```\nResults:\n```text\n > X=.1700000000000000 ERFC(X)=.8100075387981912\n > equivalently 1-ERF(X)=.8100075387981912\n```\n### **Standard**\n\nFortran 2008\n\n### **See also**\n\n[**erf**(3)](#erf)\n[**erf_scaled**(3)](#erf_scaled)\n\n### **Resources**\n\n- [Wikipedia:error function](https://en.wikipedia.org/wiki/Error_function)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ERFC_SCALED": "## erfc_scaled\n\n### **Name**\n\n**erfc_scaled** - \\[MATHEMATICS\\] Scaled complementary error function\n\n### **Synopsis**\n```fortran\n    result = erfc_scaled(x)\n```\n```fortran\n     elemental real(kind=KIND) function erfc_scaled(x)\n\n      real(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **x** is of type _real_ of any valid kind\n - **KIND** is any kind valid for a _real_ type\n - the result has the same characteristics as **x**\n\n### **Description**\n\n**erfc_scaled** computes the exponentially-scaled complementary\nerror function of **x**:\n\n$$\ne^{x^2} \\frac{2}{\\sqrt{\\pi}} \\int_{x}^{\\infty}\ne^{-t^2} dt.\n$$\n\nerfc_scaled(x)=exp(x*x)erfc(x)\n\n\n#### NOTE1\n\n  The complementary error function is asymptotic to\n  exp(-X2)/(X/PI). As such it underflows at approximately X >= 9 when\n  using ISO/IEC/IEEE 60559:2011 single precision arithmetic. The\n  exponentially-scaled complementary error function is asymptotic to\n  1/(X  PI). As such it does not underflow until X > HUGE (X)/PI.\n\n### **Options**\n\n- **x**\n  the value to apply the **erfc** function to\n\n### **Result**\n\nThe approximation to the exponentially-scaled complementary error function\nof **x**\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_erfc_scaled\nimplicit none\nreal(kind(0.0d0)) :: x = 0.17d0\n   x = erfc_scaled(x)\n   print *, x\nend program demo_erfc_scaled\n```\nResults:\n```text\n >   0.833758302149981\n```\n### **Standard**\n\nFortran 2008\n\n### **See also**\n\n[**erf**(3)](#erf),\n[**exp**(3)](#exp),\n[**erfc**(3)](#erfc)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "EVENT_QUERY": "## event_query\n\n### **Name**\n\n**event_query** - \\[COLLECTIVE\\] Query whether a coarray event has occurred\n\n### **Synopsis**\n```fortran\n    call event_query(event, count [,stat] )\n```\n```fortran\n```\n### **Characteristics**\n\n### **Description**\n\n**event_query** assigns the number of events to **count** which have been\nposted to the **event** variable and not yet been removed by calling\n**event_wait**. When **stat** is present and the invocation was successful, it\nis assigned the value **0**. If it is present and the invocation has failed,\nit is assigned a positive value and **count** is assigned the value **-1**.\n\n### **Options**\n\n- **event**\n  : (intent(in)) Scalar of type event_type, defined in\n  iso_fortran_env; shall not be coindexed.\n\n- **count**\n  : (intent(out))Scalar integer with at least the precision of default\n  _integer_.\n\n- **stat**\n  : (OPTIONAL) Scalar default-kind _integer_ variable.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_event_query\nuse iso_fortran_env\nimplicit none\ntype(event_type) :: event_value_has_been_set[*]\ninteger :: cnt\n   if (this_image() == 1) then\n      call event_query(event_value_has_been_set, cnt)\n      if (cnt > 0) write(*,*) \"Value has been set\"\n   elseif (this_image() == 2) then\n      event post(event_value_has_been_set[1])\n   endif\nend program demo_event_query\n```\n### **Standard**\n\nTS 18508\n\n### **See also**\n\n[****(3)](#)\n\n _fortran-lang intrinsic descriptions_\n",
  "EXECUTE_COMMAND_LINE": "## execute_command_line\n\n### **Name**\n\n**execute_command_line** - \\[SYSTEM:PROCESSES\\] Execute a shell command\n\n### **Synopsis**\n```fortran\n    call execute_command_line( &\n    & command [,wait] [,exitstat] [,cmdstat] [,cmdmsg] )\n```\n```fortran\n     subroutine execute_command_line(command,wait,exitstat,cmdstat,cmdmsg)\n\n      character(len=*),intent(in)             :: command\n      logical,intent(in),optional             :: wait\n      integer,intent(inout),optional          :: exitstat\n      integer,intent(inout),optional          :: cmdstat\n      character(len=*),intent(inout),optional :: cmdmsg\n```\n### **Characteristics**\n - **command** is a default _character_ scalar\n - **wait** is a default _logical_ scalar. If **wait** is present with the\n - **exitstat** is an _integer_ of the default kind.\n   It must be of a kind with at least a decimal exponent range of 9.\n - **cmdstat** is an _integer_ of default kind\n   The kind of the variable must support at least a decimal exponent range of four.\n\n - **cmdmsg** is a _character_ scalar of the default kind.\n\n### **Description**\n\n  For **execute_command_line** the **command** argument is passed\n  to the shell and executed. (The shell is generally **sh**(1) on Unix\n  systems, and cmd.exe on Windows.) If **wait** is present and has the\n  value _.false._, the execution of the command is asynchronous if the\n  system supports it; otherwise, the command is executed synchronously.\n\n  The three last arguments allow the user to get status information. After\n  synchronous execution, **exitstat** contains the integer exit code of\n  the command, as returned by **system**. **cmdstat** is set to zero if\n  the command line was executed (whatever its exit status was). **cmdmsg**\n  is assigned an error message if an error has occurred.\n\n  Note that the system call need not be thread-safe. It is the\n  responsibility of the user to ensure that the system is not called\n  concurrently if required.\n\n  When the command is executed synchronously, **execute_command_line**\n  returns after the command line has completed execution. Otherwise,\n  **execute_command_line** returns without waiting.\n\n  Because this intrinsic is making a system call, it is very system\n  dependent. Its behavior with respect to signaling is processor\n  dependent. In particular, on POSIX-compliant systems, the SIGINT and\n  SIGQUIT signals will be ignored, and the SIGCHLD will be blocked. As\n  such, if the parent process is terminated, the child process might\n  not be terminated alongside.\n\n  One of the most common causes of errors is that the program requested\n  is not in the search path. You should make sure that the program to be\n  executed is installed on your system and that it is in the system's\n  path when the program calls it. You can check if it is installed by\n  running it from the command prompt. If it runs successfully from the\n  command prompt, it means that it is installed, and so you should\n  next check that it is in the search path when the program executes\n  (usually this means checking the environment variable PATH).\n\n### **Options**\n\n- **command**\n  : the command line to be executed. The interpretation is\n  programming-environment dependent.\n\n- **wait**\n  : If **wait** is present with the\n  value _.false._, and the processor supports asynchronous execution of\n  the command, the command is executed asynchronously; otherwise it is\n  executed synchronously.\n\n  When the command is executed synchronously, **execute_command_line**\n  returns after the command line has completed execution. Otherwise,\n  **execute_command_line** returns without waiting.\n\n- **exitstat**\n  : If the command is executed synchronously, it is assigned the value\n  of the processor-dependent exit status. Otherwise, the value of\n  **exitstat** is unchanged.\n\n- **cmdstat**\n  : If an error condition occurs and **cmdstat** is not present, error\n  termination of execution of the image is initiated.\n\n  It is assigned the value **-1** if the processor does not support\n  command line execution, a processor-dependent positive value if an\n  error condition occurs, or the value **-2** if no error condition\n  occurs but **wait** is present with the value false and the processor\n  does not support asynchronous execution. Otherwise it is assigned\n  the value 0.\n\n- **cmdmsg**\n  : If an error condition occurs, it is assigned a processor-dependent\n  explanatory message. Otherwise, it is unchanged.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_exec\nimplicit none\n   integer :: i\n\n   call execute_command_line(\"external_prog.exe\", exitstat=i)\n   print *, \"Exit status of external_prog.exe was \", i\n\n   call execute_command_line(\"reindex_files.exe\", wait=.false.)\n   print *, \"Now reindexing files in the background\"\nend program demo_exec\n```\n### **Standard**\n\nFortran 2008\n\n### **See also**\n\n[**get_environment_variable**(3)](#get_environment_variable)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "EXP": "## exp\n\n### **Name**\n\n**exp** - \\[MATHEMATICS\\] Base-e exponential function\n\n### **Synopsis**\n```fortran\n    result = exp(x)\n```\n```fortran\n     elemental TYPE(kind=KIND) function exp(x)\n\n      TYPE(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **x** may be _real_ or _complex_ of any kind.\n - The return value has the same type and kind as **x**.\n\n### **Description**\n\n**exp** returns the value of _e_ (the base of natural logarithms)\nraised to the power of **x**.\n\n\"_e_\" is also known as _Euler's constant_.\n\nIf **x** is of type _complex_, its imaginary part is regarded as a value\nin radians such that if (see _Euler's formula_):\n```fortran\n    cx=(re,im)\n```\nthen\n```fortran\n    exp(cx) = exp(re) * cmplx(cos(im),sin(im),kind=kind(cx))\n```\nSince **exp** is the inverse function of **log**(3) the maximum valid magnitude\nof the _real_ component of **x** is **log(huge(x))**.\n\n### **Options**\n\n- **x**\n  : The type shall be _real_ or _complex_.\n\n### **Result**\n\nThe value of the result is **e\\*\\*x** where **e** is Euler's constant.\n\nIf **x** is of type complex, its imaginary part is\nregarded as a value in radians.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_exp\nimplicit none\nreal :: x, re, im\ncomplex :: cx\n\n   x = 1.0\n   write(*,*)\"Euler's constant is approximately\",exp(x)\n\n   !! complex values\n   ! given\n   re=3.0\n   im=4.0\n   cx=cmplx(re,im)\n\n   ! complex results from complex arguments are Related to Euler's formula\n   write(*,*)'given the complex value ',cx\n   write(*,*)'exp(x) is',exp(cx)\n   write(*,*)'is the same as',exp(re)*cmplx(cos(im),sin(im),kind=kind(cx))\n\n   ! exp(3) is the inverse function of log(3) so\n   ! the real component of the input must be less than or equal to\n   write(*,*)'maximum real component',log(huge(0.0))\n   ! or for double precision\n   write(*,*)'maximum doubleprecision component',log(huge(0.0d0))\n\n   ! but since the imaginary component is passed to the cos(3) and sin(3)\n   ! functions the imaginary component can be any real value\n\nend program demo_exp\n```\n\nResults:\n\n```text\n Euler's constant is approximately   2.718282\n given the complex value  (3.000000,4.000000)\n exp(x) is (-13.12878,-15.20078)\n is the same as (-13.12878,-15.20078)\n maximum real component   88.72284\n maximum doubleprecision component   709.782712893384\n```\n\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n- [**log**(3)](#log)\n\n### **Resources**\n\n- Wikipedia:[Exponential function](https://en.wikipedia.org/wiki/Exponential_function)\n\n- Wikipedia:[Euler's formula](https://en.wikipedia.org/wiki/Euler%27s_formula)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "EXPONENT": "## exponent\n\n### **Name**\n\n**exponent** - \\[MODEL_COMPONENTS\\] Exponent of floating-point number\n\n### **Synopsis**\n```fortran\n    result = exponent(x)\n```\n```fortran\n     elemental integer function exponent(x)\n\n      real(kind=**),intent(in) :: x\n```\n### **Characteristics**\n - **x**  shall be of type _real_ of any valid kind\n - the result is a default _integer_ type\n\n### **Description**\n\n  **exponent** returns the value of the exponent part of **x**, provided\n  the exponent is within the range of default _integers_.\n\n### **Options**\n\n- **x**\n  : the value to query the exponent of\n\n### **Result**\n\n  **exponent** returns the value of the exponent part of **x**\n\n  If **x** is zero the value returned is zero.\n\n  If **x** is an IEEE infinity or NaN, the result has the value HUGE(0).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_exponent\nimplicit none\nreal :: x = 1.0\ninteger :: i\n   i = exponent(x)\n   print *, i\n   print *, exponent(0.0)\n   print *, exponent([10.0,100.0,1000.0,-10000.0])\n   ! beware of overflow, it may occur silently\n   !print *, 2**[10.0,100.0,1000.0,-10000.0]\n   print *, exponent(huge(0.0))\n   print *, exponent(tiny(0.0))\nend program demo_exponent\n```\nResults:\n```text\n >            4           7          10          14\n >          128\n >         -125\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**fraction**(3)](#fraction),\n[**huge**(3)](#huge),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**nearest**(3)](#nearest),\n[**precision**(3)](#precision),\n[**radix**(3)](#radix),\n[**range**(3)](#range),\n[**rrspacing**(3)](#rrspacing),\n[**scale**(3)](#scale),\n[**set_exponent**(3)](#set_exponent),\n[**spacing**(3)](#spacing),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions_\n",
  "EXTENDS_TYPE_OF": "## extends_type_of\n\n### **Name**\n\n**extends_type_of** - \\[STATE:INQUIRY\\] Determine if the dynamic type\nof **a** is an extension of the dynamic type of **mold**.\n\n### **Synopsis**\n```fortran\n    result = extends_type_of(a, mold)\n```\n```fortran\n     logical extends_type_of(a, mold)\n\n      type(TYPE(kind=KIND)),intent(in) :: a\n      type(TYPE(kind=KIND)),intent(in) :: mold\n```\n### **Characteristics**\n -**a** shall be an object or pointer to an extensible declared type,\n        or unlimited polymorphic. If it is a polymorphic pointer, it\n        shall not have an undefined association status.\n -**mole** shall be an object or pointer to an extensible declared type\n           or unlimited polymorphic. If it is a polymorphic pointer,\n           it shall not have an undefined association status.\n - the result is a scalar default logical type.\n\n### **Description**\n\n  **extends_type_of** is .true. if and only if the dynamic type of\n  **a** is or could be (for unlimited polymorphic) an extension of the\n  dynamic type of **mold**.\n\n#### NOTE1\n\n  The dynamic type of a disassociated pointer or unallocated allocatable\n  variable is its declared type.\n\n#### NOTE2\n\n  The test performed by **extends_type_of** is not the same as the\n  test performed by the type guard **class is**. The test performed by\n  **extends_type_of** does not consider kind type parameters.\n\n### **options**\n- **a**\n    : be an object of extensible declared type or unlimited\n    polymorphic. If it is a polymorphic pointer, it shall not have an\n    undefined association status.\n\n- **mold**\n    : be an object of extensible declared type or unlimited\n    polymorphic. If it is a polymorphic pointer, it shall not have an\n    undefined association status.\n\n### **Result**\n\n  If **mold** is unlimited polymorphic and is either a disassociated\n  pointer or unallocated allocatable variable, the result is true.\n\n  Otherwise if **a** is unlimited polymorphic and is either a\n  disassociated pointer or unallocated allocatable variable, the result\n  is false.\n\n  Otherwise the result is true if and only if the dynamic type of **a**\n\n  if the dynamic type of A or MOLD is extensible, the result is true if\n  and only if the dynamic type of A is an extension type of the dynamic\n  type of MOLD; otherwise the result is processor dependent.\n\n\n### **Examples**\n\nSample program:\n```fortran\n  ! program demo_extends_type_of\n  module M_demo_extends_type_of\n  implicit none\n  private\n\n  type nothing\n  end type nothing\n\n  type, extends(nothing) :: dot\n    real :: x=0\n    real :: y=0\n  end type dot\n\n  type, extends(dot) :: point\n    real :: z=0\n  end type point\n\n  type something_else\n  end type something_else\n\n  public :: nothing\n  public :: dot\n  public :: point\n  public :: something_else\n\n  end module M_demo_extends_type_of\n\n  program demo_extends_type_of\n  use M_demo_extends_type_of, only : nothing, dot, point, something_else\n  implicit none\n  type(nothing) :: grandpa\n  type(dot) :: dad\n  type(point) :: me\n  type(something_else) :: alien\n\n   write(*,*)'these should all be true'\n   write(*,*)extends_type_of(me,grandpa),'I am descended from Grandpa'\n   write(*,*)extends_type_of(dad,grandpa),'Dad is descended from Grandpa'\n   write(*,*)extends_type_of(me,dad),'Dad is my ancestor'\n\n   write(*,*)'is an object an extension of itself?'\n   write(*,*)extends_type_of(grandpa,grandpa) ,'self-propagating!'\n   write(*,*)extends_type_of(dad,dad) ,'clone!'\n\n   write(*,*)' you did not father your grandfather'\n   write(*,*)extends_type_of(grandpa,dad),'no paradox here'\n\n   write(*,*)extends_type_of(dad,me),'no paradox here'\n   write(*,*)extends_type_of(grandpa,me),'no relation whatsoever'\n   write(*,*)extends_type_of(grandpa,alien),'no relation'\n   write(*,*)extends_type_of(me,alien),'not what everyone thinks'\n\n   call pointers()\n   contains\n\n   subroutine pointers()\n   ! Given the declarations and assignments\n   type t1\n   real c\n   end type\n   type, extends(t1) :: t2\n   end type\n   class(t1), pointer :: p, q\n      allocate (p)\n      allocate (t2 :: q)\n      ! the result of EXTENDS_TYPE_OF (P, Q) will be false, and the result\n      ! of EXTENDS_TYPE_OF (Q, P) will be true.\n      write(*,*)'(P,Q)',extends_type_of(p,q),\"mind your P's and Q's\"\n      write(*,*)'(Q,P)',extends_type_of(q,p)\n   end subroutine pointers\n\n  end program demo_extends_type_of\n```\nResults:\n```text\n    these should all be true\n    T I am descended from Grandpa\n    T Dad is descended from Grandpa\n    T Dad is my ancestor\n    is an object an extension of itself?\n    T self-propagating!\n    T clone!\n     you did not father your grandfather\n    F no paradox here\n    F no paradox here\n    F no relation whatsoever\n    F no relation\n    F not what everyone thinks\n    (P,Q) F mind your P's and Q's\n    (Q,P) T\n```\n### **Standard**\n\n   Fortran 2003\n\n### **See Also**\n\n[**same_type_as**(3)](#same_type_as)\n\n  _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "FINDLOC": "## findloc\n\n### **Name**\n\n**findloc** - \\[ARRAY:LOCATION\\] Location of first element of ARRAY\nidentified by MASK along dimension DIM matching a target value\n\n### **Synopsis**\n\n```fortran\n    result = findloc (array, value, dim [,mask] [,kind] [,back]) |\n             findloc (array, value [,mask] [,kind] [,back])\n```\n```fortran\n     function findloc (array, value, dim, mask, kind, back)\n\n      type(TYPE(kind=KIND)),intent(in)     :: array(..)\n      type(TYPE(kind=KIND)),intent(in)     :: value\n      integer(kind=**),intent(in),optional :: dim\n      logical(kind=**),intent(in),optional :: mask(..)\n      integer(kind=**),intent(in),optional :: kind\n      logical(kind=**),intent(in),optional :: back\n```\n### **Characteristics**\n\n- **array** is an array of any intrinsic type.\n- **value** shall be scalar but in type conformance with **array**,\n  as specified for the operator == or the operator .EQV..\n- **dim** an _integer_ corresponding to a dimension of **array**.\n  The corresponding actual argument shall not be an optional dummy\n  argument.\n- **mask** is logical and shall be conformable with **array**.\n- **kind** a scalar integer initialization expression (ie. a constant)\n- **back** a logical scalar.\n- the result is _integer_ of default kind or kind **kind** if the\n  **kind** argument is present. If **dim** does not appear, the result\n  is an array of rank one and of size equal to the rank of **array**;\n  otherwise, the result is an array of the same rank and shape as\n  **array** reduced by the dimension **dim**.\n\n**NOTE**: a kind designated as ** may be any supported kind for the type\n\n### **Description**\n\n**findloc** returns the location of the first element of **array**\nidentified by **mask** along dimension **dim** having a value equal\nto **value**.\n\nIf both **array** and **value** are of type logical, the comparison is\nperformed with the **.eqv.** operator; otherwise, the comparison is\nperformed with the == operator. If the value of the comparison is\n_.true._, that element of **array** matches **value**.\n\nIf only one element matches **value**, that element's subscripts are\nreturned. Otherwise, if more than one element matches **value** and\n**back** is absent or present with the value _.false._, the element whose\nsubscripts are returned is the first such element, taken in array\nelement order. If **back** is present with the value _.true._, the element\nwhose subscripts are returned is the last such element, taken in array\nelement order.\n\n### **Options**\n\n- **array**\n  : shall be an array of intrinsic type.\n\n- **value**\n  : shall be scalar and in type conformance with **array**.\n\n- **dim**\n  : shall be an integer scalar with a value in the range 1 <= **DIM** <=\n  n, where n is the rank of **array**. The corresponding actual argument\n  shall not be an optional dummy argument.\n\n- **mask**\n  : (optional) shall be of type logical and shall be conformable with\n  **array**.\n\n- **kind**\n  : (optional) shall be a scalar integer initialization expression.\n\n- **back**\n  : (optional) shall be a logical scalar.\n\n### **Result**\n\n**kind** is present, the kind type\nparameter is that specified by the value of **kind**; otherwise the kind\ntype parameter is that of default integer type. If **dim** does not appear,\nthe result is an array of rank one and of size equal to the rank of\n**array**; otherwise, the result is of rank n - 1 and shape\n```\n   [d1, d2, . . ., dDIM-1, dDIM+1, . . ., dn ]\n```\nwhere\n```\n   [d1, d2, . . ., dn ]\n```\nis the shape of **array**.\n\n### **Result**\n\n- **Case (i):**\n  The result of **findloc (array, value)** is a rank-one array whose\n  element values are the values of the subscripts of an element of\n  **array** whose value matches **value**. If there is such a value, the\n  ith subscript returned lies in the range 1 to ei, where ei is the\n  extent of the ith dimension of **array**. If no elements match **value**\n  or **array** has size zero, all elements of the result are zero.\n\n- **Case (ii):**\n  the result of **findloc (array, value, mask = mask)** is a\n  rank-one array whose element values are the values of the subscripts\n  of an element of **array**, corresponding to a true element of **mask**,\n  whose value matches **value**. If there is such a value, the ith\n  subscript returned lies in the range 1 to ei, where ei is the\n  extent of the ith dimension of **array**. If no elements match\n  **value**, **array** has size zero, or every element of **mask** has the\n  value false, all elements of the result are zero.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_findloc\nlogical,parameter :: T=.true., F=.false.\ninteger,allocatable :: ibox(:,:)\nlogical,allocatable :: mask(:,:)\n  ! basics\n   ! the first element matching the value is returned AS AN ARRAY\n   call printi('== 6',findloc ([2, 6, 4, 6], value = 6))\n   call printi('== 6',findloc ([2, 6, 4, 6], value = 6,back=.true.))\n   ! the first element matching the value is returned AS A SCALAR\n   call printi('== 6',findloc ([2, 6, 4, 6], value = 6,dim=1))\n   call printi('== 6',findloc ([2, 6, 4, 6], value = 6,back=.true.,dim=1))\n\n   ibox=reshape([ 0,-5,  7, 7, &\n                  3, 4, -1, 2, &\n                  1, 5,  6, 7] ,shape=[3,4],order=[2,1])\n\n   mask=reshape([ T, T, F, T, &\n                  T, T, F, T, &\n                  T, T, F, T] ,shape=[3,4],order=[2,1])\n\n   call printi('array is', ibox )\n   call printl('mask  is', mask )\n   print *, 'so for == 7 and back=.false.'\n   call printi('so for == 7 the address of the element is', &\n           & findloc (ibox, 7, mask = mask) )\n   print *, 'so for == 7 and back=.true.'\n   call printi('so for == 7 the address of the element is', &\n           & findloc (ibox, 7, mask = mask, back=.true.) )\n\n   print *,'This is independent of declared lower bounds for the array'\n\n   print *, ' using dim=N'\n   ibox=reshape([ 1,  2, -9,  &\n                  2,  2,  6 ] ,shape=[2,3],order=[2,1])\n\n   call printi('array is', ibox )\n   ! has the value [2, 1, 0] and\n   call printi('',findloc (ibox, value = 2, dim = 1) )\n   ! has the value [2, 1].\n   call printi('',findloc (ibox, value = 2, dim = 2) )\ncontains\n! GENERIC ROUTINES TO PRINT MATRICES\nsubroutine printl(title,a)\nimplicit none\n!@(#) print small 2d logical scalar, vector, matrix in row-column format\ncharacter(len=*),intent(in)  :: title\nlogical,intent(in)           :: a(..)\n\ncharacter(len=*),parameter   :: row='(\" > [ \",*(l1:,\",\"))'\ncharacter(len=*),parameter   :: all='(\" \",*(g0,1x))'\nlogical,allocatable          :: b(:,:)\ninteger                      :: i\n   write(*,all,advance='no')trim(title)\n   ! copy everything to a matrix to keep code simple\n   select rank(a)\n   rank (0); write(*,'(a)')' (a scalar)'; b=reshape([a],[1,1])\n   rank (1); write(*,'(a)')' (a vector)'; b=reshape(a,[size(a),1])\n   rank (2); write(*,'(a)')' (a matrix)'; b=a\n   rank default; stop '*printl* unexpected rank'\n   end select\n   do i=1,size(b,dim=1)\n      write(*,fmt=row,advance='no')b(i,:)\n      write(*,'(\" ]\")')\n   enddo\n   write(*,all) '>shape=',shape(a),',rank=',rank(a),',size=',size(a)\n   write(*,*)\nend subroutine printl\n\nsubroutine printi(title,a)\nimplicit none\n!@(#) print small 2d integer scalar, vector, matrix in row-column format\ncharacter(len=*),intent(in)  :: title\ninteger,intent(in)           :: a(..)\ncharacter(len=*),parameter   :: all='(\" \",*(g0,1x))'\ncharacter(len=20)            :: row\ninteger,allocatable          :: b(:,:)\ninteger                      :: i\n   write(*,all,advance='no')trim(title)\n   ! copy everything to a matrix to keep code simple\n   select rank(a)\n   rank (0); write(*,'(a)')' (a scalar)'; b=reshape([a],[1,1])\n   rank (1); write(*,'(a)')' (a vector)'; b=reshape(a,[size(a),1])\n   rank (2); write(*,'(a)')' (a matrix)'; b=a\n   rank default; stop '*printi* unexpected rank'\n   end select\n   ! find how many characters to use for integers\n   write(row,'(i0)')ceiling(log10(max(1.0,real(maxval(abs(b))))))+2\n   ! use this format to write a row\n   row='(\" > [\",*(i'//trim(row)//':,\",\"))'\n   do i=1,size(b,dim=1)\n      write(*,fmt=row,advance='no')b(i,:)\n      write(*,'(\" ]\")')\n   enddo\n   write(*,all) '>shape=',shape(a),',rank=',rank(a),',size=',size(a)\n   write(*,*)\nend subroutine printi\nend program demo_findloc\n```\nResults:\n```text\n >  == 6  (a vector)\n >  > [  2 ]\n >  >shape= 1 ,rank= 1 ,size= 1\n >\n >  == 6  (a vector)\n >  > [  4 ]\n >  >shape= 1 ,rank= 1 ,size= 1\n >\n >  == 6  (a scalar)\n >  > [  2 ]\n >  >shape= ,rank= 0 ,size= 1\n >\n >  == 6  (a scalar)\n >  > [  4 ]\n >  >shape= ,rank= 0 ,size= 1\n >\n >  array is  (a matrix)\n >  > [  0, -5,  7,  7 ]\n >  > [  3,  4, -1,  2 ]\n >  > [  1,  5,  6,  7 ]\n >  >shape= 3 4 ,rank= 2 ,size= 12\n >\n >  mask  is  (a matrix)\n >  > [ T,T,F,T ]\n >  > [ T,T,F,T ]\n >  > [ T,T,F,T ]\n >  >shape= 3 4 ,rank= 2 ,size= 12\n >\n >  so for == 7 and back=.false.\n >  so for == 7 the address of the element is  (a vector)\n >  > [  1 ]\n >  > [  4 ]\n >  >shape= 2 ,rank= 1 ,size= 2\n >\n >  so for == 7 and back=.true.\n >  so for == 7 the address of the element is  (a vector)\n >  > [  3 ]\n >  > [  4 ]\n >  >shape= 2 ,rank= 1 ,size= 2\n >\n >  This is independent of declared lower bounds for the array\n >   using dim=N\n >  array is  (a matrix)\n >  > [  1,  2, -9 ]\n >  > [  2,  2,  6 ]\n >  >shape= 2 3 ,rank= 2 ,size= 6\n >\n >    (a vector)\n >  > [  2 ]\n >  > [  1 ]\n >  > [  0 ]\n >  >shape= 3 ,rank= 1 ,size= 3\n >\n >    (a vector)\n >  > [  2 ]\n >  > [  1 ]\n >  >shape= 2 ,rank= 1 ,size= 2\n >\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n - [**maxloc**(3)](#maxloc) - Location of the maximum value within an array\n - [**minloc**(3)](#minloc) - Location of the minimum value within an array\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "FLOOR": "## floor\n\n### **Name**\n\n**floor** - \\[NUMERIC\\] Function to return largest integral value\nnot greater than argument\n\n### **Synopsis**\n```fortran\n    result = floor(a [,kind])\n```\n```fortran\n     elemental integer(kind=KIND) function floor( a ,kind )\n\n      real(kind=**),intent(in) :: a\n      integer(kind=**),intent(in),optional :: KIND\n```\n### **Characteristics**\n\n- a kind designated as ** may be any supported kind for the type\n- **a** is a _real_ of any kind\n- _KIND_ is any valid value for type _integer_.\n- the result is an _integer_ of the specified or default kind\n\n### **Description**\n\n**floor** returns the greatest integer less than or equal to **a**.\n\nIn other words, it picks the whole number at or to the left of the value on\nthe number line.\n\nThis means care has to be taken that the magnitude of the _real_ value **a**\ndoes not exceed the range of the output value, as the range of values supported\nby _real_ values is typically larger than the range for _integers_.\n\n### **Options**\n\n- **a**\n  : The value to operate on. Valid values are restricted by the size of\n  the returned _integer_ kind to the range **-huge(int(a,kind=KIND))-1**\n  to **huge(int(a),kind=KIND)**.\n\n- **kind**\n  : A scalar _integer_ constant initialization expression\n  indicating the kind parameter of the result.\n\n### **Result**\n\nThe return value is of type _integer(kind)_ if **kind** is present and of\ndefault-kind _integer_ otherwise.\n\nThe result is undefined if it cannot be represented in the specified\ninteger type.\n\nIf in range for the kind of the result the result is the whole number\nat or to the left of the input value on the number line.\n\nIf **a** is positive the result is the value with the fractional part\nremoved.\n\nIf **a** is negative, it is the whole number at or to the left of the\ninput value.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_floor\nimplicit none\nreal :: x = 63.29\nreal :: y = -63.59\n    print *, x, floor(x)\n    print *, y, floor(y)\n   ! elemental\n   print *,floor([ &\n   &  -2.7,  -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, &\n   &  0.0,   &\n   &  +0.5,  +1.0, +1.5, +2.0, +2.2, +2.5, +2.7  ])\n\n   ! note even a small deviation from the whole number changes the result\n   print *,      [2.0,2.0-epsilon(0.0),2.0-2*epsilon(0.0)]\n   print *,floor([2.0,2.0-epsilon(0.0),2.0-2*epsilon(0.0)])\n\n   ! A=Nan, Infinity or  <huge(0_KIND)-1 < A > huge(0_KIND) is undefined\nend program demo_floor\n```\nResults:\n```text\n >     63.29000             63\n >    -63.59000            -64\n >            -3         -3         -3         -2         -2         -1\n >            -1          0          0          1          1          2\n >             2          2          2\n >     2.000000      2.000000      2.000000\n >             2          1          1\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**ceiling**(3)](#ceiling),\n[**nint**(3)](#nint),\n[**aint**(3)](#aint),\n[**anint**(3)](#anint),\n[**int**(3)](#int),\n[**selected_int_kind**(3)](#selected_int_kind)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n<!--\nreal function floor(fval0)\n!@(#) return largest integer not greater than x as a real\n   fval=fval0\n   if(fval.ne.float(int(fval))) then\n      if(fval.gt.0.0) fval = int(fval)\n      if(fval.lt.0.0) fval = int(fval)-1\n   endif\n   floor=fval\nend function floor\n-->\n",
  "FRACTION": "## fraction\n\n### **Name**\n\n**fraction** - \\[MODEL_COMPONENTS\\] Fractional part of the model representation\n\n### **Synopsis**\n```fortran\n    result = fraction(x)\n```\n```fortran\n     elemental real(kind=KIND) function fraction(x)\n\n      real(kind=KIND),intent(in) :: fraction\n```\n### **Characteristics**\n\n  - **x** is of type _real_\n  - The result has the same characteristics as the argument.\n\n### **Description**\n\n  **fraction** returns the fractional part of the model representation\n  of **x**.\n\n### **Options**\n\n- **x**\n  : The value to interrogate\n\n### **Result**\n\nThe fractional part of the model representation of **x** is returned;\nit is **x \\* radix(x)\\*\\*(-exponent(x))**.\n\nIf **x** has the value zero, the result is zero.\n\nIf **x** is an IEEE NaN, the result is that NaN.\n\nIf **x** is an IEEE infinity, the result is an IEEE NaN.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_fraction\nimplicit none\nreal :: x\n   x = 178.1387e-4\n   print *, fraction(x), x * radix(x)**(-exponent(x))\nend program demo_fraction\n```\nResults:\n```text\n     0.5700439      0.5700439\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**exponent**(3)](#exponent),\n[**huge**(3)](#huge),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**nearest**(3)](#nearest),\n[**precision**(3)](#precision),\n[**radix**(3)](#radix),\n[**range**(3)](#range),\n[**rrspacing**(3)](#rrspacing),\n[**scale**(3)](#scale),\n[**set_exponent**(3)](#set_exponent),\n[**spacing**(3)](#spacing),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions_\n",
  "GAMMA": "## gamma\n\n### **Name**\n\n**gamma** - \\[MATHEMATICS\\] Gamma function, which yields factorials for positive whole numbers\n\n### **Synopsis**\n```fortran\n    result = gamma(x)\n```\n```fortran\n     elemental real(kind=**) function gamma( x)\n\n      type(real,kind=**),intent(in) :: x\n```\n### **Characteristics**\n\n - **x** is a _real_ value of any available KIND\n - returns a _real_ value with the same kind as **x**.\n\n### **Description**\n\n  **gamma(x)** computes Gamma of **x**. For positive whole number values of **n** the\n  Gamma function can be used to calculate factorials, as **(n-1)! == gamma(real(n))**.\n  That is\n```text\nn! == gamma(real(n+1))\n```\n$$\n\\\\__Gamma__(x) = \\\\int\\_0\\*\\*\\\\infty\nt\\*\\*{x-1}{\\\\mathrm{e}}\\*\\*{__-t__}\\\\,{\\\\mathrm{d}}t\n$$\n\n### **Options**\n\n- **x**\n  : Shall be of type _real_ and neither zero nor a negative integer.\n\n### **Result**\n\n  The return value is of type _real_ of the same kind as _x_. The result\n  has a value equal to a processor-dependent approximation to the gamma\n  function of **x**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_gamma\nuse, intrinsic :: iso_fortran_env, only : wp=>real64, int64\nimplicit none\nreal :: x, xa(4)\ninteger :: i, j\n\n   ! basic usage\n   x = gamma(1.0)\n   write(*,*)'gamma(1.0)=',x\n\n   ! elemental\n   xa=gamma([1.0,2.0,3.0,4.0])\n   write(*,*)xa\n   write(*,*)\n\n\n   ! gamma() is related to the factorial function\n   do i = 1, 171\n      ! check value is not too big for default integer type\n      if (factorial(i)  <=  huge(0)) then\n         write(*,*) i, nint(factorial(i)), 'integer'\n      elseif (factorial(i)  <=  huge(0_int64)) then\n         write(*,*) i, nint(factorial(i),kind=int64),'integer(kind=int64)'\n      else\n         write(*,*) i, factorial(i) , 'user factorial function'\n         write(*,*) i, product([(real(j, kind=wp), j=1, i)]), 'product'\n         write(*,*) i, gamma(real(i + 1, kind=wp)), 'gamma directly'\n      endif\n   enddo\n\n\ncontains\nfunction factorial(i) result(f)\n!  GAMMA(X) computes Gamma of X. For positive whole number values of N the\n!  Gamma function can be used to calculate factorials, as (N-1)! ==\n!  GAMMA(REAL(N)). That is\n!\n!      n! == gamma(real(n+1))\n!\ninteger, intent(in) :: i\nreal(kind=wp) :: f\n   if (i  <=  0) then\n      write(*,'(*(g0))') '<ERROR> gamma(3) function value ', i, ' <= 0'\n      stop '<STOP> bad value in gamma function'\n   endif\n   f = anint(gamma(real(i + 1,kind=wp)))\nend function factorial\n\nend program demo_gamma\n```\nResults:\n```text\n >  gamma(1.0)=   1.00000000\n >    1.00000000       1.00000000       2.00000000       6.00000000\n >\n >            1           1 integer\n >            2           2 integer\n >            3           6 integer\n >            4          24 integer\n >            5         120 integer\n >            6         720 integer\n >            7        5040 integer\n >            8       40320 integer\n >            9      362880 integer\n >           10     3628800 integer\n >           11    39916800 integer\n >           12   479001600 integer\n >           13           6227020800 integer(kind=int64)\n >           14          87178291200 integer(kind=int64)\n >           15        1307674368000 integer(kind=int64)\n >           16       20922789888000 integer(kind=int64)\n >           17      355687428096000 integer(kind=int64)\n >           18     6402373705728001 integer(kind=int64)\n >           19   121645100408832000 integer(kind=int64)\n >           20  2432902008176640000 integer(kind=int64)\n >           21   5.1090942171709440E+019 user factorial function\n >           21   5.1090942171709440E+019 product\n >           21   5.1090942171709440E+019 gamma directly\n >            :\n >            :\n >            :\n >          170   7.2574156153079990E+306 user factorial function\n >          170   7.2574156153079940E+306 product\n >          170   7.2574156153079990E+306 gamma directly\n >          171                  Infinity user factorial function\n >          171                  Infinity product\n >          171                  Infinity gamma directly\n```\n\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\nLogarithm of the Gamma function: [**log_gamma**(3)](#log_gamma)\n\n### **Resources**\n\n[Wikipedia: Gamma_function](https://en.wikipedia.org/wiki/Gamma_function)\n\n _fortran-lang intrinsic descriptions_\n",
  "GET_COMMAND": "## get_command\n\n### **Name**\n\n**get_command** - \\[SYSTEM:COMMAND LINE\\] Get the entire command line invocation\n\n### **Synopsis**\n```fortran\n    call get_command([command] [,length] [,status] [,errmsg])\n```\n```fortran\n     subroutine get_command( command ,length ,status, errmsg )\n\n      character(len=*),intent(out),optional   :: command\n      integer(kind=**),intent(out),optional   :: length\n      integer(kind=**),intent(out),optional   :: status\n      character(len=*),intent(inout),optional :: errmsg\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n   meeting the conditions described herein.\n - **command** and **errmsg** are scalar _character_ variables of default kind.\n - **length** and **status** are scalar _integer_ with a decimal exponent\n   range of at least four.\n\n### **Description**\n\n**get_command** retrieves the entire command line that was used to\ninvoke the program.\n\nNote that what is typed on the command line is often processed by\na shell. The shell typically processes special characters and white\nspace before passing it to the program. The processing can typically be\nturned off by turning off globbing or quoting the command line arguments\nand/or changing the default field separators, but this should rarely\nbe necessary.\n\n### **Result**\n\n- **command**\n  : If **command** is present, the entire command line that was used\n  to invoke the program is stored into it. If the command cannot be\n  determined, **command** is assigned all blanks.\n\n- **length**\n  : If **length** is present, it is assigned the length of the command line.\n  It is system-dependent as to whether trailing blanks will be counted.\n  : If the command length cannot be determined, a length of 0 is assigned.\n\n- **status**\n  : If **status** is present, it is assigned 0 upon success of the\n  command, **-1** if **command** is too short to store the command line,\n  or a positive value in case of an error.\n\n- **errmsg**\n  : It is assigned a processor-dependent explanatory message if the\n  command retrieval fails. Otherwise, it is unchanged.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_get_command\nimplicit none\ninteger                      :: command_line_length\ncharacter(len=:),allocatable :: command_line\n   ! get command line length\n   call get_command(length=command_line_length)\n   ! allocate string big enough to hold command line\n   allocate(character(len=command_line_length) :: command_line)\n   ! get command line as a string\n   call get_command(command=command_line)\n   ! trim leading spaces just in case\n   command_line=adjustl(command_line)\n   write(*,'(\"OUTPUT:\",a)')command_line\nend program demo_get_command\n```\nResults:\n```bash\n     # note that shell expansion removes some of the whitespace\n     # without quotes\n     ./test_get_command  arguments    on command   line to   echo\n\n     OUTPUT:./test_get_command arguments on command line to echo\n\n     # using the bash shell with single quotes\n     ./test_get_command  'arguments  *><`~[]!{}?\"\\'| '\n\n     OUTPUT:./test_get_command arguments  *><`~[]!{}?\"'|\n```\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**get_command_argument**(3)](#get_command_argument),\n[**command_argument_count**(3)](#command_argument_count)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n#\n",
  "GET_COMMAND_ARGUMENT": "## get_command_argument\n\n### **Name**\n\n**get_command_argument** - \\[SYSTEM:COMMAND LINE\\] Get command line arguments\n\n### **Synopsis**\n```fortran\n  call get_command_argument(number [,value] [,length] &\n  & [,status] [,errmsg])\n```\n```fortran\n   subroutine get_command_argument( number, value, length, &\n   & status ,errmsg)\n\n    integer(kind=**),intent(in)             :: number\n    character(len=*),intent(out),optional   :: value\n    integer(kind=**),intent(out),optional   :: length\n    integer(kind=**),intent(out),optional   :: status\n    character(len=*),intent(inout),optional :: errmsg\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n   meeting the conditions described herein.\n - **number**, **length**, and **status** are scalar _integer_\n   with a decimal exponent range of at least four.\n - **value** and **errmsg** are scalar _character_ variables of default\n   kind.\n\n### **Description**\n\n**get_command_argument** retrieves or queries the n-th argument that\nwas passed on the command line to the current program execution.\n\nThere is not anything specifically stated about what an argument is but\nin practice the arguments are strings split on whitespace unless the\narguments are quoted. IFS values (Internal Field Separators) used by\ncommon shells are typically ignored and unquoted whitespace is almost\nalways the separator.\n\nShells have often expanded command arguments and spell characters before\npassing them to the program, so the strings read are often not exactly\nwhat the user typed on the command line.\n\n### **Options**\n\n- **number**\n  : is a non-negative number indicating which argument of the current\n  program command line is to be retrieved or queried.\n  : If **number = 0**, the argument pointed to is set to the name of the\n  program (on systems that support this feature).\n  : if the processor does not have such a concept as a command name the\n  value of command argument 0 is processor dependent.\n  : For values from 1 to the number of arguments passed to the program a\n  value is returned in an order determined by the processor. Conventionally\n  they are returned consecutively as they appear on the command line from\n  left to right.\n\n### **Result**\n\n- **value**\n  : The **value** argument holds the command line argument.\n  If **value** can not hold the argument, it is truncated to fit the\n  length of **value**.\n  : If there are less than **number** arguments specified at the command\n  line or if the argument specified does not exist for other reasons,\n  **value** will be filled with blanks.\n\n- **length**\n  : The **length** argument contains the length of the n-th command\n  line argument. The length of **value** has no effect on this value,\n  It is the length required to hold all the significant characters of\n  the argument regardless of how much storage is provided by **value**.\n\n- **status**\n  : If the argument retrieval fails, **status** is a positive number;\n  if **value** contains a truncated command line argument, **status**\n  is **-1**; and otherwise the **status** is zero.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_get_command_argument\nimplicit none\ncharacter(len=255)           :: progname\ninteger                      :: count, i, argument_length, istat\ncharacter(len=:),allocatable :: arg\n\n ! command name assuming it is less than 255 characters in length\n  call get_command_argument (0, progname, status=istat)\n  if (istat == 0) then\n     print *, \"The program's name is \" // trim (progname)\n  else\n     print *, \"Could not get the program's name \" // trim (progname)\n  endif\n\n ! get number of arguments\n  count = command_argument_count()\n  write(*,*)'The number of arguments is ',count\n\n  !\n  ! allocate string array big enough to hold command line\n  ! argument strings and related information\n  !\n  do i=1,count\n     call get_command_argument(number=i,length=argument_length)\n     if(allocated(arg))deallocate(arg)\n     allocate(character(len=argument_length) :: arg)\n     call get_command_argument(i, arg,status=istat)\n     ! show the results\n     write (*,'(i3.3,1x,i0.5,1x,i0.5,1x,\"[\",a,\"]\")') &\n     & i,istat,argument_length,arg\n  enddo\n\nend program demo_get_command_argument\n```\nResults:\n```text\n./demo_get_command_argument a  test 'of getting  arguments ' \" leading\"\n```\n```text\n The program's name is ./demo_get_command_argument\n The number of arguments is            4\n001 00000 00001 [a]\n002 00000 00004 [test]\n003 00000 00022 [of getting  arguments ]\n004 00000 00008 [ leading]\n```\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**get_command**(3)](#get_command),\n[**command_argument_count**(3)](#command_argument_count)\n\n_fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n#\n",
  "GET_ENVIRONMENT_VARIABLE": "## get_environment_variable\n\n### **Name**\n\n**get_environment_variable** - \\[SYSTEM:ENVIRONMENT\\] Get value of an environment variable\n\n### **Synopsis**\n```fortran\n    call get_environment_variable(name [,value] [,length] &\n    & [,status] [,trim_name] [,errmsg] )\n```\n```fortran\n     subroutine character(len=*) get_environment_variable( &\n     & name, value, length, status, trim_name, errmsg )\n\n      character(len=*),intent(in) :: name\n      character(len=*),intent(out),optional   :: value\n      integer(kind=**),intent(out),optional   :: length\n      integer(kind=**),intent(out),optional   :: status\n      logical,intent(out),optional            :: trim_name\n      character(len=*),intent(inout),optional :: errmsg\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n   meeting the conditions described herein.\n - **name**, **value**, and **errmsg**  are a scalar _character_ of\n   default kind.\n - **length** and **status** are _integer_ scalars with a decimal exponent\n   range of at least four.\n - **trim_name** is a scalar of type _logical_ and of default kind.\n\n### **Description**\n\n**get_environment_variable** gets the **value** of the environment\nvariable **name**.\n\nNote that **get_environment_variable** need not be thread-safe. It\nis the responsibility of the user to ensure that the environment is not\nbeing updated concurrently.\n\nIf running in parallel be aware\nIt is processor dependent whether an environment variable that exists\non an image also exists on another image, and if it does exist on both\nimages whether the values are the same or different.\n\n### **Options**\n\n- **name**\n  : The name of the environment variable to query.\n  The interpretation of case is processor dependent.\n\n### **Result**\n\n- **value**\n  : The value of the environment variable being queried. If **value**\n  is not large enough to hold the data, it is truncated. If the variable\n  **name** is not set or has no value, or the processor does not support\n  environment variables **value** will be filled with blanks.\n\n- **length**\n  : Argument **length** contains the length needed for storing the\n  environment variable **name**. It is zero if the environment variable\n  is not set.\n\n- **status**\n  : **status** is **-1** if **value** is present but too short for the\n  environment variable; it is **1** if the environment variable does\n  not exist and **2** if the processor does not support environment\n  variables; in all other cases **status** is zero.\n\n- **trim_name**\n  : If **trim_name** is present with the value _.false._, the trailing\n  blanks in **name** are significant; otherwise they are not part of\n  the environment variable name.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_getenv\nimplicit none\ncharacter(len=:),allocatable :: homedir\ncharacter(len=:),allocatable :: var\n\n     var='HOME'\n     homedir=get_env(var)\n     write (*,'(a,\"=\"\"\",a,\"\"\"\")')var,homedir\n\ncontains\n\nfunction get_env(name,default) result(value)\n! a function that makes calling get_environment_variable(3) simple\nimplicit none\ncharacter(len=*),intent(in)          :: name\ncharacter(len=*),intent(in),optional :: default\ncharacter(len=:),allocatable         :: value\ninteger                              :: howbig\ninteger                              :: stat\ninteger                              :: length\n   length=0\n   value=''\n   if(name.ne.'')then\n      call get_environment_variable( name, &\n      & length=howbig,status=stat,trim_name=.true.)\n      select case (stat)\n      case (1)\n       print *, name, \" is not defined in the environment. Strange...\"\n       value=''\n      case (2)\n       print *, &\n       \"This processor does not support environment variables. Boooh!\"\n       value=''\n      case default\n       ! make string of sufficient size to hold value\n       if(allocated(value))deallocate(value)\n       allocate(character(len=max(howbig,1)) :: value)\n       ! get value\n       call get_environment_variable( &\n       & name,value,status=stat,trim_name=.true.)\n       if(stat.ne.0)value=''\n      end select\n   endif\n   if(value.eq.''.and.present(default))value=default\nend function get_env\n\nend program demo_getenv\n```\nTypical Results:\n```text\n   HOME=\"/home/urbanjs\"\n```\n### **Standard**\n\nFortran 2003\n\n### **See also**\n\n[**get_command_argument**(3)](#get_command_argument),\n[**get_command**(3)](#get_command)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n#\n",
  "HUGE": "## huge\n\n### **Name**\n\n**huge** - \\[NUMERIC MODEL\\] Largest number of a type and kind\n\n### **Synopsis**\n```fortran\n    result = huge(x)\n```\n```fortran\n     TYPE(kind=KIND) function huge(x)\n\n      TYPE(kind=KIND),intent(in) :: x(..)\n```\n### **Characteristics**\n\n - **x** may be any _real_ or _integer_ scalar or array and any kind.\n - The result will be a scalar of the same type and kind as the input **x**\n\n### **Description**\n\n  **huge** returns the largest number that is not an overflow\n  for the kind and type of **x**.\n\n### **Options**\n\n- **x**\n  : **x** is an arbitrary value which is used merely to determine what\n  _kind_ and _type_ of scalar is being queried. It need not be defined,\n  as only its characteristics are used.\n\n### **Result**\n\n  The result is the largest value supported by the specified type\n  and kind.\n\n  Note the result is as the same kind as the input to ensure the returned\n  value does not overflow. Any assignment of the result to a variable\n  should take this into consideration.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_huge\nimplicit none\ncharacter(len=*),parameter :: f='(i2,1x,2(i11,1x),f14.0:,1x,l1,1x,a)'\ninteger :: i,j,k,biggest\nreal :: v, w\ndoubleprecision :: tally\n   ! basic\n   print *, huge(0), huge(0.0), huge(0.0d0)\n   print *, tiny(0.0), tiny(0.0d0)\n\n   tally=0.0d0\n   ! note subtracting one because counter is the end value+1 on exit\n   do i=0,huge(0)-1\n      tally=tally+i\n   enddo\n   write(*,*)'tally=',tally\n\n   ! advanced\n   biggest=huge(0)\n   ! be careful of overflow when using integers in computation\n   do i=1,14\n      j=6**i   ! Danger, Danger\n      w=6**i   ! Danger, Danger\n      v=6.0**i\n      k=v      ! Danger, Danger\n\n      if(v.gt.biggest)then\n         write(*,f) i, j, k, v, v.eq.w, 'wrong j and k and w'\n      else\n         write(*,f) i, j, k, v, v.eq.w\n      endif\n\n   enddo\nend program demo_huge\n```\nResults:\n```\n  2147483647  3.4028235E+38  1.797693134862316E+308\n  1.1754944E-38  2.225073858507201E-308\n\n    1      6           6             6. T\n    2      36          36            36. T\n    3      216         216           216. T\n    4      1296        1296          1296. T\n    5      7776        7776          7776. T\n    6      46656       46656         46656. T\n    7      279936      279936        279936. T\n    8      1679616     1679616       1679616. T\n    9      10077696    10077696      10077696. T\n    10     60466176    60466176      60466176. T\n    11     362797056   362797056     362797056. T\n    12    -2118184960 -2147483648    2176782336. F wrong for j and k and w\n    13     175792128  -2147483648   13060694016. F wrong for j and k and w\n    14     1054752768 -2147483648   78364164096. F wrong for j and k and w\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**exponent**(3)](#exponent),\n[**fraction**(3)](#fraction),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**nearest**(3)](#nearest),\n[**precision**(3)](#precision),\n[**radix**(3)](#radix),\n[**range**(3)](#range),\n[**rrspacing**(3)](#rrspacing),\n[**scale**(3)](#scale),\n[**set_exponent**(3)](#set_exponent),\n[**spacing**(3)](#spacing),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "HYPOT": "## hypot\n\n### **Name**\n\n**hypot** - \\[MATHEMATICS\\] Returns the Euclidean distance - the distance between a point and the origin.\n\n### **Synopsis**\n```fortran\n    result = hypot(x, y)\n```\n```fortran\n     elemental real(kind=KIND) function hypot(x,y)\n\n      real(kind=KIND),intent(in) :: x\n      real(kind=KIND),intent(in) :: y\n```\n### **Characteristics**\n\n - **x,y** and the result shall all be _real_ and of the same **kind**.\n\n### **Description**\n\n**hypot** is referred to as the Euclidean distance function. It is\nequal to\n```fortran\nsqrt(x**2+y**2)\n```\nwithout undue underflow or overflow.\n\nIn mathematics, the _Euclidean distance_ between two points in Euclidean\nspace is the length of a line segment between two points.\n\n**hypot(x,y)** returns the distance between the point **<x,y>** and\nthe origin.\n\n### **Options**\n\n- **x**\n: The type shall be _real_.\n\n- **y**\n  : The type and kind type parameter shall be the same as **x**.\n\n### **Result**\n\nThe return value has the same type and kind type parameter as **x**.\n\nThe result is the positive magnitude of the distance of the point\n**<x,y>** from the origin **<0.0,0.0>** .\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_hypot\nuse, intrinsic :: iso_fortran_env, only : &\n & real_kinds, real32, real64, real128\nimplicit none\nreal(kind=real32) :: x, y\nreal(kind=real32),allocatable :: xs(:), ys(:)\ninteger :: i\ncharacter(len=*),parameter :: f='(a,/,SP,*(3x,g0,1x,g0:,/))'\n\n   x = 1.e0_real32\n   y = 0.5e0_real32\n\n   write(*,*)\n   write(*,'(*(g0))')'point <',x,',',y,'> is ',hypot(x,y)\n   write(*,'(*(g0))')'units away from the origin'\n   write(*,*)\n\n   ! elemental\n   xs=[  x,  x**2,  x*10.0,  x*15.0, -x**2  ]\n   ys=[  y,  y**2, -y*20.0,  y**2,   -y**2  ]\n\n   write(*,f)\"the points\",(xs(i),ys(i),i=1,size(xs))\n   write(*,f)\"have distances from the origin of \",hypot(xs,ys)\n   write(*,f)\"the closest is\",minval(hypot(xs,ys))\n\nend program demo_hypot\n```\n\nResults:\n\n```text\n   point <1.00000000,0.500000000> is 1.11803401\n   units away from the origin\n\n   the points\n      +1.00000000 +0.500000000\n      +1.00000000 +0.250000000\n      +10.0000000 -10.0000000\n      +15.0000000 +0.250000000\n      -1.00000000 -0.250000000\n   have distances from the origin of\n      +1.11803401 +1.03077638\n      +14.1421356 +15.0020828\n      +1.03077638\n   the closest is\n      +1.03077638\n```\n### **Standard**\n\nFortran 2008\n\n### **See also**\n\n[****(3)](#)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "IACHAR": "## iachar\n\n### **Name**\n\n**iachar** - \\[CHARACTER:CONVERSION\\] Return integer ASCII code of a character\n\n### **Synopsis**\n```fortran\n    result = iachar(c [,kind])\n```\n```fortran\n     elemental integer(kind=KIND) function iachar(c,kind)\n\n      character(len=1),intent(in) :: c\n      integer(kind=**),intent(in),optional :: KIND\n```\n### **Characteristics**\n\n - **c** is a single character\n - The return value is of type _integer_ and of kind **KIND**. If **KIND**\n   is absent, the return value is of default integer kind.\n\n NOTE:\n : a kind designated as ** may be any supported kind for the type\n\n### **Description**\n\n  **iachar** returns the code for the ASCII character in the first\n  character position of C.\n\n### **Options**\n\n- **c**\n  : A character to determine the ASCII code of.\n  : A common extension is to allow strings but all but the first character\n  is then ignored.\n\n- **kind**\n  : A constant initialization expression indicating the kind\n  parameter of the result.\n\n### **Result**\n\n  the result is the position of the character **c** in the ASCII\n  collating sequence. It is nonnegative and less than or equal to 127.\n\n  By ASCII, it is meant that **c** is in the collating sequence defined\n  by the codes specified in ISO/IEC 646:1991 (International Reference\n  Version).\n\n  The value of the result is processor dependent if **c** is not in the\n  ASCII collating sequence.\n\n  The results are consistent with the **lge**(3), **lgt**(3), **lle**(3),\n  and **llt**(3) comparison functions. For example, if **lle(C, D)**\n  is true, **iachar(C) <= iachar (D)** is true where **C** and **D**\n  are any two characters representable by the processor.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_iachar\nimplicit none\n   ! basic usage\n    ! just does a string one character long\n    write(*,*)iachar('A')\n    ! elemental: can do an array of letters\n    write(*,*)iachar(['A','Z','a','z'])\n\n   ! convert all characters to lowercase\n    write(*,'(a)')lower('abcdefg ABCDEFG')\ncontains\n!\npure elemental function lower(str) result (string)\n! Changes a string to lowercase\ncharacter(*), intent(In)     :: str\ncharacter(len(str))          :: string\ninteger                      :: i\n   string = str\n   ! step thru each letter in the string in specified range\n   do i = 1, len(str)\n      select case (str(i:i))\n      case ('A':'Z') ! change letter to miniscule\n         string(i:i) = char(iachar(str(i:i))+32)\n      case default\n      end select\n   end do\nend function lower\n!\nend program demo_iachar\n```\nResults:\n```text\n   65\n   65          90          97         122\n   abcdefg abcdefg\n```\n### **Standard**\n\n  Fortran 95 , with KIND argument - Fortran 2003\n\n### **See Also**\n\n[**achar**(3)](#achar),\n[**char**(3)](#char),\n[**ichar**(3)](#ichar)\n\n  See [**ichar**(3)](#ichar) in particular for a discussion of converting\n  between numerical values and formatted string representations.\n\n  Functions that perform operations on character strings, return lengths\n  of arguments, and search for certain arguments:\n\n- **Elemental:**\n  [**adjustl**(3)](#adjustl), [**adjustr**(3)](#adjustr), [**index**(3)](#index),\n  [**scan**(3)](#scan), [**verify**(3)](#verify)\n\n- **Nonelemental:**\n  [**len_trim**(3)](#len_trim),\n  [**len**(3)](#len),\n  [**repeat**(3)](#repeat), [**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "IALL": "## iall\n\n### **Name**\n\n**iall** - \\[BIT:LOGICAL\\] Bitwise and of array elements\n\n### **Synopsis**\n```fortran\n    result = iall(array [,mask]) | iall(array ,dim [,mask])\n```\n```fortran\n     integer(kind=KIND) function iall(array,dim,mask)\n\n      integer(kind=KIND),intent(in)        :: array(*)\n      integer(kind=**),intent(in),optional :: dim\n      logical(kind=**),intent(in),optional :: mask(*)\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n - **array** must be an _integer_ array\n - **mask** is a _logical_ array that conforms to **array** of any\n   _logical_ kind.\n - **dim** may be of any _integer_ kind.\n - The result will by of the same type and kind as **array**.\n\n### **Description**\n\n  **iall** reduces with a bitwise _and_ the elements of **array** along\n  dimension **dim** if the corresponding element in **mask** is _.true._.\n\n### **Options**\n\n- **array**\n  : Shall be an array of type _integer_\n\n- **dim**\n  : (Optional) shall be a scalar of type _integer_ with a value in the\n  range from **1 to n**, where **n** equals the rank of **array**.\n\n- **mask**\n  : (Optional) shall be of type _logical_ and either be a scalar or an\n  array of the same shape as **array**.\n\n### **Result**\n\n  The result is of the same type as **array**.\n\n  If **dim** is absent, a scalar with the bitwise _all_ of all elements in\n  **array** is returned. Otherwise, an array of rank **n-1**, where **n**\n  equals the rank of **array**, and a shape similar to that of **array**\n  with dimension **dim** dropped is returned.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_iall\nuse, intrinsic :: iso_fortran_env, only : integer_kinds, &\n & int8, int16, int32, int64\nimplicit none\ninteger(kind=int8) :: a(2)\n\n   a(1) = int(b'00100100')\n   a(2) = int(b'01101010')\n\n   print '(b8.8)', iall(a)\n\nend program demo_iall\n```\nResults:\n```text\n > 00100000\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**iany**(3)](#iany),\n[**iparity**(3)](#iparity),\n[**iand**(3)](#iand)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "IAND": "## iand\n\n### **Name**\n\n**iand** - \\[BIT:LOGICAL\\] Bitwise logical AND\n\n### **Synopsis**\n```fortran\n    result = iand(i, j)\n```\n```fortran\n     elemental integer(kind=KIND) function iand(i,j)\n\n      integer(kind=KIND),intent(in) :: i\n      integer(kind=KIND),intent(in) :: j\n```\n### **Characteristics**\n\n- **i**, **j** and the result shall have the same _integer_ type and kind,\n  with the exception that one of **i** or **j** may be a BOZ constant.\n\n### **Description**\n\n**iand** returns the bitwise logical **and** of two values.\n\n### **Options**\n\n- **i**\n  : one of the pair of values to compare the bits of\n\n- **j**\n  : one of the pair of values to compare the bits of\n\nIf either **i** or **j** is a BOZ-literal-constant, it is first converted\nas if by the intrinsic function **int**(3)  to type _integer_ with the\nkind type parameter of the other.\n\n### **Result**\n\nThe result has the value obtained by combining **i** and **i**\nbit-by-bit according to the following table:\n```text\n    I  |  J  |  IAND (I, J)\n  ----------------------------\n    1  |  1  |    1\n    1  |  0  |    0\n    0  |  1  |    0\n    0  |  0  |    0\n```\nSo if both the bit in **i** and **j** are on the resulting bit is on\n(a one); else the resulting bit is off (a zero).\n\nThis is commonly called the \"bitwise logical AND\" of the two values.\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_iand\nimplicit none\ninteger :: a, b\n data a / z'f' /, b / z'3' /\n write (*,*) 'a=',a,' b=',b,'iand(a,b)=',iand(a, b)\n write (*,'(b32.32)') a,b,iand(a,b)\nend program demo_iand\n```\nResults:\n```text\n    a= 15  b= 3 iand(a,b)= 3\n   00000000000000000000000000001111\n   00000000000000000000000000000011\n   00000000000000000000000000000011\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**btest**(3)](#btest),\n[**ibclr**(3)](#ibclr),\n[**ibits**(3)](#ibits),\n[**ibset**(3)](#ibset),\n[**ieor**(3)](#ieor),\n[**ior**(3)](#ior),\n[**mvbits**(3)](#mvbits),\n[**not**(3)](#not)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "IANY": "## iany\n\n### **Name**\n\n**iany** - \\[BIT:LOGICAL\\] Bitwise OR of array elements\n\n### **Synopsis**\n```fortran\n    result = iany(array [,mask]) | iany(array ,dim [,mask])\n```\n```fortran\n     integer(kind=KIND) function iany(array,dim,mask)\n\n      integer(kind=KIND),intent(in)        :: array(..)\n      integer(kind=**),intent(in),optional :: dim\n      logical(kind=**),intent(in),optional :: mask(..)\n```\n### **Characteristics**\n\n - **array** is an _integer_ array\n - **dim** may be of any _integer_ kind.\n - **mask** is a _logical_ array that conforms to **array**\n - The result will by of the same type and kind\n   as **array**. It is scalar if **dim** does not appear or is 1.\n   Otherwise, it is the shape and rank of array reduced by the\n   dimension **dim**.\n\n  note a kind designated as ** may be any supported kind for the type\n\n### **Description**\n\n  **iany** reduces with bitwise **OR** (inclusive **OR**) the\n  elements of **array** along dimension **dim** if the corresponding\n  element in **mask** is _.true._.\n\n### **Options**\n\n- **array**\n  : an array of elements to selectively **OR** based on the mask.\n\n- **dim**\n  : a value in the range from **1 to n**, where **n** equals the rank\n  of **array**.\n\n- **mask**\n  : a _logical_ scalar; or an array of the same shape as **array**.\n\n### **Result**\n\n  The result is of the same type as **array**.\n\n  If **dim** is absent, a scalar with the bitwise _or_ of all elements in\n  **array** is returned. Otherwise, an array of rank **n-1**, where **n**\n  equals the rank of **array**, and a shape similar to that of **array**\n  with dimension **dim** dropped is returned.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_iany\nuse, intrinsic :: iso_fortran_env, only : integer_kinds, &\n & int8, int16, int32, int64\nimplicit none\nlogical,parameter :: T=.true., F=.false.\ninteger(kind=int8) :: a(3)\n   a(1) = int(b'00100100',int8)\n   a(2) = int(b'01101010',int8)\n   a(3) = int(b'10101010',int8)\n   write(*,*)'A='\n   print '(1x,b8.8)', a\n   print *\n   write(*,*)'IANY(A)='\n   print '(1x,b8.8)', iany(a)\n   print *\n   write(*,*)'IANY(A) with a mask'\n   print '(1x,b8.8)', iany(a,mask=[T,F,T])\n   print *\n   write(*,*)'should match '\n   print '(1x,b8.8)', iany([a(1),a(3)])\n   print *\n   write(*,*)'does it?'\n   write(*,*)iany(a,[T,F,T]) == iany([a(1),a(3)])\nend program demo_iany\n```\nResults:\n```text\n    A=\n    00100100\n    01101010\n    10101010\n\n    IANY(A)=\n    11101110\n\n    IANY(A) with a mask\n    10101110\n\n    should match\n    10101110\n\n    does it?\n    T\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**iparity**(3)](#iparity),\n[**iall**(3)](#iall),\n[**ior**(3)](#ior)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "IBCLR": "## ibclr\n\n### **Name**\n\n**ibclr** - \\[BIT:SET\\] Clear a bit\n\n### **Synopsis**\n```fortran\n    result = ibclr(i, pos)\n```\n```fortran\n     elemental integer(kind=KIND) function ibclr(i,pos)\n\n      integer(kind=KIND),intent(in) :: i\n      integer(kind=**),intent(in) :: pos\n```\n### **Characteristics**\n\n  - **i** shall be type _integer_.\n  - **pos** shall be type _integer_.\n  - The return value is of the same kind as **i**.\n\n  - a kind designated as ** may be any supported kind for the type\n\n### **Description**\n\n  **ibclr** returns the value of **i** with the bit at position **pos**\n  set to zero.\n\n### **Options**\n\n - **i**\n   : The initial value to be modified\n\n - **pos**\n   : The position of the bit to change in the input value. A value\n   of zero refers to the right-most bit. The value of **pos** must be\n   nonnegative and less than **(bit_size(i)**).\n\n### **Result**\n\nThe returned value has the same bit sequence as **i** except the\ndesignated bit is unconditionally set to **0**\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_ibclr\nuse,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64\nimplicit none\ninteger(kind=int16) :: i\n  ! basic usage\n   print *,ibclr (16, 1), ' ==> ibclr(16,1) has the value 15'\n\n   ! it is easier to see using binary representation\n   i=int(b'0000000000111111',kind=int16)\n   write(*,'(b16.16,1x,i0)') ibclr(i,3), ibclr(i,3)\n\n  ! elemental\n   print *,'an array of initial values may be given as well'\n   print *,ibclr(i=[7,4096,9], pos=2)\n   print *\n   print *,'a list of positions results in multiple returned values'\n   print *,'not multiple bits set in one value, as the routine is  '\n   print *,'a scalar function; calling it elementally essentially  '\n   print *,'calls it multiple times.                               '\n   write(*,'(b16.16)') ibclr(i=-1_int16, pos=[1,2,3,4])\n\n   ! both may be arrays if of the same size\n\nend program demo_ibclr\n```\nResults:\n```text\n >           16  ==> ibclr(16,1) has the value 15\n > 0000000000110111 55\n >  an array of initial values may be given as well\n >            3        4096           9\n >\n >  a list of positions results in multiple returned values\n >  not multiple bits set in one value, as the routine is\n >  a scalar function; calling it elementally essentially\n >  calls it multiple times.\n > 1111111111111101\n > 1111111111111011\n > 1111111111110111\n > 1111111111101111\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**btest**(3)](#btest),\n[**iand**(3)](#iand),\n[**ibits**(3)](#ibits),\n[**ibset**(3)](#ibclr),\n[**ieor**(3)](#ieor),\n[**ior**(3)](#ior),\n[**mvbits**(3)](#mvbits),\n[**not**(3)](#not)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "IBITS": "## ibits\n\n### **Name**\n\n**ibits** - \\[BIT:COPY\\] Extraction of a subset of bits\n\n### **Synopsis**\n```fortran\n    result = ibits(i, pos, len)\n```\n```fortran\n     elemental integer(kind=KIND) function ibits(i,pos,len)\n\n      integer(kind=KIND),intent(in) :: i\n      integer(kind=**),intent(in) :: pos\n      integer(kind=**),intent(in) :: len\n```\n### **Characteristics**\n\n  - a kind designated as ** may be any supported _integer_ kind\n  - **i** may be any supported _integer_ kind as well\n  - the return value will be the same kind as **i**\n\n### **Description**\n\n**ibits** extracts a field of bits from **i**, starting\nfrom bit position **pos** and extending left for a total of **len** bits.\n\nThe result is then right-justified and the remaining left-most bits in the\nresult are zeroed.\n\nThe position **pos** is calculated assuming the right-most bit is zero and\nthe positions increment to the left.\n\n### **Options**\n\n - **i**\n   : The value to extract bits from\n\n - **pos**\n   : The position of the bit to start copying at. **pos** is\n   non-negative.\n\n - **len**\n   : the number of bits to copy from **i**. It must be non-negative.\n\n**pos + len** shall be less than or equal to **bit_size(i)**.\n\n### **Result**\n\nThe return value is composed of the selected bits right-justified,\nleft-padded with zeros.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_ibits\nuse,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64\nimplicit none\ninteger(kind=int16) :: i,j\n  ! basic usage\n   print *,ibits (14, 1, 3) ! should be seven\n   print *,ibits(-1,10,3)   ! and so is this\n   ! it is easier to see using binary representation\n   i=int(b'0101010101011101',kind=int16)\n   write(*,'(b16.16,1x,i0)') ibits(i,3,3), ibits(i,3,3)\n\n  ! we can illustrate this as\n   !        #-- position 15\n   !        |              #-- position 0\n   !        |   <-- +len   |\n   !        V              V\n   !        5432109876543210\n   i =int(b'1111111111111111',kind=int16)\n   !          ^^^^\n   j=ibits(i,10,4) ! start at 10th from left and proceed\n                   ! left for a total of 4 characters\n   write(*,'(a,b16.16)')'j=',j\n  ! lets do something less ambiguous\n   i =int(b'0010011000000000',kind=int16)\n   j=ibits(i,9,5)\n   write(*,'(a,b16.16)')'j=',j\nend program demo_ibits\n```\nResults:\n```text\n > 7\n > 7\n > 0000000000000011 3\n > j=0000000000001111\n > j=0000000000010011\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**btest**(3)](#btest),\n[**iand**(3)](#iand),\n[**ibclr**(3)](#ibclr),\n[**ibset**(3)](#ibset),\n[**ieor**(3)](#ieor),\n[**ior**(3)](#ior),\n[**mvbits**(3)](#mvbits),\n[**not**(3)](#not)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "IBSET": "## ibset\n\n### **Name**\n\n**ibset** - \\[BIT:SET\\] Set a bit to one in an integer value\n\n### **Synopsis**\n```fortran\n    result = ibset(i, pos)\n```\n```fortran\n     elemental integer(kind=KIND) function ibset(i,pos)\n\n      integer(kind=KIND),intent(in) :: i\n      integer(kind=**),intent(in) :: pos\n```\n### **Characteristics**\n\n  - a kind designated as ** may be any supported kind for the type\n  - The return value is of the same kind as **i**. Otherwise,\n    any _integer_ kinds are allowed.\n\n### **Description**\n\n**ibset** returns the value of **i** with the bit at position **pos** set to one.\n\n### **Options**\n\n - **i**\n   : The initial value to be modified\n\n - **pos**\n   : The position of the bit to change in the input value. A value\n   of zero refers to the right-most bit. The value of **pos** must be\n   nonnegative and less than **(bit_size(i)**).\n\n### **Result**\n\nThe returned value has the same bit sequence as **i** except the\ndesignated bit is unconditionally set to **1**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_ibset\nuse,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64\nimplicit none\ninteger(kind=int16) :: i\n  ! basic usage\n   print *,ibset (12, 1), 'ibset(12,1) has the value 14'\n\n   ! it is easier to see using binary representation\n   i=int(b'0000000000000110',kind=int16)\n   write(*,'(b16.16,1x,i0,1x,i0)') ibset(i,12), ibset(i,12), i\n\n  ! elemental\n   print *,'an array of initial values may be given as well'\n   print *,ibset(i=[0,4096], pos=2)\n   print *\n   print *,'a list of positions results in multiple returned values'\n   print *,'not multiple bits set in one value, as the routine is  '\n   print *,'a scalar function; calling it elementally essentially  '\n   print *,'calls it multiple times.                               '\n   write(*,'(b16.16)') ibset(i=0, pos=[1,2,3,4])\n\n   ! both may be arrays if of the same size\n\nend program demo_ibset\n```\nResults:\n```text\n >           14 ibset(12,1) has the value 14\n > 0001000000000110 4102 6\n >  an array of initial values may be given as well\n >            4        4100\n >\n >  a list of positions results in multiple returned values\n >  not multiple bits set in one value, as the routine is\n >  a scalar function; calling it elementally essentially\n >  calls it multiple times.\n > 0000000000000010\n > 0000000000000100\n > 0000000000001000\n > 0000000000010000\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**ibclr**(3)](#ibclr)\n\n[**btest**(3)](#btest),\n[**iand**(3)](#iand),\n[**ibits**(3)](#ibits),\n[**ieor**(3)](#ieor),\n[**ior**(3)](#ior),\n[**mvbits**(3)](#mvbits),\n[**not**(3)](#not)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ICHAR": "## ichar\n\n### **Name**\n\n**ichar** - \\[CHARACTER:CONVERSION\\] Character-to-integer code conversion function\n\n### **Synopsis**\n```fortran\n    result = ichar(c [,kind])\n```\n```fortran\n     elemental integer(kind=KIND) function ichar(c,KIND)\n\n      character(len=1,kind=**),intent(in) :: c\n      integer,intent(in),optional :: KIND\n```\n### **Characteristics**\n\n- **c** is a scalar _character_\n- **kind** is a constant _integer_ initialization expression indicating\n  the kind parameter of the result.\n- The return value is of type _integer_ and of kind **kind**. If **kind**\n  is absent, the return value is of default _integer_ kind.\n\n### **Description**\n\n **ichar** returns the code for the character in the system's native\n character set. The correspondence between characters and their codes is\n not necessarily the same across different Fortran implementations. For\n example, a platform using EBCDIC would return different values than an\n ASCII platform.\n\n See **iachar**(3) for specifically working with the ASCII character set.\n\n### **Options**\n\n- **c**\n  : The input character to determine the code for.\n    Its value shall be that of a character capable of representation in the processor.\n\n- **kind**\n  : indicates the kind parameter of the result. If **kind** is absent,\n  the return value is of default _integer_ kind.\n\n### **Result**\n\n  The code in the system default character set for the character being\n  queried is returned.\n\n  The result is the position of **c** in the processor collating sequence\n  associated with the kind type parameter of **c**.\n\n  it is nonnegative and less than n, where n is the number of characters\n  in the collating sequence.\n\n  The kind type parameter of the result shall specify an integer kind\n  that is capable of representing n.\n\n  For any characters C and D capable of representation in the processor,\n  C <= D is true if and only if ICHAR (C) <= ICHAR (D) is true and C ==\n  D is true if and only if ICHAR (C) == ICHAR (D) is true.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_ichar\nimplicit none\n\n   write(*,*)ichar(['a','z','A','Z'])\n\nend program demo_ichar\n```\nResults:\n```text\n             97         122          65          90\n```\n### **Standard**\n\nFortran 95 , with KIND argument -Fortran 2003\n\n### **See Also**\n\n[**achar**(3)](#achar),\n[**char**(3)](#char),\n[**iachar**(3)](#iachar)\n\nFunctions that perform operations on character strings, return lengths\nof arguments, and search for certain arguments:\n\n- **Elemental:**\n  [**adjustl**(3)](#adjustl),\n  [**adjustr**(3)](#adjustr),\n  [**index**(3)](#index),\n\n[**scan**(3)](#scan),\n[**verify**(3)](#verify)\n\n- **Nonelemental:**\n  [**len_trim**(3)](#len_trim),\n  [**len**(3)](#len),\n  [**repeat**(3)](#repeat),\n  [**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "IEOR": "## ieor\n\n### **Name**\n\n**ieor** - \\[BIT:LOGICAL\\] Bitwise exclusive OR\n\n### **Synopsis**\n```fortran\n    result = ieor(i, j)\n```\n```fortran\n     elemental integer(kind=**) function ieor(i,j)\n\n      integer(kind=**),intent(in) :: i\n      integer(kind=**),intent(in) :: j\n```\n### **Characteristics**\n\n  - **i**, **j** and the result must be of the same _integer_ kind.\n  - An exception is that one of **i** and **j** may be a BOZ literal\n    constant\n\n### **Description**\n\n  **ieor** returns a bitwise exclusive-**or** of **i** and **j**.\n\n  An exclusive OR or \"exclusive disjunction\" is a logical operation that\n  is true if and only if its arguments differ. In this case a one-bit\n  and a zero-bit substitute for true and false.\n\n  This is often represented with the notation \"XOR\", for \"eXclusive OR\".\n\n  An alternate way to view the process is that the result has the value\n  obtained by combining **i** and **j** bit-by-bit according to the\n  following table:\n\n      >  I | J |IEOR (I, J)\n      >  --#---#-----------\n      >  1 | 1 |  0\n      >  1 | 0 |  1\n      >  0 | 1 |  1\n      >  0 | 0 |  0\n\n### **Options**\n\n - **i**\n   : the first of the two values to XOR\n\n - **j**\n   : the second of the two values to XOR\n\n  If either I or J is a boz-literal-constant, it is first converted\n  as if by the intrinsic function INT to type integer with the kind\n  type parameter of the other.\n\n### **Result**\n\n  If a bit is different at the same location in **i** and **j**\n  the corresponding bit in the result is **1**, otherwise it is **0**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_ieor\nuse,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64\nimplicit none\ninteger(kind=int16) :: i,j\n  ! basic usage\n   print *,ieor (16, 1), ' ==> ieor(16,1) has the value 17'\n\n   ! it is easier to see using binary representation\n   i=int(b'0000000000111111',kind=int16)\n   j=int(b'0000001111110000',kind=int16)\n   write(*,'(a,b16.16,1x,i0)')'i=     ',i, i\n   write(*,'(a,b16.16,1x,i0)')'j=     ',j, j\n   write(*,'(a,b16.16,1x,i0)')'result=',ieor(i,j), ieor(i,j)\n\n  ! elemental\n   print *,'arguments may be arrays. If both are arrays they '\n   print *,'must have the same shape.                        '\n   print *,ieor(i=[7,4096,9], j=2)\n\n   ! both may be arrays if of the same size\n\nend program demo_ieor\n```\nResults:\n```text\n >           17  ==> ieor(16,1) has the value 17\n > i=     0000000000111111 63\n > j=     0000001111110000 1008\n > result=0000001111001111 975\n >  arguments may be arrays. If both are arrays they\n >  must have the same shape.\n >            5        4098          11\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**btest**(3)](#btest),\n[**iand**(3)](#iand),\n[**ibclr**(3)](#ibclr),\n[**ibits**(3)](#ibits),\n[**ibset**(3)](#ibset),\n[**ieor**](#ieor),\n[**ior**(3)](#ior),\n[**mvbits**(3)](#mvbits),\n[**not**(3)](#not)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "IMAGE_INDEX": "## image_index\n\n### **Name**\n\n**image_index** - \\[COLLECTIVE\\] Cosubscript to image index conversion\n\n### **Synopsis**\n```fortran\n    result = image_index(coarray, sub)\n```\n```fortran\n```\n### **Characteristics**\n\n### **Description**\n\n**image_index** returns the image index belonging to a cosubscript.\n\n### **Options**\n\n- **coarray**\n  : Coarray of any type.\n\n- **sub**\n  : default integer rank-1 array of a size equal to the corank of\n  **coarray**.\n\n### **Result**\n\nScalar default integer with the value of the image index which\ncorresponds to the cosubscripts. For invalid cosubscripts the result is\nzero.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo image_index\nimplicit none\ninteger :: array[2,-1:4,8,*]\n   ! Writes  28 (or 0 if there are fewer than 28 images)\n   write (*,*) image_index(array, [2,0,3,1])\nend demo image_index\n```\n\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**this_image**(3)](#this_image),\n[**num_images**(3)](#num_images)\n\n _fortran-lang intrinsic descriptions_\n",
  "INDEX": "## index\n\n### **Name**\n\n**index** - \\[CHARACTER:SEARCH\\] Position of a substring within a string\n\n### **Synopsis**\n```fortran\nresult = index( string, substring [,back] [,kind] )\n```\n```fortran\n elemental integer(kind=KIND) function index(string,substring,back,kind)\n\n  character(len=*,kind=KIND),intent(in) :: string\n  character(len=*,kind=KIND),intent(in) :: substring\n  logical(kind=**),intent(in),optional :: back\n  integer(kind=**),intent(in),optional :: kind\n```\n### **Characteristics**\n\n- **string** is a _character_ variable of any kind\n- **substring** is a _character_ variable of the same kind as **string**\n- **back** is a _logical_ variable of any supported kind\n- **KIND** is a scalar integer constant expression.\n\n### **Description**\n\n  **index** returns the position of the start of the leftmost\n  or rightmost occurrence of string **substring** in **string**,\n  counting from one. If **substring** is not present in **string**,\n  zero is returned.\n\n### **Options**\n\n- **string**\n  : string to be searched for a match\n\n- **substring**\n  : string to attempt to locate in **string**\n\n- **back**\n  : If the **back** argument is present and true, the return value is the\n  start of the rightmost occurrence rather than the leftmost.\n\n- **kind**\n  : if **kind** is present, the kind type parameter is that specified by the value of\n    **kind**; otherwise the kind type parameter is that of default integer type.\n\n\n### **Result**\n\n  The result is the starting position of the first substring\n  **substring** found in **string**.\n\n  If the length of **substring** is longer than **string** the result\n  is zero.\n\n  If the substring is not found the result is zero.\n\n  If **back** is _.true._ the greatest starting position is returned\n  (that is, the position of the right-most match). Otherwise,\n  the smallest position starting a match (ie. the left-most match)\n  is returned.\n\n  The position returned is measured from the left with the first\n  character of **string** being position one.\n\n  Otherwise, if no match is found zero is returned.\n\n### **Examples**\n\nExample program\n```fortran\nprogram demo_index\nimplicit none\ncharacter(len=*),parameter :: str=&\n   'Search this string for this expression'\n   !1234567890123456789012345678901234567890\n   write(*,*)&\n      index(str,'this').eq.8,              &\n      ! return value is counted from the left end even if BACK=.TRUE.\n      index(str,'this',back=.true.).eq.24, &\n      ! INDEX is case-sensitive\n      index(str,'This').eq.0\nend program demo_index\n```\nExpected Results:\n\n```text\n   T T T\n```\n### **Standard**\n\nFORTRAN 77 , with KIND argument Fortran 2003\n\n### **See Also**\n\nFunctions that perform operations on character strings, return lengths\nof arguments, and search for certain arguments:\n\n- **Elemental:**\n  [**adjustl**(3)](#adjustl), [**adjustr**(3)](#adjustr), [**index**](#index),\n  [**scan**(3)](#scan), [**verify**(3)](#verify)\n\n- **Nonelemental:**\n  [**len_trim**(3)](#len_trim),\n  [**len**(3)](#len),\n  [**repeat**(3)](#repeat), [**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions_\n",
  "INT": "## int\n\n### **Name**\n\n**int** - \\[TYPE:NUMERIC\\] Truncate towards zero and convert to integer\n\n### **Synopsis**\n```fortran\n    result = int(a [,kind])\n```\n```fortran\n     elemental integer(kind=KIND) function int(a, KIND )\n\n      TYPE(kind=**),intent(in) :: a\n      integer,optional :: KIND\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n - **a** shall be of type integer, real, or complex, or a boz-literal-constant.\n - **KIND** shall be a scalar integer constant expression.\n\n### **Description**\n\n  **int** truncates towards zero and return an _integer_.\n\n### **Options**\n\n - **a**\n   : is the value to truncate towards zero\n\n - **kind**\n   : indicates the kind parameter of the result.\n   If not present the returned type is that of default integer type.\n\n### **Result**\n\nreturns an _integer_ variable applying the following rules:\n\n**Case**:\n\n1.  If **a** is of type _integer_, **int**(a) = a\n\n2.  If **a** is of type _real_ and **|a| \\< 1, int(a)** equals **0**. If **|a| \\>=\n    1**, then **int(a)** equals the integer whose magnitude does not exceed\n    **a** and whose sign is the same as the sign of **a**.\n\n3.  If **a** is of type _complex_, rule 2 is applied to the _real_ part of **a**.\n\n4.  If _a_ is a boz-literal constant, it is treated as an _integer_\n    with the _kind_ specified.\n\n    The interpretation of a bit sequence whose most significant bit is\n    **1** is processor dependent.\n\nThe result is undefined if it cannot be represented in the specified integer type.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_int\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger :: i = 42\ncomplex :: z = (-3.7, 1.0)\nreal :: x=-10.5, y=10.5\n\n   print *, int(x), int(y)\n\n   print *, int(i)\n\n   print *, int(z), int(z,8)\n   ! elemental\n   print *, int([-10.9,-10.5,-10.3,10.3,10.5,10.9])\n   ! note int(3) truncates towards zero\n\n   ! CAUTION:\n   ! a number bigger than a default integer can represent\n   ! produces an incorrect result and is not required to\n   ! be detected by the program.\n   x=real(huge(0))+1000.0\n   print *, int(x),x\n   ! using a larger kind\n   print *, int(x,kind=int64),x\n\n   print *, int(&\n   & B\"111111111111111111111111111111111111111111111111111111111111111\",&\n   & kind=int64)\n   print *, int(O\"777777777777777777777\",kind=int64)\n   print *, int(Z\"7FFFFFFFFFFFFFFF\",kind=int64)\n\n   ! elemental\n   print *\n   print *,int([ &\n   &  -2.7,  -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, &\n   &  0.0,   &\n   &  +0.5,  +1.0, +1.5, +2.0, +2.2, +2.5, +2.7  ])\n\nend program demo_int\n```\n\nResults:\n\n```text\n >          -10   10\n >           42\n >           -3  -3\n >          -10  -10  -10   10   10  10\n >  -2147483648   2.14748467E+09\n >   2147484672   2.14748467E+09\n >   9223372036854775807\n >   9223372036854775807\n >   9223372036854775807\n >\n >  -2          -2          -2          -2          -1\n >  -1           0           0           0           1\n >   1           2           2           2           2\n```\n\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n[**aint**(3)](#aint),\n[**anint**(3)](#anint),\n[**nint**(3)](#nint),\n[**selected_int_kind**(3)](#selected_int_kind),\n[**ceiling**(3)](#ceiling),\n[**floor**(3)](#floor)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "IOR": "## ior\n\n### **Name**\n\n**ior** - \\[BIT:LOGICAL\\] Bitwise logical inclusive OR\n\n### **Synopsis**\n```fortran\n    result = ior(i, j)\n```\n```fortran\n     elemental integer(kind=KIND) function ior(i,j)\n\n      integer(kind=KIND ,intent(in) :: i\n      integer(kind=KIND ,intent(in) :: j\n```\n### **Characteristics**\n\n- **i**, **j** and the result shall have the same _integer_ type and kind,\n  with the exception that one of **i** or **j** may be a BOZ constant.\n\n### **Description**\n\n**ior** returns the bit-wise Boolean inclusive-or of **i** and **j**.\n\n### **Options**\n\n- **i**\n  : one of the pair of values to compare the bits of\n\n- **j**\n  : one of the pair of values to compare the bits of\n\nIf either **i** or **j** is a BOZ-literal-constant, it is first converted\nas if by the intrinsic function **int**(3)  to type _integer_ with the\nkind type parameter of the other.\n\n### **Result**\n\n The result has the value obtained by combining I and J\n bit-by-bit according to the following table:\n```text\n          I   J   IOR (I, J)\n          1   1        1\n          1   0        1\n          0   1        1\n          0   0        0\n```\n Where if the bit is set in either input value, it is set in the\n result. Otherwise the result bit is zero.\n\n This is commonly called the \"bitwise logical inclusive OR\" of the two values.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_ior\nimplicit none\ninteger :: i, j, k\n   i=53       ! i=00110101 binary (lowest order byte)\n   j=45       ! j=00101101 binary (lowest order byte)\n   k=ior(i,j) ! k=00111101 binary (lowest order byte), k=61 decimal\n   write(*,'(i8,1x,b8.8)')i,i,j,j,k,k\nend program demo_ior\n```\nResults:\n```\n         53 00110101\n         45 00101101\n         61 00111101\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**btest**(3)](#btest),\n[**iand**(3)](#iand),\n[**ibclr**(3)](#ibclr),\n[**ibits**(3)](#ibits),\n[**ibset**(3)](#ibset),\n[**ieor**(3)](#ieor),\n[**mvbits**(3)](#mvbits),\n[**not**(3)](#not)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "IPARITY": "## iparity\n\n### **Name**\n\n**iparity** - \\[BIT:LOGICAL\\] Bitwise exclusive OR of array elements\n\n### **Synopsis**\n```fortran\n    result = iparity( array [,mask] ) | iparity( array, dim [,mask] )\n```\n```fortran\n     integer(kind=KIND) function iparity(array, dim, mask )\n\n      integer(kind=KIND),intent(in) :: array(..)\n      logical(kind=**),intent(in),optional :: dim\n      logical(kind=**),intent(in),optional :: mask(..)\n```\n - **array** - An _integer_ array.\n - **dim** - an _integer_ scalar from 1 to the rank of **array**\n - **mask** - _logical_ conformable with **array**.\n\n### **Description**\n\n**iparity** reduces with bitwise _xor_ (exclusive _or_) the elements\nof **array** along dimension **dim** if the corresponding element in\n**mask** is _.true._.\n\n### **Options**\n\n- **array**\n  : an array of _integer_ values\n\n- **dim** a value from 1 to the rank of **array**.\n\n- **mask**\n  : a _logical_ mask either a scalar or an array of the same shape\n  as **array**.\n\n### **Result**\n\nThe result is of the same type as **array**.\n\nIf **dim** is absent, a scalar with the bitwise _xor_ of all elements in **array**\nis returned. Otherwise, an array of rank **n-1**, where **n** equals the\nrank of **array**, and a shape similar to that of **array** with dimension **dim**\ndropped is returned.\n\n  Case (i):    The result of IPARITY (ARRAY) has a value equal to the\n               bitwise exclusive OR of all the elements of ARRAY. If\n               ARRAY has size zero the result has the value zero.\n\n  Case (ii):   The result of IPARITY (ARRAY, MASK=MASK) has a value\n               equal to that of\n```fortran\n               IPARITY (PACK (ARRAY, MASK)).\n```\n  Case (iii):  The result of IPARITY (ARRAY, DIM=DIM [, MASK=MASK])\n               has a value equal to that of IPARITY (ARRAY [, MASK=MASK])\n               if ARRAY has rank one.\n\n               Otherwise, an array of values reduced along the dimension\n               **dim** is returned.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_iparity\nimplicit none\ninteger, dimension(2) :: a\n  a(1) = int(b'00100100')\n  a(2) = int(b'01101010')\n  print '(b8.8)', iparity(a)\nend program demo_iparity\n```\nResults:\n```\n   01001110\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**iany**(3)](#iany),\n[**iall**(3)](#iall),\n[**ieor**(3)](#ieor),\n[**parity**(3)](#parity)\n\n _fortran-lang intrinsic descriptions_\n",
  "ISHFT": "## ishft\n\n### **Name**\n\n**ishft** - \\[BIT:SHIFT\\] Logical shift of bits in an integer\n\n### **Synopsis**\n```fortran\n    result = ishftc( i, shift )\n```\n```fortran\n     elemental integer(kind=KIND) function ishft(i, shift )\n\n      integer(kind=KIND),intent(in) :: i\n      integer(kind=**),intent(in) :: shift\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n - **i** is an _integer_ of any kind. the kind for **i** dictates the kind of the returned value.\n - **shift** is an _integer_ of any kind.\n\n### **Description**\n\n  **ishft** returns a value corresponding to **i** with all of the\n  bits shifted **shift** places left or right as specified by the sign\n  and magnitude of **shift**.\n\n  Bits shifted out from the left end or right end are lost; zeros are\n  shifted in from the opposite end.\n\n### **Options**\n\n- **i**\n  : The value specifying the pattern of bits to shift\n\n- **shift**\n  : A value of **shift** greater than zero corresponds to a left shift,\n  a value of zero corresponds to no shift, and a value less than zero\n  corresponds to a right shift.\n\n  If the absolute value of **shift** is\n  greater than **bit_size(i)**, the value is undefined.\n\n\n### **Result**\n\n  The result has the value obtained by shifting the bits of **i** by **shift** positions.\n\n  1. If **shift** is positive, the shift is to the left\n  2. if **shift** is negative, the shift is to the right\n  3.  if **shift** is zero, no shift is performed.\n\n  Bits shifted out from the left or from the right, as appropriate,\n  are lost. Zeros are shifted in from the opposite end.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_ishft\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger             :: shift\ncharacter(len=*),parameter :: g='(b32.32,1x,i0)'\n\n   write(*,*) ishft(3, 1),' <== typically should have the value 6'\n\n   shift=4\n   write(*,g) ishft(huge(0),shift), shift\n   shift=0\n   write(*,g) ishft(huge(0),shift), shift\n   shift=-4\n   write(*,g) ishft(huge(0),shift), shift\nend program demo_ishft\n```\nResults:\n```text\n>              6  <== typically should have the value 6\n>   11111111111111111111111111110000 4\n>   01111111111111111111111111111111 0\n>   00000111111111111111111111111111 -4\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**ishftc**(3)](#ishftc)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "ISHFTC": "## ishftc\n\n### **Name**\n\n**ishftc** - \\[BIT:SHIFT\\] Shift rightmost bits circularly, AKA. a logical shift\n\n### **Synopsis**\n```fortran\n    result = ishftc( i, shift [,size] )\n```\n```fortran\n     elemental integer(kind=KIND) function ishftc(i, shift, size)\n\n      integer(kind=KIND),intent(in)        :: i\n      integer(kind=**),intent(in)          :: shift\n      integer(kind=**),intent(in),optional :: size\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n - **i** may be an _integer_ of any kind\n - **shift** and **size** may be _integers_ of any kind\n - the kind for **i** dictates the kind of the returned value.\n\n### **Description**\n\n  **ishftc** circularly shifts just the specified rightmost bits of\n  an integer.\n\n  **ishftc** returns a value corresponding to **i** with the rightmost\n  **size** bits shifted circularly **shift** places; that is, bits\n  shifted out one end of the section are shifted into the opposite end\n  of the section.\n\n  A value of **shift** greater than zero corresponds to a left shift,\n  a value of zero corresponds to no shift, and a value less than zero\n  corresponds to a right shift.\n\n### **Options**\n\n- **i**\n  : The value specifying the pattern of bits to shift\n\n- **shift**\n  : If **shift** is positive, the shift is to the left; if **shift**\n    is negative, the shift is to the right; and if **shift** is zero,\n    no shift is performed.\n\n    The absolute value of **shift** must be less than **size** (simply\n    put, the number of positions to shift must be less than or equal to\n    the number of bits specified to be shifted).\n\n- **size**\n  : The value must be greater than zero and less than or equal to\n    **bit_size**(i).\n\n    The default if **bit_size(i)** is absent is to circularly shift the\n    entire value **i**.\n\n### **Result**\n\n  The result characteristics (kind, shape, size, rank, ...) are the\n  same as **i**.\n\n  The result has the value obtained by shifting the **size** rightmost\n  bits of **i** circularly by **shift** positions.\n\n  No bits are lost.\n\n  The unshifted bits are unaltered.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_ishftc\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger             :: i\ncharacter(len=*),parameter :: g='(b32.32,1x,i0)'\n  ! basics\n   write(*,*) ishftc(3, 1),' <== typically should have the value 6'\n\n   print *, 'lets start with this:'\n   write(*,'(b32.32)')huge(0)\n   print *, 'shift the value by various amounts, negative and positive'\n   do i= -bit_size(0), bit_size(0), 8\n      write(*,g) ishftc(huge(0),i), i\n   enddo\n  print *,'elemental'\n  i=huge(0)\n  write(*,*)ishftc(i,[2,3,4,5])\n  write(*,*)ishftc([2**1,2**3,-2**7],3)\n  print *,'note the arrays have to conform when elemental'\n  write(*,*)ishftc([2**1,2**3,-2**7],[5,20,0])\n\nend program demo_ishftc\n```\nResults:\n```text\n >            6  <== typically should have the value 6\n >  lets start with this:\n > 01111111111111111111111111111111\n >  shift the value by various amounts, negative and positive\n > 01111111111111111111111111111111 -32\n > 11111111111111111111111101111111 -24\n > 11111111111111110111111111111111 -16\n > 11111111011111111111111111111111 -8\n > 01111111111111111111111111111111 0\n > 11111111111111111111111101111111 8\n > 11111111111111110111111111111111 16\n > 11111111011111111111111111111111 24\n > 01111111111111111111111111111111 32\n >  elemental\n >           -3          -5          -9         -17\n >           16          64       -1017\n >  note the arrays have to conform when elemental\n >           64     8388608        -128\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n- [**ishft**(3)](#ishft)   - Logical shift of bits in an integer\n- [**shifta**(3)](#shifta) - Right shift with fill\n- [**shiftl**(3)](#shiftl) - Shift bits left\n- [**shiftr**(3)](#shiftr) - Combined right shift of the bits of two int...\n- [**dshiftl**(3)](#dshiftl) - Combined left shift of the bits of two inte...\n- [**dshiftr**(3)](#dshiftr) - Combined right shift of the bits of two int...\n- [**cshift**(3)](#cshift)   - Circular shift elements of an array\n- [**eoshift**(3)](#eoshift) - End-off shift elements of an array\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "IS_CONTIGUOUS": "## is_contiguous\n\n### **Name**\n\n**is_contiguous** - \\[ARRAY:INQUIRY\\] Test if object is contiguous\n\n### **Synopsis**\n```fortran\n    result = is_contiguous(array)\n```\n```fortran\n     logical function is_contiguous(array)\n\n      type(TYPE(kind=**)),intent(in) :: array\n```\n### **Characteristics**\n\n- a kind designated as ** may be any supported kind for the type\n- **array** may be of any type. It shall be an array or assumed-rank. If it is a pointer it\n  shall be associated.\n- the result is a default logical scalar\n\n### **Description**\n\n**is_contiguous** returns _.true._ if and only if an object is\ncontiguous.\n\nAn object is contiguous if it is\n\n- **(1)**\n  an object with the CONTIGUOUS attribute,\n\n- **(2)**\n  a nonpointer whole array that is not assumed-shape,\n\n- **(3)**\n  an assumed-shape array that is argument associated with an array\n  that is contiguous,\n\n- **(4)**\n  an array allocated by an ALLOCATE statement,\n\n- **(5)**\n  a pointer associated with a contiguous target, or\n\n- **(6)**\n  a nonzero-sized array section provided that\n\n  - **(a)**\n    its base object is contiguous,\n\n  - **(b)**\n    it does not have a vector subscript,\n\n  - **(c)**\n    the elements of the section, in array element order, are a\n    subset of the base object elements that are consecutive in\n    array element order,\n\n  - **(d)**\n    if the array is of type character and a substring-range\n    appears, the substring-range specifies all of the characters\n    of the parent-string,\n\n  - **(e)**\n    only its final part-ref has nonzero rank, and\n\n  - **(f)**\n    it is not the real or imaginary part of an array of type\n    complex.\n\nAn object is not contiguous if it is an array subobject, and\n\n- the object has two or more elements,\n\n- the elements of the object in array element order are not\n  consecutive in the elements of the base object,\n\n- the object is not of type character with length zero, and\n\n- the object is not of a derived type that has no ultimate\n  components other than zero-sized arrays and\n\n- characters with length zero.\n\nIt is processor-dependent whether any other object is contiguous.\n\n### **Options**\n\n- **array**\n  : An array of any type to be tested for being contiguous. If it is a\n  pointer it shall be associated.\n\n### **Result**\n\n  The result has the value _.true._ if **array** is contiguous, and _.false._\n  otherwise.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_is_contiguous\nimplicit none\nintrinsic is_contiguous\nreal, DIMENSION (1000, 1000), TARGET :: A\nreal, DIMENSION (:, :), POINTER       :: IN, OUT\n   IN => A              ! Associate IN with target A\n   OUT => A(1:1000:2,:) ! Associate OUT with subset of target A\n   !\n   write(*,*)'IN is ',IS_CONTIGUOUS(IN)\n   write(*,*)'OUT is ',IS_CONTIGUOUS(OUT)\n   !\nend program demo_is_contiguous\n```\nResults:\n\n```text\n    IN is  T\n    OUT is  F\n```\n### **Standard**\n\nFortran 2008\n\n### **See also**\n\n[****(3)](#)\n\n _fortran-lang intrinsic descriptions_\n",
  "IS_IOSTAT_END": "## is_iostat_end\n\n### **Name**\n\n**is_iostat_end** - \\[STATE:INQUIRY\\] Test for end-of-file value\n\n### **Synopsis**\n```fortran\n    result = is_iostat_end(i)\n```\n```fortran\n     elemental logical function is_iostat_end(i)\n\n      integer,intent(in) :: i\n```\n### **Characteristics**\n\n - **i** is _integer_ of any kind\n - the return value is a default _logical_\n\n### **Description**\n\n**is_iostat_end** tests whether a variable (assumed returned as a status\nfrom an I/O statement) has the \"end of file\" I/O status value.\n\nThe function is equivalent to comparing the variable with the\n**iostat_end** parameter of the intrinsic module **iso_fortran_env**.\n\n### **Options**\n\n- **i**\n  : An _integer_ status value to test if indicating end of file.\n\n### **Result**\n\nreturns  _.true._ if and only if**i** has the value\nwhich indicates an end of file condition for **iostat=** specifiers, and is\n_.false._ otherwise.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_iostat\nimplicit none\nreal               :: value\ninteger            :: ios\ncharacter(len=256) :: message\n   write(*,*)'Begin entering numeric values, one per line'\n   do\n      read(*,*,iostat=ios,iomsg=message)value\n      if(ios.eq.0)then\n         write(*,*)'VALUE=',value\n      elseif( is_iostat_end(ios) ) then\n         stop 'end of file. Goodbye!'\n      else\n         write(*,*)'ERROR:',ios,trim(message)\n         exit\n      endif\n      !\n   enddo\nend program demo_iostat\n```\n### **Standard**\n\nFortran 2003\n\n### **See also**\n\n[****(3)](#)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "IS_IOSTAT_EOR": "## is_iostat_eor\n\n### **Name**\n\n**is_iostat_eor** - \\[STATE:INQUIRY\\] Test for end-of-record value\n\n### **Synopsis**\n```fortran\n    result = is_iostat_eor(i)\n```\n```fortran\n     elemental integer function is_iostat_eor(i)\n\n      integer(kind=KIND),intent(in) :: i\n```\n### **Characteristics**\n\n - **i** is _integer_ of any kind\n - the return value is a default _logical_\n\n### **Description**\n\n  **is_iostat_eor** tests whether a variable has the value of the\n  I/O status \"end of record\". The function is equivalent to comparing\n  the variable with the **iostat_eor** parameter of the intrinsic module\n  **iso_fortran_env**.\n\n### **Options**\n\n- **i**\n  : The value to test as indicating \"end of record\".\n\n### **Result**\n\n  Returns _.true._ if and only if **i** has the value which indicates\n  an end-of-record condition for iostat= specifiers, and is _.false._\n  otherwise.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_is_iostat_eor\nuse iso_fortran_env, only : iostat_eor\nimplicit none\ninteger :: inums(5), lun, ios\n\n  ! create a test file to read from\n   open(newunit=lun, form='formatted',status='scratch')\n   write(lun, '(a)') '10 20 30'\n   write(lun, '(a)') '40 50 60 70'\n   write(lun, '(a)') '80 90'\n   write(lun, '(a)') '100'\n   rewind(lun)\n\n   do\n      read(lun, *, iostat=ios) inums\n      write(*,*)'iostat=',ios\n      if(is_iostat_eor(ios)) then\n         stop 'end of record'\n      elseif(is_iostat_end(ios)) then\n         print *,'end of file'\n         exit\n      elseif(ios.ne.0)then\n         print *,'I/O error',ios\n         exit\n      endif\n   enddo\n\n   close(lun,iostat=ios,status='delete')\n\nend program demo_is_iostat_eor\n```\nResults:\n```text\n >  iostat=           0\n >  iostat=          -1\n >  end of file\n```\n### **Standard**\n\nFortran 2003\n\n### **See also**\n\n[****(3)](#)\n\n _fortran-lang intrinsic descriptions_\n",
  "KIND": "## kind\n\n### **Name**\n\n**kind** - \\[KIND:INQUIRY\\] Query kind of an entity\n\n### **Synopsis**\n```fortran\n    result = kind(x)\n```\n```fortran\n     integer function kind(x)\n\n      type(TYPE(kind=**)),intent(in) :: x(..)\n```\n### **Characteristics**\n - **x** may be of any intrinsic type. It may be a scalar or an array.\n - the result is a default _integer_ scalar\n\n### **Description**\n\n   **kind(x)**(3) returns the kind value of the entity **x**.\n\n### **Options**\n\n- **x**\n  : Value to query the kind of.\n\n### **Result**\n\n  The return value indicates the kind of the argument **x**.\n\n  Note that kinds are processor-dependent.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_kind\nimplicit none\ninteger,parameter :: dc = kind(' ')\ninteger,parameter :: dl = kind(.true.)\n\n   print *, \"The default character kind is \", dc\n   print *, \"The default logical kind is \", dl\n\nend program demo_kind\n```\nResults:\n```text\n    The default character kind is            1\n    The default logical kind is            4\n```\n### **Standard**\n\nFortran 95\n\n### **See also**\n\n- [**allocated**(3)](#allocated) -  Status of an allocatable entity\n- [**is_contiguous**(3)](#is_contiguous) -  test if object is contiguous\n- [**lbound**(3)](#lbound)    -  Lower dimension bounds of an array\n- [**rank**(3)](#rank)      -  Rank of a data object\n- [**shape**(3)](#shape)     -  Determine the shape of an array\n- [**size**(3)](#size)      -  Determine the size of an array\n- [**ubound**(3)](#ubound)    -  Upper dimension bounds of an array\n- [**bit_size**(3)](#bit_size)  -  Bit size inquiry function\n- [**storage_size**(3)](#storage_size) -  Storage size in bits\n- [**kind**](#kind)      -  Kind of an entity\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "LBOUND": "## lbound\n\n### **Name**\n\n**lbound** - \\[ARRAY:INQUIRY\\] Lower dimension bounds of an array\n\n### **Synopsis**\n```fortran\n    result = lbound(array [,dim] [,kind] )\n```\n```fortran\n     elemental TYPE(kind=KIND) function lbound(array,dim,kind)\n\n      TYPE(kind=KIND),intent(in)           :: array(..)\n      integer(kind=**),intent(in),optional :: dim\n      integer(kind=**),intent(in),optional :: kind\n```\n### **Characteristics**\n\n- **array** shall be assumed-rank or an array, of any type.\n  It cannot be an unallocated allocatable array or a pointer that is not associated.\n\n- **dim** shall be a scalar _integer_.\n  The corresponding actual argument shall not be an optional dummy\n  argument, a disassociated pointer, or an unallocated allocatable.\n\n- **kind** an _integer_ initialization expression indicating the kind\n  parameter of the result.\n\n- The return value is of type _integer_ and of kind **kind**. If **kind**\n  is absent, the return value is of default integer kind.\n  The result is scalar if **dim** is present; otherwise, the result is\n  an array of rank one and size n, where n is the rank of **array**.\n\n- a kind designated as ** may be any supported kind for the type\n\n### **Description**\n\n  **lbound** returns the lower bounds of an array, or a single lower\n  bound along the **dim** dimension.\n\n### **Options**\n\n- **array**\n  : Shall be an array, of any type.\n\n- **dim**\n  : Shall be a scalar _integer_.\n  If **dim** is absent, the result is an array of the upper bounds of\n  **array**.\n\n- **kind**\n  : An _integer_ initialization expression indicating the kind\n  parameter of the result.\n\n### **Result**\n\nIf **dim** is absent,\nthe result is an array of the lower bounds of **array**.\n\nIf **dim** is present, \nthe result is a scalar corresponding to the lower bound of the\narray along that dimension. If **array** is an expression rather than\na whole array or array structure component, or if it has a zero extent\nalong the relevant dimension, the lower bound is taken to be 1.\n\n    NOTE1\n\n    If **array** is assumed-rank and has rank zero, **dim** cannot be\n    present since it cannot satisfy the requirement **1 <= dim <= 0**.\n\n### **Examples**\n\nNote that in my opinion this function should not be used on assumed-size\narrays or in any function without an explicit interface. Errors can\noccur if there is no interface defined.\n\nSample program\n```fortran\n! program demo_lbound\nmodule m_bounds\nimplicit none\n contains\n    subroutine msub(arr)\n       !!integer,intent(in) :: arr(*)  ! cannot be assumed-size array\n       integer,intent(in) :: arr(:)\n       write(*,*)'MSUB: LOWER=',lbound(arr), &\n       & 'UPPER=',ubound(arr), &\n       & 'SIZE=',size(arr)\n    end subroutine msub\n end module m_bounds\n\n program demo_lbound\n use m_bounds, only : msub\n implicit none\n interface\n    subroutine esub(arr)\n    integer,intent(in) :: arr(:)\n    end subroutine esub\n end interface\n integer :: arr(-10:10)\n    write(*,*)'MAIN: LOWER=',lbound(arr), &\n    & 'UPPER=',ubound(arr), &\n    & 'SIZE=',size(arr)\n    call csub()\n    call msub(arr)\n    call esub(arr)\n contains\nsubroutine csub\n   write(*,*)'CSUB: LOWER=',lbound(arr), &\n   & 'UPPER=',ubound(arr), &\n   & 'SIZE=',size(arr)\nend subroutine csub\nend\n\n subroutine esub(arr)\n implicit none\n integer,intent(in) :: arr(:)\n    ! WARNING: IF CALLED WITHOUT AN EXPLICIT INTERFACE\n    ! THIS WILL GIVE UNDEFINED ANSWERS (like 0,0,0)\n    write(*,*)'ESUB: LOWER=',lbound(arr), &\n    & 'UPPER=',ubound(arr), &\n    & 'SIZE=',size(arr)\n end subroutine esub\n\n!end program demo_lbound\n```\nResults:\n```\n   MAIN: LOWER=         -10 UPPER=          10 SIZE=          21\n   CSUB: LOWER=         -10 UPPER=          10 SIZE=          21\n   MSUB: LOWER=           1 UPPER=          21 SIZE=          21\n   ESUB: LOWER=           1 UPPER=          21 SIZE=          21\n```\n### **Standard**\n\nFortran 95 , with KIND argument - Fortran 2003\n\n### **See Also**\n\n#### Array inquiry:\n\n- [**size**(3)](#size) -  Determine the size of an array\n- [**rank**(3)](#rank) -  Rank of a data object\n- [**shape**(3)](#shape) -  Determine the shape of an array\n- [**ubound**(3)](#ubound) -  Upper dimension bounds of an array\n\n[**co\\_ubound**(3)](#ucobound),\n[**co\\_lbound**(3)](lcobound)\n\n#### State Inquiry:\n\n- [**allocated**(3)](#allocated) -  Status of an allocatable entity\n- [**is_contiguous**(3)](#is_contiguous) -  Test if object is contiguous\n\n#### Kind Inquiry:\n\n- [**kind**(3)](#kind) - Kind of an entity\n\n#### Bit Inquiry:\n\n- [**storage_size**(3)](#storage_size) - Storage size in bits\n- [**bit_size**(3)](#bit_size) -  Bit size inquiry function\n- [**btest**(3)](#btest) - Tests a bit of an _integer_ value.\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "LCOBOUND": "## lcobound\n\n### **Name**\n\n**lcobound** - \\[COLLECTIVE\\] Lower codimension bounds of an array\n\n### **Synopsis**\n```fortran\n     result = lcobound( coarray [,dim] [,kind] )\n```\n```fortran\n```\n### **Characteristics**\n\n### **Description**\n\n**lcobound** returns the lower bounds of a coarray, or a single\nlower cobound along the **dim** codimension.\n\n### **Options**\n\n- **array**\n  : Shall be an coarray, of any type.\n\n- **dim**\n  : (Optional) Shall be a scalar _integer_.\n\n- **kind**\n  : (Optional) An _integer_ initialization expression indicating the kind\n  parameter of the result.\n\n### **Result**\n\nThe return value is of type _integer_ and of kind **kind**. If **kind** is absent,\nthe return value is of default integer kind. If **dim** is absent, the\nresult is an array of the lower cobounds of **coarray**. If **dim** is present,\nthe result is a scalar corresponding to the lower cobound of the array\nalong that codimension.\n\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**ucobound**(3)](#ucobound),\n[**lbound**(3)](#lbound)\n\n _fortran-lang intrinsic descriptions_\n",
  "LEADZ": "## leadz\n\n### **Name**\n\n**leadz** - \\[BIT:COUNT\\] Number of leading zero bits of an integer\n\n### **Synopsis**\n```fortran\n    result = leadz(i)\n```\n```fortran\n     elemental integer function leadz(i)\n\n      integer(kind=**),intent(in) :: i\n```\n### **Characteristics**\n\n- **i** may be an _integer_ of any kind.\n- the return value is a default integer type.\n\n### **Description**\n\n  **leadz** returns the number of leading zero bits of an integer.\n\n### **Options**\n\n- **i**\n  : _integer_ to count the leading zero bits of.\n\n### **Result**\n\n  The number of leading zero bits, taking into account the kind of the\n  input value. If all the bits of **i** are zero, the result value is\n  **bit_size(i)**.\n\n  The result  may also be thought of as **bit_size(i)-1-k** where **k**\n  is the position of the leftmost 1 bit in the input **i**. Positions\n  are from 0 to bit-size(), with 0 at the right-most bit.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_leadz\nimplicit none\ninteger :: value, i\ncharacter(len=80) :: f\n\n  ! make a format statement for writing a value as a bit string\n  write(f,'(\"(b\",i0,\".\",i0,\")\")')bit_size(value),bit_size(value)\n\n  ! show output for various integer values\n  value=0\n  do i=-150, 150, 50\n     value=i\n     write (*,'(\"LEADING ZERO BITS=\",i3)',advance='no') leadz(value)\n     write (*,'(\" OF VALUE \")',advance='no')\n     write(*,f,advance='no') value\n     write(*,'(*(1x,g0))') \"AKA\",value\n  enddo\n  ! Notes:\n  ! for two's-complements programming environments a negative non-zero\n  ! integer value will always start with a 1 and a positive value with 0\n  ! as the first bit is the sign bit. Such platforms are very common.\nend program demo_leadz\n```\nResults:\n```text\n  LEADING ZERO BITS=  0 OF VALUE 11111111111111111111111101101010 AKA -150\n  LEADING ZERO BITS=  0 OF VALUE 11111111111111111111111110011100 AKA -100\n  LEADING ZERO BITS=  0 OF VALUE 11111111111111111111111111001110 AKA -50\n  LEADING ZERO BITS= 32 OF VALUE 00000000000000000000000000000000 AKA 0\n  LEADING ZERO BITS= 26 OF VALUE 00000000000000000000000000110010 AKA 50\n  LEADING ZERO BITS= 25 OF VALUE 00000000000000000000000001100100 AKA 100\n  LEADING ZERO BITS= 24 OF VALUE 00000000000000000000000010010110 AKA 150\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**bit_size**(3)](#bit_size),\n[**popcnt**(3)](#popcnt),\n[**poppar**(3)](#poppar),\n[**trailz**(3)](#trailz)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "LEN": "## len\n\n### **Name**\n\n**len** - \\[CHARACTER\\] Length of a character entity\n\n### **Synopsis**\n```fortran\n    result = len(string [,kind])\n```\n```fortran\n     integer(kind=KIND) function len(string,KIND)\n\n      character(len=*),intent(in) :: string(..)\n      integer,optional,intent(in) :: KIND\n```\n### **Characteristics**\n\n - **string** is a scalar or array _character_ variable\n - **KIND** is a scalar integer constant expression.\n - the returned value is the same integer kind as the **kind**\n   argument, or of the default integer kind if **kind** is not specified.\n\n### **Description**\n\n  **len** returns the length of a _character_ string.\n\n  If **string** is an array, the length of a single element of **string**\n  is returned, as all elements of an array are the same length.\n\n  Note that **string** need not be defined when this intrinsic is invoked,\n  as only the length (not the content) of **string** is needed.\n\n### **Options**\n\n- **string**\n  : A scalar or array string to return the length of.\n    If it is an unallocated allocatable variable or a pointer that is\n    not associated, its length type parameter shall not be deferred.\n\n- **kind**\n  : A constant indicating the _kind_ parameter of the result.\n\n### **Result**\n\n  The result has a value equal to the number of characters in STRING\n  if it is scalar or in an element of STRING if it is an array.\n\n### **Examples**\n\nSample program\n\n```fortran\nprogram demo_len\nimplicit none\n\n! fixed length\ncharacter(len=40) :: string\n! allocatable length\ncharacter(len=:),allocatable :: astring\ncharacter(len=:),allocatable :: many_strings(:)\ninteger :: ii\n  ! BASIC USAGE\n   ii=len(string)\n   write(*,*)'length =',ii\n\n  ! ALLOCATABLE VARIABLE LENGTH CAN CHANGE\n  ! the allocatable string length will be the length of RHS expression\n   astring=' How long is this allocatable string? '\n   write(*,*)astring, ' LEN=', len(astring)\n  ! print underline\n   write(*,*) repeat('=',len(astring))\n  ! assign new value to astring and length changes\n   astring='New allocatable string'\n   write(*,*)astring, ' LEN=', len(astring)\n  ! print underline\n   write(*,*) repeat('=',len(astring))\n\n  ! THE STRING LENGTH WILL BE CONSTANT FOR A FIXED-LENGTH VARIABLE\n   string=' How long is this fixed string? '\n   write(*,*)string,' LEN=',len(string)\n   string='New fixed string '\n   write(*,*)string,' LEN=',len(string)\n\n  ! ALL STRINGS IN AN ARRAY ARE THE SAME LENGTH\n  ! a scalar is returned for an array, as all values in a Fortran\n  ! character array must be of the same length.\n   many_strings = [ character(len=7) :: 'Tom', 'Dick', 'Harry' ]\n   write(*,*)'length of ALL elements of array=',len(many_strings)\n\n  ! NAME%LEN IS ESSENTIALLY THE SAME AS LEN(NAME)\n  ! you can also query the length (and other attributes) of a string\n  ! using a \"type parameter inquiry\" (available since fortran 2018)\n   write(*,*)'length from type parameter inquiry=',string%len\n  ! %len is equivalent to a call to LEN() except the kind of the integer\n  ! value returned is always of default kind.\n\n  ! LOOK AT HOW A PASSED STRING CAN BE USED ...\n   call passed(' how long? ')\n\ncontains\n\n   subroutine passed(str)\n   character(len=*),intent(in)  :: str\n   ! the length of str can be used in the definitions of variables\n      ! you can query the length of the passed variable\n      write(*,*)'length of passed value is ', LEN(str)\n   end subroutine passed\n\nend program demo_len\n```\nResults:\n```text\n >  length =          40\n >   How long is this allocatable string?  LEN=          38\n >  ======================================\n >  New allocatable string LEN=          22\n >  ======================\n >   How long is this fixed string?          LEN=          40\n >  New fixed string                         LEN=          40\n >  length of ALL elements of array=           7\n >  length from type parameter inquiry=          40\n >  length of passed value is           11\n```\n### **Standard**\n\nFORTRAN 77 ; with **kind** argument - Fortran 2003\n\n### **See Also**\n\nlen_trim(3), adjustr(3), trim(3), and adjustl(3) are related routines that\nallow you to deal with leading and trailing blanks.\n\nFunctions that perform operations on character strings, return lengths\nof arguments, and search for certain arguments:\n\n- **Elemental:**\n  [**adjustl**(3)](#adjustl),\n  [**adjustr**(3)](#adjustr),\n  [**index**(3)](#index),\n  [**scan**(3)](#scan),\n  [**verify**(3)](#verify)\n\n- **Nonelemental:**\n  [**len_trim**(3)](#len_trim),\n  [**len**](#len),\n  [**repeat**(3)](#repeat),\n  [**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "LEN_TRIM": "## len_trim\n\n### **Name**\n\n**len_trim** - \\[CHARACTER:WHITESPACE\\] Character length without trailing blank characters\n\n### **Synopsis**\n```fortran\n  result = len_trim(string [,kind])\n```\n```fortran\n   elemental integer(kind=KIND) function len_trim(string,KIND)\n\n    character(len=*),intent(in) :: string\n    integer(kind=KIND),intent(in),optional :: KIND\n```\n### **Characteristics**\n\n - **string** is of type _character_\n - **kind** is a scalar integer constant expression specifying the kind\n   of the returned value.\n - The return value is of type _integer_ and of kind **KIND**. If **KIND**\n   is absent, the return value is of default _integer_ kind.\n\n### **Description**\n\n  **len_trim** returns the length of a character string, ignoring\n  any trailing blanks.\n\n### **Options**\n\n- **string**\n  : The input string whose length is to be measured.\n\n- **kind**\n  : Indicates the kind parameter of the result.\n\n### **Result**\n\n  The result equals the number of characters remaining\n  after any trailing blanks in **string** are removed.\n\n  If the input argument is of zero length or all blanks\n  the result is zero.\n\n### **Examples**\n\nSample program\n```fortran\nprogram demo_len_trim\nimplicit none\ncharacter(len=:),allocatable :: string\ninteger :: i\n! basic usage\n   string=\" how long is this string?     \"\n   write(*,*) string\n   write(*,*)'UNTRIMMED LENGTH=',len(string)\n   write(*,*)'TRIMMED LENGTH=',len_trim(string)\n\n   ! print string, then print substring of string\n   string='xxxxx   '\n   write(*,*)string,string,string\n   i=len_trim(string)\n   write(*,*)string(:i),string(:i),string(:i)\n   !\n  ! elemental example\n   ELE:block\n   ! an array of strings may be used\n   character(len=:),allocatable :: tablet(:)\n   tablet=[character(len=256) :: &\n   & ' how long is this string?     ',&\n   & 'and this one?']\n      write(*,*)'UNTRIMMED LENGTH=  ',len(tablet)\n      write(*,*)'TRIMMED LENGTH=    ',len_trim(tablet)\n      write(*,*)'SUM TRIMMED LENGTH=',sum(len_trim(tablet))\n   endblock ELE\n   !\nend program demo_len_trim\n```\nResults:\n```text\n     how long is this string?\n    UNTRIMMED LENGTH=          30\n    TRIMMED LENGTH=          25\n    xxxxx   xxxxx   xxxxx\n    xxxxxxxxxxxxxxx\n    UNTRIMMED LENGTH=           256\n    TRIMMED LENGTH=              25          13\n    SUM TRIMMED LENGTH=          38\n```\n### **Standard**\n\nFortran 95 . **kind** argument added with Fortran 2003.\n\n### **See Also**\n\nFunctions that perform operations on character strings, return lengths\nof arguments, and search for certain arguments:\n\n- **Elemental:**\n  [**adjustl**(3)](#adjustl),\n  [**adjustr**(3)](#adjustr),\n  [**index**(3)](#index),\n  [**scan**(3)](#scan),\n  [**verify**(3)](#verify)\n\n- **Nonelemental:**\n  [**repeat**(3)](#repeat),\n  [**len**(3)](#len),\n  [**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "LGE": "## lge\n\n### **Name**\n\n**lge** - \\[CHARACTER:COMPARE\\] ASCII Lexical greater than or equal\n\n### **Synopsis**\n```fortran\n    result = lge(string_a, stringb)\n```\n```fortran\n     elemental logical function lge(string_a, string_b)\n\n      character(len=*),intent(in) :: string_a\n      character(len=*),intent(in) :: string_b\n```\n### **Characteristics**\n\n - **string_a** is default _character_ or an ASCII character.\n - **string_b** is the same type and kind as **string\\_a**\n - the result is a default logical\n\n### **Description**\n\n  **lge** determines whether one string is lexically greater than\n  or equal to another string, where the two strings are interpreted as\n  containing ASCII character codes. If **string_a** and **string_b**\n  are not the same length, the shorter is compared as if spaces were\n  appended to it to form a value that has the same length as the longer.\n\n  The lexical comparison intrinsics **lge**, **lgt**(3), **lle**(3),\n  and **llt**(3) differ from the corresponding intrinsic operators\n  _.ge., .gt., .le., and .lt._, in that the latter use the processor's\n  character ordering (which is not ASCII on some targets), whereas the\n  former always use the ASCII ordering.\n\n### **Options**\n\n- **string_a**\n  : string to be tested\n\n- **string_b**\n  : string to compare to **string_a**\n\n### **Result**\n\n  Returns _.true._ if string_a == string_b, and _.false._ otherwise,\n  based on the ASCII collating sequence.\n\n  If both input arguments are null strings, _.true._ is always returned.\n\n  If either string contains a character not in the ASCII character set,\n  the result is processor dependent.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_lge\nimplicit none\ninteger :: i\n   print *,'the ASCII collating sequence for printable characters'\n   write(*,'(1x,19a)')(char(i),i=32,126) ! ASCII order\n   write(*,*) lge('abc','ABC')           ! [T] lowercase is > uppercase\n   write(*,*) lge('abc','abc  ')         ! [T] trailing spaces\n   ! If both strings are of zero length the result is true\n   write(*,*) lge('','')                 ! [T]\n   write(*,*) lge('','a')                ! [F] the null string is padded\n   write(*,*) lge('a','')                ! [T]\n   ! elemental\n   write(*,*) lge('abc',['abc','123'])   ! [T T]  scalar and array\n   write(*,*) lge(['cba', '123'],'abc')  ! [T F]\n   write(*,*) lge(['abc','123'],['cba','123']) ! [F T]  both arrays\nend program demo_lge\n```\nResults:\n```text\n >  the ASCII collating sequence for printable characters\n >   !\"#$%&'()*+,-./012\n >  3456789:;<=>?@ABCDE\n >  FGHIJKLMNOPQRSTUVWX\n >  YZ[\\]^_`abcdefghijk\n >  lmnopqrstuvwxyz{|}~\n >  T\n >  T\n >  T\n >  F\n >  T\n >  T T\n >  T F\n >  F T\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n  [**lgt**(3)](#lgt),\n  [**lle**(3)](#lle),\n  [**llt**(3)](#llt)\n\nFunctions that perform operations on character strings, return lengths\nof arguments, and search for certain arguments:\n\n- **Elemental:**\n  [**adjustl**(3)](#adjustl),\n  [**adjustr**(3)](#adjustr),\n  [**index**(3)](#index),\n\n[**scan**(3)](#scan),\n[**verify**(3)](#verify)\n\n- **Nonelemental:**\n  [**len_trim**(3)](#len_trim),\n  [**len**(3)](#len),\n  [**repeat**(3)](#repeat),\n  [**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "LGT": "## lgt\n\n### **Name**\n\n**lgt** - \\[CHARACTER:COMPARE\\] ASCII Lexical greater than\n\n### **Synopsis**\n```fortran\n     result = lgt(string_a, string_b)\n```\n```fortran\n      elemental logical function lgt(string_a, string_b)\n\n       character(len=*),intent(in) :: string_a\n       character(len=*),intent(in) :: string_b\n```\n### **Characteristics**\n\n - **string_a** is default _character_ or an ASCII character.\n - **string_b** is the same type and kind as **string_a**\n - the result is a default logical\n\n### **Description**\n\n  **lgt** determines whether one string is lexically greater than\n  another string, where the two strings are interpreted as containing\n  ASCII character codes. If the String **a** and String **b** are not\n  the same length, the shorter is compared as if spaces were appended\n  to it to form a value that has the same length as the longer.\n\n  In general, the lexical comparison intrinsics **lge**, **lgt**, **lle**,\n  and **llt** differ from the corresponding intrinsic operators _.ge.,\n  .gt., .le., and .lt._, in that the latter use the processor's character\n  ordering (which is not ASCII on some targets), whereas the former\n  always use the ASCII ordering.\n\n### **Options**\n\n- **string_a**\n  : string to be tested\n\n- **string_b**\n  : string to compare to **string_a**\n\n### **Result**\n\n  Returns _.true._ if string_a \\> string_b, and _.false._ otherwise,\n  based on the ASCII ordering.\n\n  If both input arguments are null strings, _.false._ is returned.\n\n  If either string contains a character not in the ASCII character set,\n  the result is processor dependent.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_lgt\nimplicit none\ninteger :: i\n   print *,'the ASCII collating sequence for printable characters'\n   write(*,'(1x,19a)')(char(i),i=32,126)\n\n   write(*,*) lgt('abc','ABC')          ! [T] lowercase is > uppercase\n   write(*,*) lgt('abc','abc  ')        ! [F] trailing spaces\n\n   ! If both strings are of zero length the result is false.\n   write(*,*) lgt('','')                ! [F]\n   write(*,*) lgt('','a')               ! [F] the null string is padded\n   write(*,*) lgt('a','')               ! [T]\n   write(*,*) lgt('abc',['abc','123'])  ! [F T]  scalar and array\n   write(*,*) lgt(['cba', '123'],'abc') ! [T F]\n   write(*,*) lgt(['abc','123'],['cba','123']) ! [F F]  both arrays\nend program demo_lgt\n```\nResults:\n```text\n >  the ASCII collating sequence for printable characters\n >   !\"#$%&'()*+,-./012\n >  3456789:;<=>?@ABCDE\n >  FGHIJKLMNOPQRSTUVWX\n >  YZ[\\]^_`abcdefghijk\n >  lmnopqrstuvwxyz{|}~\n >  T\n >  F\n >  F\n >  F\n >  T\n >  F T\n >  T F\n >  F F\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n [**lge**(3)](#lge),\n [**lle**(3)](#lle),\n [**llt**(3)](#llt)\n\n  Functions that perform operations on character strings, return lengths\n  of arguments, and search for certain arguments:\n\n- **Elemental:**\n  [**adjustl**(3)](#adjustl),\n  [**adjustr**(3)](#adjustr),\n  [**index**(3)](#index),\n\n[**scan**(3)](#scan),\n[**verify**(3)](#verify)\n\n- **Nonelemental:**\n  [**len_trim**(3)](#len_trim),\n  [**len**(3)](#len),\n  [**repeat**(3)](#repeat),\n  [**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "LLE": "## lle\n\n### **Name**\n\n**lle** - \\[CHARACTER:COMPARE\\] ASCII Lexical less than or equal\n\n### **Synopsis**\n```fortran\n     result = lle(string_a, stringb)\n```\n```fortran\n      elemental logical function lle(string_a, string_b)\n\n       character(len=*),intent(in) :: string_a\n       character(len=*),intent(in) :: string_b\n```\n### **Characteristics**\n\n - **string_a** is default _character_ or an ASCII character.\n - **string_b** is the same type and kind as **string_a**\n - the result is a default logical\n\n### **Description**\n\n  **lle** determines whether one string is lexically less than or equal\n  to another string, where the two strings are interpreted as containing\n  ASCII character codes.\n\n  If **string_a** and **string_b** are not the\n  same length, the shorter is compared as if spaces were appended to it\n  to form a value that has the same length as the longer.\n\n  Leading spaces are significant.\n\n  In general, the lexical comparison intrinsics **lge**, **lgt**, **lle**,\n  and **llt** differ from the corresponding intrinsic operators _.ge.,\n  .gt., .le., and .lt._, in that the latter use the processor's character\n  ordering (which is not ASCII on some targets), whereas **lle**\n  always uses the ASCII ordering.\n\n### **Options**\n\n- **string_a**\n  : string to be tested\n\n- **string_b**\n  : string to compare to **string_a**\n\n### **Result**\n\n  Returns _.true._ if **string_a \\<= string_b**, and _.false._ otherwise,\n  based on the ASCII collating sequence.\n\n  If both input arguments are null strings, _.true._ is always returned.\n\n  If either string contains a character not in the ASCII character set,\n  the result is processor dependent.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_lle\nimplicit none\ninteger :: i\n   print *,'the ASCII collating sequence for printable characters'\n   write(*,'(1x,19a)')(char(i),i=32,126)\n  ! basics\n\n   print *,'case matters'\n   write(*,*) lle('abc','ABC')       ! F lowercase is > uppercase\n\n   print *,'a space is the lowest printable character'\n   write(*,*) lle('abcd','abc')      ! F  d > space\n   write(*,*) lle('abc','abcd')      ! T  space < d\n\n   print *,'leading spaces matter, trailing spaces do not'\n   write(*,*) lle('abc','abc  ')     ! T trailing spaces\n   write(*,*) lle('abc',' abc')      ! F leading spaces are significant\n\n   print *,'even null strings are padded and compared'\n   ! If both strings are of zero length the result is true.\n   write(*,*) lle('','')             ! T\n   write(*,*) lle('','a')            ! T the null string is padded\n   write(*,*) lle('a','')            ! F\n   print *,'elemental'\n   write(*,*) lle('abc',['abc','123'])  ! [T,F] scalar and array\n   write(*,*) lle(['cba', '123'],'abc') ! [F,T]\n   ! per the rules for elemental procedures arrays must be the same size\n   write(*,*) lle(['abc','123'],['cba','123']) ! [T,T] both arrays\nend program demo_lle\n```\nResults:\n```text\n >  the ASCII collating sequence for printable characters\n >   !\"#$%&'()*+,-./012\n >  3456789:;<=>?@ABCDE\n >  FGHIJKLMNOPQRSTUVWX\n >  YZ[\\]^_`abcdefghijk\n >  lmnopqrstuvwxyz{|}~\n >  case matters\n >  F\n >  a space is the lowest printable character\n >  F\n >  T\n >  leading spaces matter, trailing spaces do not\n >  T\n >  F\n >  even null strings are padded and compared\n >  T\n >  T\n >  F\n >  elemental\n >  T F\n >  F T\n >  T T\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n  [**lge**(3)](#lge),\n  [**lgt**(3)](#lgt),\n  [**llt**(3)](#llt)\n\nFunctions that perform operations on character strings, return lengths\nof arguments, and search for certain arguments:\n\n- **Elemental:**\n  [**adjustl**(3)](#adjustl),\n  [**adjustr**(3)](#adjustr),\n  [**index**(3)](#index),\n\n[**scan**(3)](#scan),\n[**verify**(3)](#verify)\n\n- **Nonelemental:**\n  [**len_trim**(3)](#len_trim),\n  [**len**(3)](#len),\n  [**repeat**(3)](#repeat),\n  [**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "LLT": "## llt\n\n### **Name**\n\n**llt** - \\[CHARACTER:COMPARE\\] ASCII Lexical less than\n\n### **Synopsis**\n```fortran\n     result = llt(string_a, stringb)\n```\n```fortran\n      elemental logical function llt(string_a, string_b)\n\n       character(len=*),intent(in) :: string_a\n       character(len=*),intent(in) :: string_b\n```\n### **Characteristics**\n\n - **string_a** is default _character_ or an ASCII character.\n - **string_b** is the same type and kind as **string_a**\n - the result is a default logical\n\n### **Description**\n\n  **llt** determines whether one string is lexically less than\n  another string, where the two strings are interpreted as containing\n  ASCII character codes. If the **string_a** and **string_b** are not\n  the same length, the shorter is compared as if spaces were appended\n  to it to form a value that has the same length as the longer.\n\n  In general, the lexical comparison intrinsics **lge**, **lgt**, **lle**,\n  and **llt** differ from the corresponding intrinsic operators _.ge.,\n  .gt., .le., and .lt._, in that the latter use the processor's character\n  ordering (which is not ASCII on some targets), whereas the former\n  always use the ASCII ordering.\n\n### **Options**\n\n\n- **string_a**\n  : string to be tested\n\n- **string_b**\n  : string to compare to **string_a**\n\n### **Result**\n\n  Returns _.true._ if string_a \\<= string_b, and _.false._ otherwise,\n  based on the ASCII collating sequence.\n\n  If both input arguments are null strings, _.false._ is always returned.\n\n  If either string contains a character not in the ASCII character set,\n  the result is processor dependent.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_llt\nimplicit none\ninteger :: i\n\n   print *,'the ASCII collating sequence for printable characters'\n   write(*,'(1x,19a)')(char(i),i=32,126) ! ASCII order\n\n  ! basics\n   print *,'case matters'\n   write(*,*) llt('abc','ABC')           ! [F] lowercase is > uppercase\n   write(*,*) llt('abc','abc  ')         ! [F] trailing spaces\n   ! If both strings are of zero length the result is false.\n   write(*,*) llt('','')                 ! [F]\n   write(*,*) llt('','a')                ! [T] the null string is padded\n   write(*,*) llt('a','')                ! [F]\n   print *,'elemental'\n   write(*,*) llt('abc',['abc','123'])   ! [F F]  scalar and array\n   write(*,*) llt(['cba', '123'],'abc')  ! [F T]\n   write(*,*) llt(['abc','123'],['cba','123']) ! [T F]  both arrays\nend program demo_llt\n```\nResults:\n```text\n >  the ASCII collating sequence for printable characters\n >   !\"#$%&'()*+,-./012\n >  3456789:;<=>?@ABCDE\n >  FGHIJKLMNOPQRSTUVWX\n >  YZ[\\]^_`abcdefghijk\n >  lmnopqrstuvwxyz{|}~\n >  case matters\n >  F\n >  F\n >  F\n >  T\n >  F\n >  elemental\n >  F F\n >  F T\n >  T F\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n  [**lge**(3)](#lge),\n  [**lgt**(3)](#lgt),\n  [**lle**(3)](#lle))\n\nFunctions that perform operations on character strings, return lengths\nof arguments, and search for certain arguments:\n\n- **Elemental:**\n  [**adjustl**(3)](#adjustl), [**adjustr**(3)](#adjustr), [**index**(3)](#index),\n  [**scan**(3)](#scan), [**verify**(3)](#verify)\n\n- **Nonelemental:**\n  [**len_trim**(3)](#len_trim),\n  [**len**(3)](#len),\n  [**repeat**(3)](#repeat), [**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "LOG": "## log\n\n### **Name**\n\n**log** - \\[MATHEMATICS\\] Natural logarithm\n\n### **Synopsis**\n```fortran\n  result = log(x)\n```\n```fortran\n   elemental TYPE(kind=KIND) function log(x)\n\n    TYPE(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **x** may be any _real_ or _complex_ kind.\n - the result is the same type and characteristics as **x**.\n\n### **Description**\n\n  **log** computes the natural logarithm of **x**, i.e. the logarithm to\n  the base \"e\".\n\n### **Options**\n\n- **x**\n  : The value to compute the natural log of.\n    If **x** is _real_, its value shall be greater than zero.\n    If **x** is _complex_, its value shall not be zero.\n\n\n### **Result**\n\n  The natural logarithm of **x**.\n  If **x** is the _complex_ value **(r,i)** , the imaginary part \"i\" is in the range\n```fortran\n    -PI < i <= PI\n```\n   If the real part of **x** is less than zero and the imaginary part of\n   **x** is zero, then the imaginary part of the result is approximately\n   **PI** if the imaginary part of **PI** is positive real zero or the\n   processor does not distinguish between positive and negative real zero,\n   and approximately **-PI** if the imaginary part of **x** is negative\n   real zero.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_log\nimplicit none\n  real(kind(0.0d0)) :: x = 2.71828182845904518d0\n  complex :: z = (1.0, 2.0)\n  write(*,*)x, log(x)    ! will yield (approximately) 1\n  write(*,*)z, log(z)\nend program demo_log\n```\nResults:\n```text\n      2.7182818284590451        1.0000000000000000\n   (1.00000000,2.00000000) (0.804718971,1.10714877)\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See also**\n\n[****(3)](#)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "LOG10": "## log10\n\n### **Name**\n\n**log10** - \\[MATHEMATICS\\] Base 10 or common logarithm\n\n### **Synopsis**\n```fortran\n    result = log10(x)\n```\n```fortran\n     elemental real(kind=KIND) function log10(x)\n\n      real(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **x** may be any kind of _real_ value\n - the result is the same type and characteristics as **x**.\n\n### **Description**\n\n  **log10** computes the base 10 logarithm of **x**. This is generally\n  called the \"common logarithm\".\n\n### **Options**\n\n- **x**\n  : A _real_ value > 0 to take the log of.\n\n### **Result**\n\n  The logarithm to base 10 of **x**\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_log10\nuse, intrinsic :: iso_fortran_env, only : real_kinds, &\n & real32, real64, real128\nimplicit none\nreal(kind=real64) :: x = 10.0_real64\n\n   x = log10(x)\n   write(*,'(*(g0))')'log10(',x,') is ',log10(x)\n\n   ! elemental\n   write(*, *)log10([1.0, 10.0, 100.0, 1000.0, 10000.0, &\n                     & 100000.0, 1000000.0, 10000000.0])\n\nend program demo_log10\n```\nResults:\n```text\n > log10(1.000000000000000) is .000000000000000\n >   0.0000000E+00   1.000000       2.000000       3.000000       4.000000\n >    5.000000       6.000000       7.000000\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See also**\n\n[****(3)](#)\n\n _fortran-lang intrinsic descriptions_\n",
  "LOGICAL": "## logical\n\n### **Name**\n\n**logical** - \\[TYPE:LOGICAL\\] Conversion between kinds of logical values\n\n### **Synopsis**\n```fortran\n    result = logical(l [,kind])\n```\n```fortran\n     elemental logical(kind=KIND) function logical(l,KIND)\n\n      logical(kind=**),intent(in) :: l\n      integer(kind=**),intent(in),optional :: KIND\n```\n### **Characteristics**\n\n  - a kind designated as ** may be any supported kind for the type\n  - **l** is of type logical\n  - **KIND** shall be a scalar integer constant expression.\n    If **KIND** is present, the kind type parameter of the result is\n    that specified by the value of **KIND**; otherwise, the kind type\n    parameter is that of default logical.\n\n### **Description**\n\n  **logical** converts one kind of _logical_ variable to another.\n\n### **Options**\n\n- **l**\n  : The _logical_ value to produce a copy of with kind **kind**\n\n- **kind**\n  : indicates the kind parameter of the result.\n  If not present, the default kind is returned.\n\n### **Result**\n\nThe return value is a _logical_ value equal to **l**, with a kind\ncorresponding to **kind**, or of the default logical kind if **kind**\nis not given.\n\n### **Examples**\n\nSample program:\n```fortran\nLinux\nprogram demo_logical\n! Access array containing the kind type parameter values supported by this\n! compiler for entities of logical type\nuse iso_fortran_env, only : logical_kinds\nimplicit none\ninteger :: i\n\n   ! list kind values supported on this platform, which generally vary\n   ! in storage size as alias declarations\n   do i =1, size(logical_kinds)\n      write(*,'(*(g0))')'integer,parameter :: boolean', &\n      & logical_kinds(i),'=', logical_kinds(i)\n   enddo\n\nend program demo_logical\n```\nResults:\n```text\n > integer,parameter :: boolean1=1\n > integer,parameter :: boolean2=2\n > integer,parameter :: boolean4=4\n > integer,parameter :: boolean8=8\n > integer,parameter :: boolean16=16\n```\n### **Standard**\n\nFortran 95 , related ISO_FORTRAN_ENV module - fortran 2009\n\n### **See Also**\n\n[**int**(3)](#int),\n[**real**(3)](#real),\n[**cmplx**(3)](#cmplx)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "LOG_GAMMA": "## log_gamma\n\n### **Name**\n\n**log_gamma** - \\[MATHEMATICS\\] Logarithm of the absolute value of\nthe Gamma function\n\n### **Synopsis**\n```fortran\n    result = log_gamma(x)\n```\n```fortran\n     elemental real(kind=KIND) function log_gamma(x)\n\n      real(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n  - **x** may be any _real_ type\n  - the return value is of same type and kind as **x**.\n\n### **Description**\n\n  **log_gamma** computes the natural logarithm of the absolute value\n  of the Gamma function.\n\n### **Options**\n\n- **x**\n  : neither negative nor zero value to render the result for.\n\n### **Result**\n\n The result has a value equal to a processor-dependent approximation\n to the natural logarithm of the absolute value of the gamma function\n of **x**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_log_gamma\nimplicit none\nreal :: x = 1.0\n   write(*,*)x,log_gamma(x) ! returns 0.0\n   write(*,*)x,log_gamma(3.0) ! returns 0.693 (approximately)\nend program demo_log_gamma\n```\nResults:\n```text\n >    1.000000      0.0000000E+00\n >    1.000000      0.6931472\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\nGamma function: [**gamma**(3)](#gamma)\n\n _fortran-lang intrinsic descriptions_\n",
  "MASKL": "## maskl\n\n### **Name**\n\n**maskl** - \\[BIT:SET\\] Generates a left justified mask\n\n### **Synopsis**\n```fortran\n    result = maskl( i [,kind] )\n```\n```fortran\n     elemental integer(kind=KIND) function maskl(i,KIND)\n\n      integer(kind=**),intent(in) :: i\n      integer(kind=**),intent(in),optional :: KIND\n```\n### **Characteristics**\n\n- a kind designated as ** may be any supported kind for the type\n- **i** is an integer\n- **kind** Shall be a scalar constant expression of type _integer_\n  whose value is a supported _integer_ kind.\n- The result is an _integer_ of the same _kind_ as **i** unless **kind** is\n  present, which is then used to specify the kind of the result.\n\n### **Description**\n\n  **maskl** has its leftmost **i** bits set to **1**, and the remaining\n  bits set to **0**.\n\n### **Options**\n\n- **i**\n  : the number of left-most bits to set in the _integer_ result. It\n  must be from 0 to the number of bits for the kind of the result.\n  The default kind of the result is the same as **i** unless the result\n  size is specified by **kind**. That is, these Fortran statements must\n  be _.true._ :\n```fortran\n   i >= 0 .and. i < bitsize(i) ! if KIND is not specified\n   i >= 0 .and. i < bitsize(0_KIND) ! if KIND is specified\n```\n- **kind**\n  : designates the kind of the _integer_ result.\n\n### **Result**\n\n  The leftmost **i** bits of the output _integer_ are set to 1 and the\n  other bits are set to 0.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_maskl\nimplicit none\ninteger :: i\n  ! basics\n   i=3\n   write(*,'(i0,1x,b0)') i, maskl(i)\n\n  ! elemental\n   write(*,'(*(i11,1x,b0.32,1x,/))') maskl([(i,i,i=0,bit_size(0),4)])\nend program demo_maskl\n```\nResults:\n```text\n > 3 11100000000000000000000000000000\n >           0 00000000000000000000000000000000\n >  -268435456 11110000000000000000000000000000\n >   -16777216 11111111000000000000000000000000\n >    -1048576 11111111111100000000000000000000\n >      -65536 11111111111111110000000000000000\n >       -4096 11111111111111111111000000000000\n >        -256 11111111111111111111111100000000\n >         -16 11111111111111111111111111110000\n >          -1 11111111111111111111111111111111\n\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**maskr**(3)](#maskr)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "MASKR": "## maskr\n\n### **Name**\n\n**maskr** - \\[BIT:SET\\] Generates a right-justified mask\n\n### **Synopsis**\n```fortran\n    result = maskr( i [,kind] )\n```\n```fortran\n     elemental integer(kind=KIND) function maskr(i,KIND)\n\n      integer(kind=**),intent(in) :: i\n      integer(kind=**),intent(in),optional :: KIND\n```\n### **Characteristics**\n\n- a kind designated as ** may be any supported kind for the type\n- **i** is an integer\n- **kind** Shall be a scalar constant expression of type _integer_\n  whose value is a supported _integer_ kind.\n- The result is an _integer_ of the same _kind_ as **i** unless **kind** is\n  present, which is then used to specify the kind of the result.\n\n### **Description**\n\n  **maskr** generates an _integer_ with its rightmost **i**\n  bits set to 1, and the remaining bits set to 0.\n\n### **Options**\n\n- **i**\n  : the number of right-most bits to set in the _integer_ result. It\n  must be from 0 to the number of bits for the kind of the result.\n  The default kind of the result is the same as **i** unless the result\n  size is specified by **kind**. That is, these Fortran statements must\n  be _.true._ :\n```fortran\n   i >= 0 .and. i < bitsize(i) ! if KIND is not specified\n   i >= 0 .and. i < bitsize(0_KIND) ! if KIND is specified\n```\n- **kind**\n  : designates the kind of the _integer_ result.\n\n### **Result**\n\n  The rightmost **i** bits of the output _integer_ are set to 1 and the\n  other bits are set to 0.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_maskr\nimplicit none\ninteger :: i\n\n  ! basics\n   print *,'basics'\n   write(*,'(i0,t5,b32.32)') 1, maskr(1)\n   write(*,'(i0,t5,b32.32)') 5,  maskr(5)\n   write(*,'(i0,t5,b32.32)') 11, maskr(11)\n   print *,\"should be equivalent on two's-complement processors\"\n   write(*,'(i0,t5,b32.32)') 1,  shiftr(-1,bit_size(0)-1)\n   write(*,'(i0,t5,b32.32)') 5,  shiftr(-1,bit_size(0)-5)\n   write(*,'(i0,t5,b32.32)') 11, shiftr(-1,bit_size(0)-11)\n\n  ! elemental\n   print *,'elemental '\n   print *,'(array argument accepted like called with each element)'\n   write(*,'(*(i11,1x,b0.32,1x,/))') maskr([(i,i,i=0,bit_size(0),4)])\n\nend program demo_maskr\n```\nResults:\n```text\n >   basics\n >  1   00000000000000000000000000000001\n >  5   00000000000000000000000000011111\n >  11  00000000000000000000011111111111\n >   should be equivalent on two's-complement processors\n >  1   00000000000000000000000000000001\n >  5   00000000000000000000000000011111\n >  11  00000000000000000000011111111111\n >   elemental\n >   (array argument accepted like called with each element)\n >            0 00000000000000000000000000000000\n >           15 00000000000000000000000000001111\n >          255 00000000000000000000000011111111\n >         4095 00000000000000000000111111111111\n >        65535 00000000000000001111111111111111\n >      1048575 00000000000011111111111111111111\n >     16777215 00000000111111111111111111111111\n >    268435455 00001111111111111111111111111111\n >           -1 11111111111111111111111111111111\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**maskl**(3)](#maskl)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "MATMUL": "## matmul\n\n### **Name**\n\n**matmul** - \\[TRANSFORMATIONAL\\] Numeric or logical matrix\nmultiplication\n\n### **Synopsis**\n```fortran\n    result = matmul(matrix_a,matrix_b)\n```\n```fortran\n     function matmul(matrix_a, matrix_b)\n\n      type(TYPE1(kind=**))      :: matrix_a(..)\n      type(TYPE2(kind=**))      :: matrix_b(..)\n      type(TYPE(kind=PROMOTED)) :: matmul(..)\n```\n### **Characteristics**\n\n - **matrix_a** is a numeric (_integer_, _real_, or _complex_ ) or\n   _logical_ array of rank one two.\n - **matrix_b** is a numeric (_integer_, _real_, or _complex_ ) or\n   _logical_ array of rank one two.\n - At least one argument must be rank two.\n - the size of the first dimension of **matrix_b** must equal the size\n   of the last dimension of **matrix_a**.\n - the type of the result is the same as if an element of each argument\n   had been multiplied as a RHS expression (that is, if the arguments\n   are not of the same type the result follows the same rules of promotion\n   as a simple scalar multiplication of the two types would produce)\n - If one argument is _logical_, both must be _logical_. For logicals\n   the resulting type is as if the _.and._ operator has been used on\n   elements from the arrays.\n - The shape of the result depends on the shapes of the arguments\n   as described below.\n\n### **Description**\n\n **matmul** performs a matrix multiplication on numeric or logical\n arguments.\n\n### **Options**\n\n- **matrix_a**\n  : A numeric or logical array with a rank of one or two.\n\n- **matrix_b**\n  : A numeric or logical array with a rank of one or two. The last\n  dimension of **matrix_a** and the first dimension of **matrix_b**\n  must be equal.\n\n  Note that **matrix_a** and **matrix_b** may be different numeric\n  types.\n\n### **Result**\n\n####  **Numeric Arguments**\n\n  If **matrix_a** and **matrix_b** are numeric the result is an\n  array containing the conventional matrix product of **matrix_a**\n  and **matrix_b**.\n\n  First, for the numeric expression **C=matmul(A,B)**\n\n   - Any vector **A(n)** is treated as a row vector **A(1,n)**.\n   - Any vector **B(n)** is treated as a column vector **B(n,1)**.\n\n#####  **Shape and Rank**\n\n  The shape of the result can then be determined as the number of rows\n  of the first matrix and the number of columns of the second; but if\n  any argument is of rank one (a vector) the result is also rank one.\n  Conversely when both arguments are of rank two, the result has a rank\n  of two. That is ...\n\n   + If **matrix_a** has shape [n,m] and **matrix_b** has shape [m,k],\n     the result has shape [n,k].\n   + If **matrix_a** has shape [m] and **matrix_b** has shape [m,k],\n     the result has shape [k].\n   + If **matrix_a** has shape [n,m] and **matrix_b** has shape [m],\n     the result has shape [n].\n\n#####  **Values**\n\n  Then element **C(i,j)** of the product is obtained by multiplying\n  term-by-term the entries of the ith row of **A** and the jth column\n  of **B**, and summing these products. In other words, **C(i,j)**\n  is the dot product of the ith row of **A** and the jth column of **B**.\n\n#### **Logical Arguments**\n\n#####  **Values**\n\n  If **matrix_a** and **matrix_b** are of type logical, the array elements\n  of the result are instead:\n```fortran\n  Value_of_Element (i,j) = &\n  ANY( (row_i_of_MATRIX_A) .AND. (column_j_of_MATRIX_B) )\n```\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_matmul\nimplicit none\ninteger :: a(2,3), b(3,2), c(2), d(3), e(2,2), f(3), g(2), v1(4),v2(4)\n   a = reshape([1, 2, 3, 4, 5, 6], [2, 3])\n   b = reshape([10, 20, 30, 40, 50, 60], [3, 2])\n   c = [1, 2]\n   d = [1, 2, 3]\n   e = matmul(a, b)\n   f = matmul(c,a)\n   g = matmul(a,d)\n\n   call print_matrix_int('A is ',a)\n   call print_matrix_int('B is ',b)\n   call print_vector_int('C is ',c)\n   call print_vector_int('D is ',d)\n   call print_matrix_int('E is matmul(A,B)',e)\n   call print_vector_int('F is matmul(C,A)',f)\n   call print_vector_int('G is matmul(A,D)',g)\n\n   ! look at argument shapes when one is a vector\n   write(*,'(\" > shape\")')\n   ! at least one argument must be of rank two\n   ! so for two vectors at least one must be reshaped\n   v1=[11,22,33,44]\n   v2=[10,20,30,40]\n\n   ! these return a vector C(1:1)\n   ! treat A(1:n) as A(1:1,1:n)\n   call print_vector_int('Cd is a vector (not a scalar)',&\n   & matmul(reshape(v1,[1,size(v1)]),v2))\n   ! or treat B(1:m) as B(1:m,1:1)\n   call print_vector_int('cD is a vector too',&\n   & matmul(v1,reshape(v2,[size(v2),1])))\n\n   ! or treat A(1:n) as A(1:1,1:n) and B(1:m) as B(1:m,1:1)\n   ! but note this returns a matrix C(1:1,1:1) not a vector!\n   call print_matrix_int('CD is a matrix',matmul(&\n   & reshape(v1,[1,size(v1)]), &\n   & reshape(v2,[size(v2),1])))\n\ncontains\n\n! CONVENIENCE ROUTINES TO PRINT IN ROW-COLUMN ORDER\nsubroutine print_vector_int(title,arr)\ncharacter(len=*),intent(in)  :: title\ninteger,intent(in)           :: arr(:)\n   call print_matrix_int(title,reshape(arr,[1,shape(arr)]))\nend subroutine print_vector_int\n\nsubroutine print_matrix_int(title,arr)\n!@(#) print small 2d integer arrays in row-column format\ncharacter(len=*),parameter :: all='(\" > \",*(g0,1x))' ! a handy format\ncharacter(len=*),intent(in)  :: title\ninteger,intent(in)           :: arr(:,:)\ninteger                      :: i\ncharacter(len=:),allocatable :: biggest\n\n   print all\n   print all, trim(title)\n   biggest='           '  ! make buffer to write integer into\n   ! find how many characters to use for integers\n   write(biggest,'(i0)')ceiling(log10(max(1.0,real(maxval(abs(arr))))))+2\n   ! use this format to write a row\n   biggest='(\" > [\",*(i'//trim(biggest)//':,\",\"))'\n   ! print one row of array at a time\n   do i=1,size(arr,dim=1)\n      write(*,fmt=biggest,advance='no')arr(i,:)\n      write(*,'(\" ]\")')\n   enddo\n\nend subroutine print_matrix_int\n\nend program demo_matmul\n```\nResults:\n```text\n    >\n    > A is\n    > [  1,  3,  5 ]\n    > [  2,  4,  6 ]\n    >\n    > B is\n    > [  10,  40 ]\n    > [  20,  50 ]\n    > [  30,  60 ]\n    >\n    > C is\n    > [  1,  2 ]\n    >\n    > D is\n    > [  1,  2,  3 ]\n    >\n    > E is matmul(A,B)\n    > [  220,  490 ]\n    > [  280,  640 ]\n    >\n    > F is matmul(C,A)\n    > [   5,  11,  17 ]\n    >\n    > G is matmul(A,D)\n    > [  22,  28 ]\n    > shape\n    >\n    > Cd is a vector (not a scalar)\n    > [  3300 ]\n    >\n    > cD is a vector too\n    > [  3300 ]\n    >\n    > CD is a matrix\n    > [  3300 ]\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**product**(3)](#product),\n[**transpose**(3)](#transpose)\n\n### **Resources**\n\n- [Matrix multiplication : Wikipedia](https://en.wikipedia.org/wiki/Matrix_multiplication)\n- The Winograd variant of Strassen's matrix-matrix multiply algorithm may\n  be of interest for optimizing multiplication of very large matrices. See\n```text\n    \"GEMMW: A portable level 3 BLAS Winograd variant of Strassen's\n    matrix-matrix multiply algorithm\",\n\n    Douglas, C. C., Heroux, M., Slishman, G., and Smith, R. M.,\n    Journal of Computational Physics,\n    Vol. 110, No. 1, January 1994, pages 1-10.\n\n  The numerical instabilities of Strassen's method for matrix\n  multiplication requires special processing.\n```\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "MAX": "## max\n\n### **Name**\n\n**max** - \\[NUMERIC\\] Maximum value of an argument list\n\n### **Synopsis**\n```fortran\n    result = max(a1, a2, a3, ...)\n```\n```fortran\n     elemental TYPE(kind=KIND) function max(a1, a2, a3, ... )\n\n      TYPE(kind=KIND,intent(in),optional :: a1\n      TYPE(kind=KIND,intent(in),optional :: a2\n      TYPE(kind=KIND,intent(in),optional :: a3\n                :\n                :\n                :\n```\n### **Characteristics**\n\n - **a3, a3, a4, ...** must be of the same type and kind as **a1**\n - the arguments may (all) be _integer_, _real_ or _character_\n - there must be at least two arguments\n - the length of a character result is the length of the longest argument\n - the type and kind of the result is the same as those of the arguments\n\n### **Description**\n\n  **max** returns the argument with the largest (most positive) value.\n\n  For arguments of character type, the result is as if the arguments had\n  been successively compared with the intrinsic operational operators,\n  taking into account the collating sequence of the _character_ kind.\n\n  If the selected _character_ argument is shorter than the longest\n  argument, the result is as all values were extended with blanks on\n  the right to the length of the longest argument.\n\n  It is unusual for a Fortran intrinsic to take an arbitrary number of\n  options, and in addition **max** is elemental, meaning any number\n  of arguments may be arrays as long as they are of the same shape.\n  The examples have an extended description clarifying the resulting\n  behavior for those not familiar with calling a \"scalar\" function\n  elementally with arrays.\n\n  See maxval(3) for simply getting the max value of an array.\n\n### **Options**\n\n- **a1**\n  : The first argument determines the type and kind of the returned\n  value, and of any remaining arguments as well as being a member of\n  the set of values to find the maximum (most positive) value of.\n\n- **a2,a3,...**\n  : the remaining arguments of which to find the maximum value(s) of.\n  : There must be at least two arguments to **max(3)**.\n\n### **Result**\n\n  The return value corresponds to an array of the same shape of any\n  array argument, or a scalar if all arguments are scalar.\n\n  The returned value when any argument is an array will be an array of\n  the same shape where each element is the maximum value occurring at\n  that location, treating all the scalar values as arrays of that same\n  shape with all elements set to the scalar value.\n\n### **Examples**\n\nSample program\n```fortran\nprogram demo_max\nimplicit none\nreal :: arr1(4)= [10.0,11.0,30.0,-100.0]\nreal :: arr2(5)= [20.0,21.0,32.0,-200.0,2200.0]\ninteger :: box(3,4)= reshape([-6,-5,-4,-3,-2,-1,1,2,3,4,5,6],shape(box))\n\n  ! basic usage\n   ! this is simple enough when all arguments are scalar\n\n   ! the most positive value is returned, not the one with the\n   ! largest magnitude\n   write(*,*)'scalars:',max(10.0,11.0,30.0,-100.0)\n   write(*,*)'scalars:',max(-22222.0,-0.0001)\n\n   ! strings do not need to be of the same length\n   write(*,*)'characters:',max('the','words','order')\n\n   ! leading spaces are significant; everyone is padded on the right\n   ! to the length of the longest argument\n   write(*,*)'characters:',max('c','bb','a')\n   write(*,*)'characters:',max(' c','b','a')\n\n  ! elemental\n   ! there must be at least two arguments, so even if A1 is an array\n   ! max(A1) is not valid. See MAXVAL(3) and/or MAXLOC(3) instead.\n\n   ! strings in a single array do need to be of the same length\n   ! but the different objects can still be of different lengths.\n   write(*,\"(*('\"\"',a,'\"\"':,1x))\")MAX(['A','Z'],['BB','Y '])\n   ! note the result is now an array with the max of every element\n   ! position, as can be illustrated numerically as well:\n   write(*,'(a,*(i3,1x))')'box=   ',box\n   write(*,'(a,*(i3,1x))')'box**2=',sign(1,box)*box**2\n   write(*,'(a,*(i3,1x))')'max    ',max(box,sign(1,box)*box**2)\n\n   ! Remember if any argument is an array by the definition of an\n   ! elemental function all the array arguments must be the same shape.\n\n   ! to find the single largest value of arrays you could use something\n   ! like MAXVAL([arr1, arr2]) or probably better (no large temp array),\n   ! max(maxval(arr1),maxval(arr2)) instead\n\n   ! so this returns an array of the same shape as any input array\n   ! where each result is the maximum that occurs at that position.\n   write(*,*)max(arr1,arr2(1:4))\n   ! this returns an array just like arr1 except all values less than\n   ! zero are set to zero:\n   write(*,*)max(box,0)\n   ! When mixing arrays and scalars you can think of the scalars\n   ! as being a copy of one of the arrays with all values set to\n   ! the scalar value.\n\nend program demo_max\n```\nResults:\n```text\n    scalars:   30.00000\n    scalars: -9.9999997E-05\n    characters:words\n    characters:c\n    characters:b\n   \"BB\" \"Z \"\n   box=    -6  -5  -4  -3  -2  -1   1   2   3   4   5   6\n   box**2=-36 -25 -16  -9  -4  -1   1   4   9  16  25  36\n   max     -6  -5  -4  -3  -2  -1   1   4   9  16  25  36\n   20.00000  21.00000  32.00000  -100.0000\n   0  0  0  0  0  0\n   1  2  3  4  5  6\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n[**maxloc**(3)](#maxloc),\n[**minloc**(3)](#minloc),\n[**maxval**(3)](#maxval),\n[**minval**(3)](#minval),\n[**min**(3)](#min)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "MAXEXPONENT": "## maxexponent\n\n### **Name**\n\n**maxexponent** - \\[NUMERIC MODEL\\] Maximum exponent of a real kind\n\n### **Synopsis**\n```fortran\n    result = maxexponent(x)\n```\n```fortran\n     elemental integer function maxexponent(x)\n\n      real(kind=**),intent(in)   :: x\n```\n### **Characteristics**\n\n - **x**  is a _real_ scalar or array of any _real_ kind\n - the result is a default _integer_ scalar\n\n### **Description**\n\n  **maxexponent** returns the maximum exponent in the model of the\n  type of **x**.\n\n### **Options**\n\n- **x**\n  : A value used to select the kind of _real_ to return a value for.\n\n### **Result**\n\n  The value returned is the maximum exponent for the kind of the value\n  queried\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_maxexponent\nuse, intrinsic :: iso_fortran_env, only : real32,real64,real128\nimplicit none\ncharacter(len=*),parameter :: g='(*(g0,1x))'\n   print  g,  minexponent(0.0_real32),   maxexponent(0.0_real32)\n   print  g,  minexponent(0.0_real64),   maxexponent(0.0_real64)\n   print  g,  minexponent(0.0_real128),  maxexponent(0.0_real128)\nend program demo_maxexponent\n```\nResults:\n```text\n   -125 128\n   -1021 1024\n   -16381 16384\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**exponent**(3)](#exponent),\n[**fraction**(3)](#fraction),\n[**huge**(3)](#huge),\n[**minexponent**(3)](#minexponent),\n[**nearest**(3)](#nearest),\n[**precision**(3)](#precision),\n[**radix**(3)](#radix),\n[**range**(3)](#range),\n[**rrspacing**(3)](#rrspacing),\n[**scale**(3)](#scale),\n[**set_exponent**(3)](#set_exponent),\n[**spacing**(3)](#spacing),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "MAXLOC": "## maxloc\n\n### **Name**\n\n**maxloc** - \\[ARRAY:LOCATION\\] Location of the maximum value within an array\n\n### **Synopsis**\n```fortran\n    result = maxloc(array [,mask]) | maxloc(array [,dim] [,mask])\n```\n```fortran\n     NUMERIC function maxloc(array, dim, mask)\n\n      NUMERIC,intent(in) :: array(..)\n      integer(kind=**),intent(in),optional :: dim\n      logical(kind=**),intent(in),optional :: mask(..)\n```\n### **Characteristics**\n\n  - a kind designated as ** may be any supported kind for the type\n  - **NUMERIC** designates any intrinsic numeric type and kind.\n\n### **Description**\n\n**maxloc** determines the location of the element in the array with\nthe maximum value, or, if the **dim** argument is supplied, determines\nthe locations of the maximum element along each row of the array in the\n**dim** direction.\n\nIf **mask** is present, only the elements for which **mask**\nis _.true._ are considered. If more than one element in the array has\nthe maximum value, the location returned is that of the first such element\nin array element order.\n\nIf the array has zero size, or all of the elements\nof **mask** are .false., then the result is an array of zeroes. Similarly,\nif **dim** is supplied and all of the elements of **mask** along a given\nrow are zero, the result value for that row is zero.\n\n### **Options**\n\n- **array**\n  : Shall be an array of type _integer_, _real_, or _character_.\n\n- **dim**\n  : (Optional) Shall be a scalar of type _integer_, with a value between\n  one and the rank of **array**, inclusive. It may not be an optional\n  dummy argument.\n\n- **mask**\n  : Shall be an array of type _logical_, and conformable with **array**.\n\n### **Result**\n\nIf **dim** is absent, the result is a rank-one array with a length equal\nto the rank of **array**. If **dim** is present, the result is an array\nwith a rank one less than the rank of **array**, and a size corresponding\nto the size of **array** with the **dim** dimension removed. If **dim**\nis present and **array** has a rank of one, the result is a scalar. In\nall cases, the result is of default _integer_ type.\n\nThe value returned is reference to the offset from the beginning of the\narray, not necessarily the subscript value if the array subscripts do\nnot start with one.\n\n### **Examples**\n\nsample program\n\n```fortran\nprogram demo_maxloc\nimplicit none\ninteger      :: ii\ninteger,save :: i(-3:3)=[(abs(abs(ii)-50),ii=-3,3)]\ninteger,save :: ints(3,5)= reshape([&\n   1,  2,  3,  4,  5, &\n   10, 20, 30, 40, 50, &\n   11, 22, 33, 44, 55  &\n],shape(ints),order=[2,1])\n\n    write(*,*) maxloc(ints)\n    write(*,*) maxloc(ints,dim=1)\n    write(*,*) maxloc(ints,dim=2)\n    ! when array bounds do not start with one remember MAXLOC(3) returns\n    ! the offset relative to the lower bound-1 of the location of the\n    ! maximum value, not the subscript of the maximum value. When the\n    ! lower bound of the array is one, these values are the same. In\n    ! other words, MAXLOC(3) returns the subscript of the value assuming\n    ! the first subscript of the array is one no matter what the lower\n    ! bound of the subscript actually is.\n    write(*,'(g0,1x,g0)') (ii,i(ii),ii=lbound(i,dim=1),ubound(i,dim=1))\n    write(*,*)maxloc(i)\n\nend program demo_maxloc\n```\n\nResults:\n\n```text\n >     3       5\n >     3       3       3       3       3\n >     5       5       5\n >  -3 47\n >  -2 48\n >  -1 49\n >  0 50\n >  1 49\n >  2 48\n >  3 47\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n - [**findloc**(3)](#findloc) - Location of first element of ARRAY\n   identified by MASK along dimension DIM matching a target\n - [**minloc**(3)](#minloc) - Location of the minimum value within an array\n - [**maxval**(3)](#maxval)\n - [**minval**(3)](#minval)\n - [**max**(3)](#max)\n\n _fortran-lang intrinsic descriptions_\n",
  "MAXVAL": "## maxval\n\n### **Name**\n\n**maxval** - \\[ARRAY:REDUCTION\\] Determines the maximum value in an array or row\n\n### **Synopsis**\n```fortran\n    result = maxval(array [,mask]) | maxval(array [,dim] [,mask])\n```\n```fortran\n     NUMERIC function maxval(array ,dim, mask)\n\n      NUMERIC,intent(in) :: array(..)\n      integer(kind=**),intent(in),optional :: dim\n      logical(kind=**),intent(in),optional :: mask(..)\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n - **NUMERIC** designates any numeric type and kind.\n\n### **Description**\n\n  **maxval** determines the maximum value of the elements in an\n  array value, or, if the **dim** argument is supplied, determines the\n  maximum value along each row of the array in the **dim** direction. If\n  **mask** is present, only the elements for which **mask** is _.true._\n  are considered. If the array has zero size, or all of the elements of\n  **mask** are _.false._, then the result is the most negative number\n  of the type and kind of **array** if **array** is numeric, or a string\n  of nulls if **array** is of character type.\n\n### **Options**\n\n- **array**\n  : Shall be an array of type _integer_, _real_, or _character_.\n\n- **dim**\n  : (Optional) Shall be a scalar of type _integer_, with a value between\n  one and the rank of **array**, inclusive. It may not be an optional\n  dummy argument.\n\n- **mask**\n  : (Optional) Shall be an array of type _logical_, and conformable with\n  **array**.\n\n### **Result**\n\nIf **dim** is absent, or if **array** has a rank of one, the result is a scalar.\nIf **dim** is present, the result is an array with a rank one less than the\nrank of **array**, and a size corresponding to the size of **array** with the\n**dim** dimension removed. In all cases, the result is of the same type and\nkind as **array**.\n\n### **Examples**\n\nsample program:\n\n```fortran\nprogram demo_maxval\nimplicit none\ninteger,save :: ints(3,5)= reshape([&\n   1,  2,  3,  4,  5, &\n  10, 20, 30, 40, 50, &\n  11, 22, 33, 44, 55  &\n],shape(ints),order=[2,1])\n\n   write(*,*) maxval(ints)\n   write(*,*) maxval(ints,dim=1)\n   write(*,*) maxval(ints,dim=2)\n   ! find biggest number less than 30 with mask\n   write(*,*) maxval(ints,mask=ints.lt.30)\nend program demo_maxval\n```\nResults:\n```\n >  55\n >  11     22     33     44     55\n >   5     50     55\n >  22\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**maxloc**(3)](#maxloc),\n[**minloc**(3)](#minloc),\n[**minval**(3)](#minval),\n[**max**(3)](#max),\n[**min**(3)](#min)\n\n _fortran-lang intrinsic descriptions_\n",
  "MERGE": "## merge\n\n### **Name**\n\n**merge** - \\[ARRAY:CONSTRUCTION\\] Merge variables\n\n### **Synopsis**\n```fortran\n    result = merge(tsource, fsource, mask)\n```\n```fortran\n     elemental type(TYPE(kind=KIND)) function merge(tsource,fsource,mask)\n\n      type(TYPE(kind=KIND)),intent(in) :: tsource\n      type(TYPE(kind=KIND)),intent(in) :: fsource\n      logical(kind=**),intent(in)   :: mask\n      mask** : Shall be of type logical.\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n - **tsource** May be of any type, including user-defined.\n - **fsource** Shall be of the same type and type parameters as **tsource**.\n - **mask** shall be of type logical.\n - The result will by of the same type and type parameters as **tsource**.\n\n\n### **Description**\n\nThe elemental function **merge** selects values from two arrays or\nscalars according to a logical mask. The result is equal to an element\nof **tsource** where the corresponding element of **mask** is _.true._, or an\nelement of **fsource** when it is _.false._ .\n\nMulti-dimensional arrays are supported.\n\nNote that argument expressions to **merge** are not required to be\nshort-circuited so (as an example) if the array **x** contains zero values\nin the statement below the standard does not prevent floating point\ndivide by zero being generated; as **1.0/x** may be evaluated for all values\nof **x** before the mask is used to select which value to retain:\n\n```fortran\n      y = merge( 1.0/x, 0.0, x /= 0.0 )\n```\n\nNote the compiler is also free to short-circuit or to generate an\ninfinity so this may work in many programming environments but is not\nrecommended.\n\nFor cases like this one may instead use masked assignment via the **where**\nconstruct:\n\n```fortran\n      where(x .ne. 0.0)\n         y = 1.0/x\n      elsewhere\n         y = 0.0\n      endwhere\n```\n\ninstead of the more obscure\n\n```fortran\n      merge(1.0/merge(x,1.0,x /= 0.0), 0.0, x /= 0.0)\n```\n### **Options**\n\n- **tsource**\n  : May be of any type, including user-defined.\n\n- **fsource**\n  : Shall be of the same type and type parameters as **tsource**.\n\n- **mask**\n  : Shall be of type _logical_.\n\nNote that (currently) _character_ values must be of the same length.\n\n### **Result**\n  The result is built from an element of **tsource** if **mask** is\n  _.true._ and from **fsource** otherwise.\n\n  Because **tsource** and **fsource** are required to have the same type\n  and type parameters (for both the declared and dynamic types), the\n  result is polymorphic if and only if both **tsource** and **fsource**\n  are polymorphic.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_merge\nimplicit none\ninteger :: tvals(2,3), fvals(2,3), answer(2,3)\nlogical :: mask(2,3)\ninteger :: i\ninteger :: k\nlogical :: chooseleft\n\n   ! Works with scalars\n   k=5\n   write(*,*)merge (1.0, 0.0, k > 0)\n   k=-2\n   write(*,*)merge (1.0, 0.0, k > 0)\n\n   ! set up some simple arrays that all conform to the\n   ! same shape\n   tvals(1,:)=[  10, -60,  50 ]\n   tvals(2,:)=[ -20,  40, -60 ]\n\n   fvals(1,:)=[ 0, 3, 2 ]\n   fvals(2,:)=[ 7, 4, 8 ]\n\n   mask(1,:)=[ .true.,  .false., .true. ]\n   mask(2,:)=[ .false., .false., .true. ]\n\n   ! lets use the mask of specific values\n   write(*,*)'mask of logicals'\n   answer=merge( tvals, fvals, mask )\n   call printme()\n\n   ! more typically the mask is an expression\n   write(*, *)'highest values'\n   answer=merge( tvals, fvals, tvals > fvals )\n   call printme()\n\n   write(*, *)'lowest values'\n   answer=merge( tvals, fvals, tvals < fvals )\n   call printme()\n\n   write(*, *)'zero out negative values'\n   answer=merge( 0, tvals, tvals < 0)\n   call printme()\n\n   write(*, *)'binary choice'\n   chooseleft=.false.\n   write(*, '(3i4)')merge([1,2,3],[10,20,30],chooseleft)\n   chooseleft=.true.\n   write(*, '(3i4)')merge([1,2,3],[10,20,30],chooseleft)\n\ncontains\n\nsubroutine printme()\n      write(*, '(3i4)')(answer(i, :), i=1, size(answer, dim=1))\nend subroutine printme\n\nend program demo_merge\n```\nResults:\n```text\n >    1.00000000\n >    0.00000000\n >  mask of logicals\n >   10   3  50\n >    7   4 -60\n >  highest values\n >   10   3  50\n >    7  40   8\n >  lowest values\n >    0 -60   2\n >  -20   4 -60\n >  zero out negative values\n >   10   0  50\n >    0  40   0\n >  binary choice\n >   10  20  30\n >    1   2   3\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n- [**pack**(3)](#pack) packs an array into an array of rank one\n- [**spread**(3)](#spread) is used to add a dimension and replicate data\n- [**unpack**(3)](#unpack) scatters the elements of a vector\n- [**transpose**(3)](#transpose) - Transpose an array of rank two\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "MERGE_BITS": "## merge_bits\n\n### **Name**\n\n**merge_bits** - \\[BIT:COPY\\] Merge bits using a mask\n\n### **Synopsis**\n```fortran\n    result = merge_bits(i, j, mask)\n```\n```fortran\n     elemental integer(kind=KIND) function merge_bits(i,j,mask)\n\n      integer(kind=KIND), intent(in) :: i, j, mask\n```\n### **Characteristics**\n\n - the result and all input values have the same _integer_ type and\n   KIND with the exception that the mask and either **i** or **j** may be\n   a BOZ constant.\n\n### **Description**\n\nA common graphics operation in Ternary Raster Operations is to combine\nbits from two different sources, generally referred to as bit-blending.\n**merge_bits** performs a masked bit-blend of **i** and **j** using\nthe bits of the **mask** value to determine which of the input values\nto copy bits from.\n\nSpecifically, The k-th bit of the result is equal to the k-th bit of\n**i** if the k-th bit of **mask** is **1**; it is equal to the k-th bit\nof **j** otherwise (so all three input values must have the same number\nof bits).\n\nThe resulting value is the same as would result from\n```fortran\n    ior (iand (i, mask),iand (j, not (mask)))\n```\nAn exception to all values being of the same _integer_ type is that **i**\nor **j** and/or the mask may be a BOZ constant (A BOZ constant means it is\neither a Binary, Octal, or Hexadecimal literal constant). The BOZ values\nare converted to the _integer_ type of the non-BOZ value(s) as if called\nby the intrinsic function **int()** with the kind of the non-BOZ value(s),\nso the BOZ values must be in the range of the type of the result.\n\n### **Options**\n\n- **i**\n  : value to select bits from when the associated bit in the mask is **1**.\n\n- **j**\n  : value to select bits from when the associated bit in the mask is **0**.\n\n- **mask**\n  : a value whose bits are used as a mask to select bits from **i** and **j**\n\n### **Result**\n\nThe bits blended from **i** and **j** using the mask **mask**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_merge_bits\nuse,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64\nimplicit none\ninteger(kind=int16) :: if_one,if_zero,msk\ncharacter(len=*),parameter :: fmt='(*(g0, 1X))'\n\n   ! basic usage\n   print *,'MERGE_BITS( 5,10,41) should be 3.=>',merge_bits(5,10,41)\n   print *,'MERGE_BITS(13,18,22) should be 4.=>',merge_bits(13,18,22)\n\n   ! use some values in base2 illustratively:\n   if_one =int(b'1010101010101010',kind=int16)\n   if_zero=int(b'0101010101010101',kind=int16)\n\n   msk=int(b'0101010101010101',kind=int16)\n   print '(\"should get all zero bits =>\",b16.16)', &\n   & merge_bits(if_one,if_zero,msk)\n\n   msk=int(b'1010101010101010',kind=int16)\n   print '(\"should get all ones bits =>\",b16.16)', &\n   & merge_bits(if_one,if_zero,msk)\n\n   ! using BOZ values\n   print fmt, &\n   & merge_bits(32767_int16,    o'12345',         32767_int16), &\n   & merge_bits(o'12345', 32767_int16, b'0000000000010101'), &\n   & merge_bits(32767_int16,    o'12345',             z'1234')\n\n   ! a do-it-yourself equivalent for comparison and validation\n   print fmt, &\n   & ior(iand(32767_int16, 32767_int16),                   &\n   &   iand(o'12345', not(32767_int16))),                  &\n\n   & ior(iand(o'12345', int(o'12345', kind=int16)),        &\n   &   iand(32767_int16, not(int(o'12345', kind=int16)))), &\n\n   & ior(iand(32767_int16, z'1234'),                       &\n   &   iand(o'12345', not(int( z'1234', kind=int16))))\n\nend program demo_merge_bits\n```\nResults:\n```text\n    MERGE_BITS( 5,10,41) should be 3.=>           3\n    MERGE_BITS(13,18,22) should be 4.=>           4\n   should get all zero bits =>0000000000000000\n   should get all ones bits =>1111111111111111\n   32767 32751 5877\n   32767 32767 5877\n```\n### **Standard**\n\nFortran 2008\n\n### **See also**\n\n[****(3)](#)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "MIN": "## min\n\n### **Name**\n\n**min** - \\[NUMERIC\\] Minimum value of an argument list\n\n### **Synopsis**\n```fortran\n    result = min(a1, a2, a3, ... )\n```\n```fortran\n     elemental TYPE(kind=KIND) function min(a1, a2, a3, ... )\n\n      TYPE(kind=KIND,intent(in)   :: a1\n      TYPE(kind=KIND,intent(in)   :: a2\n      TYPE(kind=KIND,intent(in)   :: a3\n                :\n                :\n                :\n```\n### **Characteristics**\n\n- **TYPE** may be _integer_, _real_ or _character_.\n\n### **Description**\n\n**min** returns the argument with the smallest (most negative) value.\n\nSee **max**(3) for an extended example of the behavior of **min** as\nand **max**(3).\n\n### **Options**\n\n- **a1**\n  : the first element of the set of values to determine the minimum of.\n\n- **a2, a3, ...**\n  : An expression of the same type and kind as **a1** completing the\n  set of values to find the minimum of.\n\n### **Result**\n\nThe return value corresponds to the minimum value among the arguments,\nand has the same type and kind as the first argument.\n\n### **Examples**\n\nSample program\n```fortran\nprogram demo_min\nimplicit none\n    write(*,*)min(10.0,11.0,30.0,-100.0)\nend program demo_min\n```\nResults:\n```\n      -100.0000000\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n[**maxloc**(3)](#maxloc),\n[**minloc**(3)](#minloc),\n[**minval**(3)](#minval),\n[**max**(3)](#max),\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "MINEXPONENT": "## minexponent\n\n### **Name**\n\n**minexponent** - \\[NUMERIC MODEL\\] Minimum exponent of a real kind\n\n### **Synopsis**\n```fortran\n    result = minexponent(x)\n```\n```fortran\n     elemental integer function minexponent(x)\n\n      real(kind=**),intent(in) :: x\n```\n### **Characteristics**\n\n - **x**  is a _real_ scalar or array of any _real_ kind\n - the result is a default _integer_ scalar\n\n### **Description**\n\n  **minexponent** returns the minimum exponent in the model of the\n  type of **x**.\n\n### **Options**\n\n- **x**\n  : A value used to select the kind of _real_ to return a value for.\n\n### **Result**\n\n  The value returned is the maximum exponent for the kind of the value\n  queried\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_minexponent\nuse, intrinsic :: iso_fortran_env, only : &\n &real_kinds, real32, real64, real128\nimplicit none\nreal(kind=real32) :: x\nreal(kind=real64) :: y\n    print *, minexponent(x), maxexponent(x)\n    print *, minexponent(y), maxexponent(y)\nend program demo_minexponent\n```\nExpected Results:\n```\n        -125         128\n       -1021        1024\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**exponent**(3)](#exponent),\n[**fraction**(3)](#fraction),\n[**huge**(3)](#huge),\n[**maxexponent**(3)](#maxexponent),\n[**nearest**(3)](#nearest),\n[**precision**(3)](#precision),\n[**radix**(3)](#radix),\n[**range**(3)](#range),\n[**rrspacing**(3)](#rrspacing),\n[**scale**(3)](#scale),\n[**set_exponent**(3)](#set_exponent),\n[**spacing**(3)](#spacing),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "MINLOC": "## minloc\n\n### **Name**\n\n**minloc** - \\[ARRAY:LOCATION\\] Location of the minimum value within an array\n\n### **Synopsis**\n```fortran\n    result = minloc(array [,mask]) | minloc(array [,dim] [,mask])\n```\n```fortran\n     NUMERIC function minloc(array, dim, mask)\n\n      NUMERIC,intent(in) :: array(..)\n      integer(kind=**),intent(in),optional :: dim\n      logical(kind=**),intent(in),optional :: mask(..)\n```\n### **Characteristics**\n\n  - a kind designated as ** may be any supported kind for the type\n  - **NUMERIC** is any numeric type and kind.\n\n### **Description**\n\n  **minloc** determines the location of the element in the array with\n  the minimum value, or, if the **dim** argument is supplied, determines\n  the locations of the minimum element along each row of the array in\n  the **dim** direction.\n\n  If **mask** is present, only the elements for which **mask** is _true._\n  are considered.\n\n  If more than one element in the array has the minimum value, the\n  location returned is that of the first such element in array element\n  order.\n\n  If the array has zero size, or all of the elements of **mask** are\n  _.false._, then the result is an array of zeroes. Similarly, if **dim**\n  is supplied and all of the elements of **mask** along a given row are\n  zero, the result value for that row is zero.\n\n### **Options**\n\n- **array**\n  : Shall be an array of type _integer_, _real_, or _character_.\n\n- **dim**\n  : (Optional) Shall be a scalar of type _integer_, with a value between\n  one and the rank of **array**, inclusive. It may not be an optional\n  dummy argument.\n\n- **mask**\n  : Shall be an array of type _logical_, and conformable with **array**.\n\n### **Result**\n\nIf **dim** is absent, the result is a rank-one array with a length equal\nto the rank of **array**. If **dim** is present, the result is an array\nwith a rank one less than the rank of **array**, and a size corresponding\nto the size of **array** with the **dim** dimension removed. If **dim**\nis present and **array** has a rank of one, the result is a scalar. In\nall cases, the result is of default _integer_ type.\n\n### **Examples**\n\nsample program:\n\n```fortran\nprogram demo_minloc\nimplicit none\ninteger,save :: ints(3,5)= reshape([&\n   4, 10,  1,  7, 13, &\n   9, 15,  6, 12,  3, &\n  14,  5, 11,  2,  8  &\n],shape(ints),order=[2,1])\n   write(*,*) minloc(ints)\n   write(*,*) minloc(ints,dim=1)\n   write(*,*) minloc(ints,dim=2)\n   ! where in each column is the smallest number .gt. 10 ?\n   write(*,*) minloc(ints,dim=2,mask=ints.gt.10)\n   ! a one-dimensional array with dim=1 explicitly listed returns a scalar\n   write(*,*) minloc(pack(ints,.true.),dim=1) ! scalar\nend program demo_minloc\n```\nResults:\n```text\n >        1       3\n >        1       3       1       3       2\n >        3       5       4\n >        5       4       3\n >        7\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n - [**findloc**(3)](#findloc) - Location of first element of ARRAY\n   identified by MASK along dimension DIM matching a target\n - [**maxloc**(3)](#maxloc) - Location of the maximum value within an array\n - [**minloc**](#minloc) - Location of the minimum value within an array\n - [**min**(3)](#min)\n - [**minval**(3)](#minval)\n - [**maxval**(3)](#maxval)\n - [**max**(3)](#max)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "MINVAL": "## minval\n\n### **Name**\n\n**minval** - \\[ARRAY:REDUCTION\\] Minimum value of an array\n\n### **Synopsis**\n```fortran\n    result = minval(array, [mask]) | minval(array [,dim] [,mask])\n```\n```fortran\n     NUMERIC function minval(array, dim, mask)\n\n      NUMERIC,intent(in) :: array(..)\n      integer(kind=**),intent(in),optional :: dim\n      logical(kind=**),intent(in),optional :: mask(..)\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n - **NUMERIC** is any numeric type and kind.\n\n### **Description**\n\n  **minval** determines the minimum value of the elements in an array\n  value, or, if the **dim** argument is supplied, determines the minimum\n  value along each row of the array in the **dim** direction.\n\n  If **mask** is present, only the elements for which **mask** is\n  _.true._ are considered.\n\n  If the array has zero size, or all of the elements of **mask**\n  are _.false._, then the result is **huge(array)** if **array** is\n  numeric, or a string of **char(len=255)** characters if **array**\n  is of character type.\n\n### **Options**\n\n- **array**\n  : Shall be an array of type _integer_, _real_, or _character_.\n\n- **dim**\n  : (Optional) Shall be a scalar of type _integer_, with a value between\n  one and the rank of ARRAY, inclusive. It may not be an optional\n  dummy argument.\n\n- **mask**\n  : Shall be an array of type _logical_, and conformable with **array**.\n\n### **Result**\n\nIf **dim** is absent, or if **array** has a rank of one, the result is a scalar.\n\nIf **dim** is present, the result is an array with a rank one less than the\nrank of **array**, and a size corresponding to the size of **array** with the\n**dim** dimension removed. In all cases, the result is of the same type and\nkind as **array**.\n\n### **Examples**\n\nsample program:\n```fortran\nprogram demo_minval\nimplicit none\ninteger :: i\ncharacter(len=*),parameter :: g='(3x,*(g0,1x))'\n\ninteger,save :: ints(3,5)= reshape([&\n       1,  -2,   3,   4,   5,  &\n      10,  20, -30,  40,  50,  &\n      11,  22,  33, -44,  55  &\n],shape(ints),order=[2,1])\n\ninteger,save :: box(3,5,2)\n\n   box(:,:,1)=ints\n   box(:,:,2)=-ints\n\n   write(*,*)'Given the array'\n   write(*,'(1x,*(g4.4,1x))') &\n   & (ints(i,:),new_line('a'),i=1,size(ints,dim=1))\n\n   write(*,*)'What is the smallest element in the array?'\n   write(*,g) minval(ints),'at <',minloc(ints),'>'\n\n   write(*,*)'What is the smallest element in each column?'\n   write(*,g) minval(ints,dim=1)\n\n   write(*,*)'What is the smallest element in each row?'\n   write(*,g) minval(ints,dim=2)\n\n   ! notice the shape of the output has less columns\n   ! than the input in this case\n   write(*,*)'What is the smallest element in each column,'\n   write(*,*)'considering only those elements that are'\n   write(*,*)'greater than zero?'\n   write(*,g) minval(ints, dim=1, mask = ints > 0)\n\n   write(*,*)&\n   & 'if everything is false a zero-sized array is NOT returned'\n   write(*,*) minval(ints, dim=1, mask = .false.)\n   write(*,*)'even for a zero-sized input'\n   write(*,g) minval([integer ::], dim=1, mask = .false.)\n\n   write(*,*)'a scalar answer for everything false is huge()'\n   write(*,g) minval(ints, mask = .false.)\n   write(*,g) minval([integer ::], mask = .false.)\n\n   write(*,*)'some calls with three dimensions'\n   write(*,g) minval(box, mask = .true. )\n   write(*,g) minval(box, dim=1, mask = .true. )\n\n   write(*,g) minval(box, dim=2, mask = .true. )\n   write(*,g) 'shape of answer is ', &\n   & shape(minval(box, dim=2, mask = .true. ))\n\nend program demo_minval\n```\nResults:\n```text\n > Given the array\n >    1   -2    3    4    5\n >   10   20  -30   40   50\n >   11   22   33  -44   55\n >\n > What is the smallest element in the array?\n >   -44 at < 3 4 >\n > What is the smallest element in each column?\n >   1 -2 -30 -44 5\n > What is the smallest element in each row?\n >   -2 -30 -44\n > What is the smallest element in each column,\n > considering only those elements that are\n > greater than zero?\n >   1 20 3 4 5\n > if everything is false a zero-sized array is NOT returned\n >  2147483647  2147483647  2147483647  2147483647  2147483647\n > even for a zero-sized input\n >   2147483647\n > a scalar answer for everything false is huge()\n >   2147483647\n >   2147483647\n > some calls with three dimensions\n >   -55\n >   1 -2 -30 -44 5 -11 -22 -33 -40 -55\n >   -2 -30 -44 -5 -50 -55\n >   shape of answer is  3 2\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**min**(3)](#min),\n[**minloc**(3)](#minloc)\n[**maxloc**(3)](#maxloc),\n[**maxval**(3)](#maxval),\n[**min**(3)](#min)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "MOD": "## mod\n\n### **Name**\n\n**mod** - \\[NUMERIC\\] Remainder function\n\n### **Synopsis**\n```fortran\n    result = mod(a, p)\n```\n```fortran\n     elemental type(TYPE(kind=KIND)) function mod(a,p)\n\n      type(TYPE(kind=KIND)),intent(in) :: a\n      type(TYPE(kind=KIND)),intent(in) :: p\n```\n### **Characteristics**\n\n  - The result and arguments are all of the same type and kind.\n  - The type  may be any kind of _real_ or _integer_.\n\n### **Description**\n\n**mod** computes the remainder of the division of **a** by **p**.\n\n  In mathematics, the remainder is the amount \"left over\" after\n  performing some computation. In arithmetic, the remainder is the\n  integer \"left over\" after dividing one integer by another to produce\n  an integer quotient (integer division). In algebra of polynomials, the\n  remainder is the polynomial \"left over\" after dividing one polynomial\n  by another. The modulo operation is the operation that produces such\n  a remainder when given a dividend and divisor.\n\n  - (remainder). (2022, October 10). In Wikipedia.\n     https://en.wikipedia.org/wiki/Remainder\n\n### **Options**\n\n- **a**\n  : The dividend\n\n- **p**\n  : the divisor (not equal to zero).\n\n### **Result**\n\n  The return value is the result of **a - (int(a/p) \\* p)**.\n\n  As can be seen by the formula the sign of **p** is canceled out.\n  Therefore the returned value always has the sign of **a**.\n\n  Of course, the magnitude of the result will be less than the magnitude\n  of **p**, as the result has been reduced by all multiples of **p**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_mod\nimplicit none\n\n   ! basics\n    print *, mod( -17,  3 ), modulo( -17,  3 )\n    print *, mod(  17, -3 ), modulo(  17, -3 )\n    print *, mod(  17,  3 ), modulo(  17,  3 )\n    print *, mod( -17, -3 ), modulo( -17, -3 )\n\n    print *, mod(-17.5, 5.2), modulo(-17.5, 5.2)\n    print *, mod( 17.5,-5.2), modulo( 17.5,-5.2)\n    print *, mod( 17.5, 5.2), modulo( 17.5, 5.2)\n    print *, mod(-17.5,-5.2), modulo(-17.5,-5.2)\n\n  ! with a divisor of 1 the fractional part is returned\n    print *, mod(-17.5, 1.0), modulo(-17.5, 1.0)\n    print *, mod( 17.5,-1.0), modulo( 17.5,-1.0)\n    print *, mod( 17.5, 1.0), modulo( 17.5, 1.0)\n    print *, mod(-17.5,-1.0), modulo(-17.5,-1.0)\n\nend program demo_mod\n```\nResults:\n```text\n             -2           1\n              2          -1\n              2           2\n             -2          -2\n     -1.900001       3.299999\n      1.900001      -3.299999\n      1.900001       1.900001\n     -1.900001      -1.900001\n    -0.5000000      0.5000000\n     0.5000000     -0.5000000\n     0.5000000      0.5000000\n    -0.5000000     -0.5000000\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n - [**modulo**(3)](#modulo) - Modulo function\n - [**aint**(3)](#aint) - truncate toward zero to a whole _real_ number\n - [**int**(3)](#int) - truncate toward zero to a whole _integer_ number\n - [**anint**(3)](#anint) -  _real_ nearest whole number\n - [**nint**(3)](#nint) - _integer_ nearest whole number\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "MODULO": "## modulo\n\n### **Name**\n\n**modulo** - \\[NUMERIC\\] Modulo function\n\n### **Synopsis**\n```fortran\n    result = modulo(a, p)\n```\n```fortran\n     elemental TYPE(kind=KIND) function modulo(a,p)\n\n      TYPE(kind=KIND),intent(in) :: a\n      TYPE(kind=KIND),intent(in) :: p\n```\n### **Characteristics**\n\n  - **a** may be any kind of _real_ or _integer_.\n  - **p** is the same type and kind as **a**\n  - The result and arguments are all of the same type and kind.\n\n### **Description**\n\n**modulo** computes the **a** modulo **p**.\n\n### **Options**\n\n- **a**\n  : the value to take the **modulo** of\n\n- **p**\n  : The value to reduce **a** by till the remainder is <= **p**.\n    It shall not be zero.\n\n### **Result**\n\nThe type and kind of the result are those of the arguments.\n\n- If **a** and **p** are of type _integer_: **modulo(a,p)** has the value of\n  **a - floor (real(a) / real(p)) \\* p**.\n\n- If **a** and **p** are of type _real_: **modulo(a,p)** has the value of\n  **a - floor (a / p) \\* p**.\n\nThe returned value has the same sign as **p** and a magnitude less than the\nmagnitude of **p**.\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_modulo\nimplicit none\n     print *, modulo(17,3)        ! yields 2\n     print *, modulo(17.5,5.5)    ! yields 1.0\n\n     print *, modulo(-17,3)       ! yields 1\n     print *, modulo(-17.5,5.5)   ! yields 4.5\n\n     print *, modulo(17,-3)       ! yields -1\n     print *, modulo(17.5,-5.5)   ! yields -4.5\nend program demo_modulo\n```\nResults:\n```text\n >            2\n >    1.000000\n >            1\n >    4.500000\n >           -1\n >   -4.500000\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**mod**(3)](#mod)\n\n _fortran-lang intrinsic descriptions_\n",
  "MOVE_ALLOC": "## move_alloc\n\n### **Name**\n\n**move_alloc** - \\[MEMORY\\] Move allocation from one object to another\n\n### **Synopsis**\n```fortran\n    call move_alloc(from, to [,stat] [,errmsg] )\n```\n```fortran\n     subroutine move_alloc(from, to)\n\n      type(TYPE(kind=**)),intent(inout),allocatable :: from(..)\n      type(TYPE(kind=**)),intent(out),allocatable   :: to(..)\n      integer(kind=**),intent(out)   :: stat\n      character(len=*),intent(inout) :: errmsg\n```\n### **Characteristics**\n\n- **from** may be of any type and kind.\n- **to** shall be of the same type, kind and rank as **from**.\n\n### **Description**\n\n**move_alloc** moves the allocation from **from** to\n**to**. **from** will become deallocated in the process.\n\nThis is potentially more efficient than other methods of assigning\nthe values in **from** to **to** and explicitly deallocating **from**,\nwhich are far more likely to require a temporary object or a copy of\nthe elements of the array.\n\n### **Options**\n\n- **from**\n  : The data object to be moved to **to** and deallocated.\n\n- **to**\n  : The destination data object to move the allocated data object **from**\n  to. Typically, it is a different shape than **from**.\n\n- **stat**\n  : If **stat** is present and execution is successful, it is assigned the\n    value zero.\n  : If an error condition occurs,\n\n      o if **stat** is absent, error termination is initiated;\n      o otherwise, if **from** is a coarray and the current team contains a\n        stopped image, **stat** is assigned the value STAT\\_STOPPED\\_IMAGE\n        from the intrinsic module ISO\\_FORTRAN\\_ENV;\n      o otherwise, if **from** is a coarray and the current team contains\n      a failed image, and no other error condition\n        occurs, **stat** is assigned the value STAT\\_FAILED\\_IMAGE from the\n        intrinsic module ISO\\_FORTRAN\\_ENV;\n      o otherwise, **stat** is assigned a processor-dependent positive value\n        that differs from that of STAT\\_STOPPED\\_IMAGE or STAT\\_FAILED\\_IMAGE.\n\n- **errmsg**\n  : If the **errmsg** argument is present and an error condition occurs,\n    it is assigned an explanatory message. If no error condition occurs,\n    the definition status and value of **errmsg** are unchanged.\n\n### **Examples**\n\nBasic sample program to allocate a bigger grid\n\n```fortran\nprogram demo_move_alloc\nimplicit none\n! Example to allocate a bigger GRID\nreal, allocatable :: grid(:), tempgrid(:)\ninteger :: n, i\n\n   ! initialize small GRID\n   n = 3\n   allocate (grid(1:n))\n   grid = [ (real (i), i=1,n) ]\n\n   ! initialize TEMPGRID which will be used to replace GRID\n   allocate (tempgrid(1:2*n))    ! Allocate bigger grid\n   tempgrid(::2)  = grid         ! Distribute values to new locations\n   tempgrid(2::2) = grid + 0.5   ! initialize other values\n\n   ! move TEMPGRID to GRID\n   call MOVE_ALLOC (from=tempgrid, to=grid)\n\n   ! TEMPGRID should no longer be allocated\n   ! and GRID should be the size TEMPGRID was\n   if (size (grid) /= 2*n .or. allocated (tempgrid)) then\n      print *, \"Failure in move_alloc!\"\n   endif\n   print *, allocated(grid), allocated(tempgrid)\n   print '(99f8.3)', grid\nend program demo_move_alloc\n```\n\nResults:\n\n```text\n    T F\n      1.000   1.500   2.000   2.500   3.000   3.500\n```\n\n### **Standard**\n\nFortran 2003, STAT and ERRMSG options added 2018\n\n### **See Also**\n\n[**allocated**(3)](#allocated)\n\n _fortran-lang intrinsic descriptions_\n<!--\n    35  2 Class. Subroutine, pure if and only if FROM is not a coarray.\n    1   3 Arguments.\n    2     FROM      may be of any type, rank, and corank. It shall be allocatable and shall not be a coindexed object.\n    3               It is an INTENT (INOUT) argument.\n    4     TO        shall be type compatible (7.3.2.3) with FROM and have the same rank and corank. It shall be\n    5               allocatable and shall not be a coindexed object. It shall be polymorphic if FROM is polymorphic.\n    6               It is an INTENT (OUT) argument. Each nondeferred parameter of the declared type of TO shall\n    7               have the same value as the corresponding parameter of the declared type of FROM.\n    8     STAT (optional) shall be a noncoindexed integer scalar with a decimal exponent range of at least four. It is an\n    9               INTENT (OUT) argument.\n    10    ERRMSG(optional) shall be a noncoindexed default character scalar. It is an INTENT (INOUT) argument.\n\n    11  4 If execution of MOVE_ALLOC is successful, or if STAT_FAILED_IMAGE is assigned to STAT,\n    12          On invocation of MOVE_ALLOC, if the allocation status of TO is allocated, it is deallocated. Then,\n    13        if FROM has an allocation status of allocated on entry to MOVE_ALLOC, TO becomes allocated with\n    14        dynamic type, type parameters, bounds, cobounds, and value identical to those that FROM had on entry\n    15        to MOVE_ALLOC. Note that if FROM and TO are the same variable, it shall be unallocated when\n    16        MOVE_ALLOC is invoked.\n    17          If TO has the TARGET attribute, any pointer associated with FROM on entry to MOVE_ALLOC becomes\n    18        correspondingly associated with TO. If TO does not have the TARGET attribute, the pointer association\n    19        status of any pointer associated with FROM on entry becomes undefined.\n    20          The allocation status of FROM becomes unallocated.\n    21  5 When a reference to MOVE_ALLOC is executed for which the FROM argument is a coarray, there is an implicit\n    22    synchronization of all active images of the current team. On those images, execution of the segment (11.6.2)\n    23    following the CALL statement is delayed until all other active images of the current team have executed the same\n    24    statement the same number of times. When such a reference is executed, if any image of the current team has\n    25    stopped or failed, an error condition occurs.\n    38  9 Example. The example below demonstrates reallocation of GRID to twice its previous size, with its previous\n    39    contents evenly distributed over the new elements so that intermediate points can be inserted.\n    40          REAL,ALLOCATABLE :: GRID(:),TEMPGRID(:)\n    41          . . .\n    42          ALLOCATE(GRID(-N:N))   ! initial allocation of GRID\n    43          . . .\n    44          ALLOCATE(TEMPGRID(-2*N:2*N)) ! allocate bigger grid\n    45          TEMPGRID(::2)=GRID ! distribute values to new locations\n    46          CALL MOVE_ALLOC(TO=GRID,FROM=TEMPGRID)\n     1      The old grid is deallocated because TO is INTENT (OUT), and GRID then takes over the new grid allocation.\n                NOTE1\n                It is expected that the implementation of allocatable objects will typically involve descriptors to locate the\n                allocated storage; MOVE_ALLOC could then be implemented by transferring the contents of the descriptor\n                for FROM to the descriptor for TO and clearing the descriptor for FROM.\n-->\n",
  "MVBITS": "## mvbits\n\n### **Name**\n\n**mvbits** - \\[BIT:COPY\\] Reproduce bit patterns found in one integer in another\n\n### **Synopsis**\n```fortran\n   call mvbits(from, frompos, len, to, topos)\n```\n```fortran\n    elemental subroutine mvbits( from, frompos, len, to, topos )\n\n     integer(kind=KIND),intent(in)    :: from\n     integer(kind=**),intent(in)      :: frompos\n     integer(kind=**),intent(in)      :: len\n     integer(kind=KIND),intent(inout) :: to\n     integer(kind=**),intent(in)      :: topos\n```\n### **Characteristics**\n\n - **from** is an _integer_\n - **frompos** is an integer\n - **len** is an integer\n - **to** is an integer of the same kind as **from**.\n - **topos** is an integer\n\n### **Description**\n\n**mvbits** copies a bit pattern found in a range of adjacent bits in\nthe _integer_ **from** to a specified position in another integer **to**\n(which is of the same kind as **from**). It otherwise leaves the bits\nin **to** as-is.\n\nThe bit positions copied must exist within the value of **from**.\nThat is, the values of **frompos+len-1** and **topos+len-1** must be\nnonnegative and less than **bit_size**(from).\n\nThe bits are numbered **0** to **bit_size(i)-1**, from right to left.\n\n### **Options**\n\n- **from**\n  : An _integer_ to read bits from.\n\n- **frompos**\n  : **frompos** is the position of the first bit to copy. It is a\n  nonnegative _integer_ value < **bit_size(from)**.\n\n- **len**\n  : A nonnegative _integer_ value that indicates how many bits to\n  copy from **from**. It must not specify copying bits past the end\n  of **from**. That is, **frompos + len** must be less than or equal\n  to **bit_size(from)**.\n\n- **to**\n  : The _integer_ variable to place the copied bits into. It must\n  be of the same kind as **from** and may even be the same variable\n  as **from**, or associated to it.\n\n  **to** is set by copying the sequence of bits of length **len**,\n  starting at position **frompos** of **from** to position **topos** of\n  **to**. No other bits of **to** are altered. On return, the **len**\n  bits of **to** starting at **topos** are equal to the value that\n  the **len** bits of **from** starting at **frompos** had on entry.\n\n- **topos**\n  : A nonnegative _integer_ value indicating the starting location in\n  **to** to place the specified copy of bits from **from**.\n  **topos + len** must be less than or equal to **bit_size(to)**.\n\n### **Examples**\n\nSample program that populates a new 32-bit integer with its bytes\nin reverse order from the input value (ie. changes the Endian of the integer).\n```fortran\nprogram demo_mvbits\nuse,intrinsic :: iso_fortran_env,  only : int8, int16, int32, int64\nimplicit none\ninteger(kind=int32) :: intfrom, intto, abcd_int\ncharacter(len=*),parameter :: bits= '(g0,t30,b32.32)'\ncharacter(len=*),parameter :: fmt= '(g0,t30,a,t40,b32.32)'\n\n    intfrom=huge(0)  ! all bits are 1 accept the sign bit\n    intto=0          ! all bits are 0\n\n    !! CHANGE BIT 0\n    ! show the value and bit pattern\n    write(*,bits)intfrom,intfrom\n    write(*,bits)intto,intto\n\n    ! copy bit 0 from intfrom to intto to show the rightmost bit changes\n    !          (from,    frompos, len,    to, topos)\n    call mvbits(intfrom,       0,   1, intto,     0) ! change bit 0\n    write(*,bits)intto,intto\n\n    !! COPY PART OF A VALUE TO ITSELF\n    ! can copy bit from a value to itself\n    call mvbits(intfrom,0,1,intfrom,31)\n    write(*,bits)intfrom,intfrom\n\n    !! MOVING BYTES AT A TIME\n    ! make native integer value with bit patterns\n    ! that happen to be the same as the beginning of the alphabet\n    ! to make it easy to see the bytes are reversed\n    abcd_int=transfer('abcd',0)\n    ! show the value and bit pattern\n    write(*,*)'native'\n    write(*,fmt)abcd_int,abcd_int,abcd_int\n\n    ! change endian of the value\n    abcd_int=int_swap32(abcd_int)\n    ! show the values and their bit pattern\n    write(*,*)'non-native'\n    write(*,fmt)abcd_int,abcd_int,abcd_int\n\n contains\n\n pure elemental function int_swap32(intin) result(intout)\n ! Convert a 32 bit integer from big Endian to little Endian,\n ! or conversely from little Endian to big Endian.\n !\n integer(kind=int32), intent(in)  :: intin\n integer(kind=int32) :: intout\n    ! copy bytes from input value to new position in output value\n    !          (from,  frompos, len,     to, topos)\n    call mvbits(intin,       0,   8, intout,    24) ! byte1 to byte4\n    call mvbits(intin,       8,   8, intout,    16) ! byte2 to byte3\n    call mvbits(intin,      16,   8, intout,     8) ! byte3 to byte2\n    call mvbits(intin,      24,   8, intout,     0) ! byte4 to byte1\n end function int_swap32\n\n end program demo_mvbits\n```\nResults:\n```text\n\n   2147483647                   01111111111111111111111111111111\n   0                            00000000000000000000000000000000\n   1                            00000000000000000000000000000001\n   -1                           11111111111111111111111111111111\n    native\n   1684234849                   abcd      01100100011000110110001001100001\n    non-native\n   1633837924                   dcba      01100001011000100110001101100100\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**btest**(3)](#btest),\n[**iand**(3)](#iand),\n[**ibclr**(3)](#ibclr),\n[**ibits**(3)](#ibits),\n[**ibset**(3)](#ibset),\n[**ieor**(3)](#ieor),\n[**ior**(3)](#ior),\n[**not**(3)](#not)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "NEAREST": "## nearest\n\n### **Name**\n\n**nearest** - \\[MODEL_COMPONENTS\\] Nearest representable number\n\n### **Synopsis**\n```fortran\n    result = nearest(x, s)\n```\n```fortran\n     elemental real(kind=KIND) function nearest(x,s)\n\n      real(kind=KIND),intent(in) :: x\n      real(kind=**),intent(in) :: s\n```\n### **Characteristics**\n\n- **x** may be a _real_ value of any kind.\n- **s** may be a _real_ value of any kind.\n- The return value is of the same type and kind as **x**.\n- a kind designated as ** may be any supported kind for the type\n\n### **Description**\n\n**nearest** returns the processor-representable number nearest to\n**x** in the direction indicated by the sign of **s**.\n\n### **Options**\n\n- **x**\n  : the value to find the nearest representable value of\n\n- **s**\n  : a non-zero value whose sign is used to determine the direction in\n  which to search from **x** to the representable value.\n\n  If **s** is positive, **nearest** returns the processor-representable\n  number greater than **x** and nearest to it.\n\n  If **s** is negative, **nearest** returns the processor-representable\n  number smaller than **x** and nearest to it.\n\n### **Result**\n\nThe return value is of the same type as **x**. If **s** is positive, **nearest**\nreturns the processor-representable number greater than **x** and nearest to\nit. If **s** is negative, **nearest** returns the processor-representable number\nsmaller than **x** and nearest to it.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_nearest\nimplicit none\n\n   real :: x, y\n   x = nearest(42.0, 1.0)\n   y = nearest(42.0, -1.0)\n   write (*,\"(3(g20.15))\") x, y, x - y\n\n!  write (*,\"(3(g20.15))\") &\n!   nearest(tiny(0.0),1.0), &\n!   nearest(tiny(0.0),-1.0), &\n!   nearest(tiny(0.0),1.0) -nearest(tiny(0.0),-1.0)\n\n!  write (*,\"(3(g20.15))\") &\n!   nearest(huge(0.0),1.0), &\n!   nearest(huge(0.0),-1.0), &\n!   nearest(huge(0.0),1.0)- nearest(huge(0.0),-1.0)\n\nend program demo_nearest\n```\nResults:\n```text\n   42.0000038146973    41.9999961853027    .762939453125000E-05\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**exponent**(3)](#exponent),\n[**fraction**(3)](#fraction),\n[**huge**(3)](#huge),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**precision**(3)](#precision),\n[**radix**(3)](#radix),\n[**range**(3)](#range),\n[**rrspacing**(3)](#rrspacing),\n[**scale**(3)](#scale),\n[**set_exponent**(3)](#set_exponent),\n[**spacing**(3)](#spacing),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions_\n",
  "NEW_LINE": "## new_line\n\n### **Name**\n\n**new_line** - \\[CHARACTER:INQUIRY\\] Newline character\n\n### **Synopsis**\n```fortran\n    result = new_line(c)\n```\n```fortran\n     character(len=1,kind=KIND) function new_line(c)\n\n      character(len=1,kind=KIND),intent(in) :: c(..)\n```\n### **Characteristics**\n\n - **c** shall be of type _character_. It may be a scalar or an array.\n - the result is a _character_ scalar of length one with the same kind type parameter as **c**.\n\n### **Description**\n\n**new_line** returns the newline character.\n\nNormally, newlines are generated with regular formatted I/O statements like\nWRITE() and PRINT() when each statement completes:\n```fortran\n   print *, 'x=11'\n   print *\n   print *, 'y=22'\n   end\n```\nproduces:\n    x=11\n\n    y=22\n```\nAlternatively, a \"/\" descriptor in a format is used to generate a\nnewline on the output. For example:\n```fortran\n   write(*,'(a,1x,i0,/,a)') 'x =',11,'is the answer'\n   end\n```\nproduces:\n```text\n   x = 11\n   is the answer\n```\nAlso, for formatted sequential output if more data is listed on the\noutput statement than can be represented by the format statement a\nnewline is generated and then the format is reused until the output\nlist is exhausted.\n```fortran\n   write(*,'(a,\"=\",i0)') 'x', 10, 'y', 20\n   end\n```\nproduces\n```text\n   x=10\n   y=20\n```\nBut there are occasions, particularly when non-advancing I/O or stream\nI/O is being generated (which does not generate a newline at the end\nof each WRITE statement, as normally occurs) where it is preferable to\nplace a newline explicitly in the output at specified points.\n\nTo do so you must make sure you are generating the correct newline\ncharacter, which the techniques above do automatically.\n\nThe newline character varies between some platforms, and can even\ndepend on the encoding (ie. which character set is being used) of the\noutput file. In these cases selecting the correct character to output\ncan be determined by the **new_line** procedure.\n\n### **Options**\n\n- **c**\n  : an arbitrary character whose kind is used to decide on the output\n  character that represents a newline.\n\n### **Result**\n\nCase (i)\n  : If **a** is default _character_ and the character in position **10**\n  of the ASCII collating sequence is representable in the default\n  character set, then the result is **achar(10)**.\n\n  This is the typical case, and just requires using \"new_line('a')\".\n\nCase (ii)\n  : If **a** is an ASCII character or an ISO 10646 character, then the\n  result is **char(10, kind (a))**.\n\nCase (iii)\n  : Otherwise, the result is a processor-dependent character that\n  represents a newline in output to files connected for formatted\n  stream output if there is such a character.\n\nCase (iv)\n  : If not of the previous cases apply, the result is the blank character.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_new_line\nimplicit none\ncharacter,parameter :: nl=new_line('a')\ncharacter(len=:),allocatable :: string\nreal :: r\ninteger :: i, count\n\n  ! basics\n   ! print a string with a newline embedded in it\n   string='This is record 1.'//nl//'This is record 2.'\n   write(*,'(a)') string\n\n   ! print a newline character string\n   write(*,'(*(a))',advance='no') &\n      nl,'This is record 1.',nl,'This is record 2.',nl\n\n   ! output a number of words of random length as a paragraph\n   ! by inserting a new_line before line exceeds 70 characters\n\n  ! simplistic paragraph print using non-advancing I/O\n   count=0\n   do i=1,100\n\n      ! make some fake word of random length\n      call random_number(r)\n      string=repeat('x',int(r*10)+1)\n\n      count=count+len(string)+1\n      if(count.gt.70)then\n         write(*,'(a)',advance='no')nl\n         count=len(string)+1\n      endif\n      write(*,'(1x,a)',advance='no')string\n   enddo\n   write(*,'(a)',advance='no')nl\n\nend program demo_new_line\n```\nResults:\n```text\n   This is record 1.\n   This is record 2.\n\n   This is record 1.\n   This is record 2.\n    x x xxxx xxxxxxx xxxxxxxxxx xxxxxxxxx xxxx xxxxxxxxxx xxxxxxxx\n    xxxxxxxxx xxxx xxxxxxxxx x xxxxxxxxx xxxxxxxx xxxxxxxx xxxx x\n    xxxxxxxxxx x x x xxxxxx xxxxxxxxxx x xxxxxxxxxx x xxxxxxx xxxxxxxxx\n    xx xxxxxxxxxx xxxxxxxx x xx xxxxxxxxxx xxxxxxxx xxx xxxxxxx xxxxxx\n    xxxxx xxxxxxxxx x xxxxxxxxxx xxxxxx xxxxxxxx xxxxx xxxxxxxx xxxxxxxx\n    xxxxx xxx xxxxxxxx xxxxxxx xxxxxxxx xxx xxxx xxx xxxxxxxx xxxxxx\n    xxxxxxx xxxxxxx xxxxx xxxxx xx xxxxxx xx xxxxxxxxxx xxxxxx x xxxx\n    xxxxxx xxxxxxx x xxx xxxxx xxxxxxxxx xxx xxxxxxx x xxxxxx xxxxxxxxx\n    xxxx xxxxxxxxx xxxxxxxx xxxxxxxx xxx xxxxxxx xxxxxxx xxxxxxxxxx\n    xxxxxxxxxx xxxxxx xxxxx xxxx xxxxxxx xx xxxxxxxxxx xxxxxx xxxxxx\n    xxxxxx xxxx xxxxx\n```\n### **Standard**\n\nFortran 2003\n\n### **See also**\n\n[**achar**(3)](#achar),\n[**char**(3)](#char),\n[**iachar**(3)](#iachar),\n[**ichar**(3)](#ichar),\n[**selected_char_kind**(3)](#selected_char_kind)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "NINT": "## nint\n\n### **Name**\n\n**nint** - \\[TYPE:NUMERIC\\] Nearest whole number\n\n### **Synopsis**\n```fortran\n    result = nint( a [,kind] )\n```\n```fortran\n     elemental integer(kind=KIND) function nint(a, kind )\n\n      real(kind=**),intent(in) :: a\n      integer(kind=**),intent(in),optional :: KIND\n```\n### **Characteristics**\n\n  - a kind designated as ** may be any supported kind for the type\n  - **a** is type real of any kind\n  - **KIND** is a scalar integer constant expression\n  - The result is default _integer_ kind or the value of **kind**\n    if **kind** is present.\n\n### **Description**\n\n  **nint** rounds its argument to the nearest whole number with its\n  sign preserved.\n\n  The user must ensure the value is a valid value for the range of the\n  **kind** returned. If the processor cannot represent the result in the kind\n  specified, the result is undefined.\n\n  If **a** is greater than zero, **nint(a)** has the value **int(a+0.5)**.\n\n  If **a** is less than or equal to zero, **nint(a)** has the value\n  **int(a-0.5)**.\n\n### **Options**\n\n- **a**\n  : The value to round to the nearest whole number\n\n- **kind**\n  : can specify the kind of the output value. If not present, the\n  output is the default type of _integer_.\n\n### **Result**\n\n  The result is the integer nearest **a**, or if there are two integers\n  equally near **a**, the result is whichever such _integer_ has the greater\n  magnitude.\n\n  The result is undefined if it cannot be represented in the specified\n  integer type.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_nint\nimplicit none\ninteger,parameter   :: dp=kind(0.0d0)\nreal,allocatable    :: in(:)\ninteger,allocatable :: out(:)\ninteger             :: i\nreal                :: x4\nreal(kind=dp)       :: x8\n\n  ! basic use\n   x4 = 1.234E0\n   x8 = 4.721_dp\n   print *, nint(x4), nint(-x4)\n   print *, nint(x8), nint(-x8)\n\n  ! elemental\n   in = [ -2.7,  -2.5, -2.2, -2.0, -1.5, -1.0, -0.5, -0.4, &\n        &  0.0,   &\n        & +0.04, +0.5, +1.0, +1.5, +2.0, +2.2, +2.5, +2.7  ]\n   out = nint(in)\n   do i=1,size(in)\n      write(*,*)in(i),out(i)\n   enddo\n\n  ! dusty corners\n   ISSUES: block\n   use,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\n   integer :: icheck\n      ! make sure input is in range for the type returned\n      write(*,*)'Range limits for typical KINDS:'\n      write(*,'(1x,g0,1x,g0)')  &\n      & int8,huge(0_int8),   &\n      & int16,huge(0_int16), &\n      & int32,huge(0_int32), &\n      & int64,huge(0_int64)\n\n      ! the standard does not require this to be an error ...\n      x8=12345.67e15 ! too big of a number\n      icheck=selected_int_kind(ceiling(log10(x8)))\n      write(*,*)'Any KIND big enough? ICHECK=',icheck\n      print *, 'These are all wrong answers for ',x8\n      print *, nint(x8,kind=int8)\n      print *, nint(x8,kind=int16)\n      print *, nint(x8,kind=int32)\n      print *, nint(x8,kind=int64)\n   endblock ISSUES\n\nend program demo_nint\n```\nResults:\n```text\n >               1          -1\n >               5          -5\n >      -2.700000              -3\n >      -2.500000              -3\n >      -2.200000              -2\n >      -2.000000              -2\n >      -1.500000              -2\n >      -1.000000              -1\n >     -0.5000000              -1\n >     -0.4000000               0\n >      0.0000000E+00           0\n >      3.9999999E-02           0\n >      0.5000000               1\n >       1.000000               1\n >       1.500000               2\n >       2.000000               2\n >       2.200000               2\n >       2.500000               3\n >       2.700000               3\n >     Range limits for typical KINDS:\n >     1 127\n >     2 32767\n >     4 2147483647\n >     8 9223372036854775807\n >     Any KIND big enough? ICHECK=          -1\n >     These are all wrong answers for   1.234566949990144E+019\n >        0\n >          0\n >     -2147483648\n >      -9223372036854775808\n```\n### **Standard**\n\nFORTRAN 77 , with KIND argument - Fortran 90\n\n### **See Also**\n\n[**aint**(3)](#aint),\n[**anint**(3)](#anint),\n[**int**(3)](#int),\n[**selected_int_kind**(3)](#selected_int_kind),\n[**ceiling**(3)](#ceiling),\n[**floor**(3)](#floor)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "NORM2": "## norm2\n\n### **Name**\n\n**norm2** - \\[MATHEMATICS\\] Euclidean vector norm\n\n### **Synopsis**\n```fortran\n    result = norm2(array, [dim])\n```\n```fortran\n     real(kind=KIND) function norm2(array, dim)\n\n      real(kind=KIND),intent(in) :: array(..)\n      integer(kind=**),intent(in),optional :: dim\n```\n### **Characteristics**\n\n - **array** shall be an array of type _real_.\n - **dim** shall be a scalar of type _integer_\n - The result is of the same type as **array**.\n\n### **Description**\n\n  **norm2** calculates the Euclidean vector norm (L_2 norm or\n  generalized L norm) of **array** along dimension **dim**.\n\n### **Options**\n\n- **array**\n  : the array of input values for the L_2 norm computations\n\n- **dim**\n  : a value in the range from **1** to **rank(array)**.\n\n### **Result**\n\n  If **dim** is absent, a scalar with the square root of the sum of squares\n  of the elements of **array** is returned.\n\n  Otherwise, an array of rank **n-1**, where **n** equals the rank of\n  **array**, and a shape similar to that of **array** with dimension DIM\n  dropped is returned.\n\n      Case (i):     The result of NORM2 (X) has a value equal to a\n                    processor-dependent approximation to the generalized\n                    L norm of X, which is the square root of the sum of\n                    the squares of the elements of X. If X has size zero,\n                    the result has the value zero.\n\n      Case (ii):    The result of NORM2 (X, DIM=DIM) has a value equal\n                    to that of NORM2 (X) if X has rank one. Otherwise,\n                    the resulting array is reduced in rank with dimension\n                    **dim** removed, and each remaining elment is the\n                    result of NORM2(X) for the values along dimension\n                    **dim**.\n\n  It is recommended that the processor compute the result without undue\n  overflow or underflow.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_norm2\nimplicit none\ninteger :: i\nreal :: x(2,3) = reshape([ &\n   1, 2, 3, &\n   4, 5, 6  &\n   ],shape(x),order=[2,1])\n\n  write(*,*) 'input in row-column order'\n  write(*,*) 'x='\n  write(*,'(4x,3f4.0)')transpose(x)\n  write(*,*)\n  write(*,*) 'norm2(x)=',norm2(x)\n  write(*,*) 'which is equivalent to'\n  write(*,*) 'sqrt(sum(x**2))=',sqrt(sum(x**2))\n  write(*,*)\n  write(*,*) 'for reference the array squared is'\n  write(*,*) 'x**2='\n  write(*,'(4x,3f4.0)')transpose(x**2)\n  write(*,*)\n  write(*,*) 'norm2(x,dim=1)=',norm2(x,dim=1)\n  write(*,*) 'norm2(x,dim=2)=',norm2(x,dim=2)\n  write(*,*) '(sqrt(sum(x(:,i)**2)),i=1,3)=',(sqrt(sum(x(:,i)**2)),i=1,3)\n  write(*,*) '(sqrt(sum(x(i,:)**2)),i=1,2)=',(sqrt(sum(x(i,:)**2)),i=1,2)\n\nend program demo_norm2\n```\nResults:\n```text\n >  input in row-column order\n >  x=\n >       1.  2.  3.\n >       4.  5.  6.\n >\n >  norm2(x)=   9.539392\n >  which is equivalent to\n >  sqrt(sum(x**2))=   9.539392\n >\n >  for reference the array squared is\n >  x**2=\n >       1.  4.  9.\n >      16. 25. 36.\n >\n >  norm2(x,dim=1)=   4.123106       5.385165       6.708204\n >  norm2(x,dim=2)=   3.741657       8.774964\n >  (sqrt(sum(x(:,i)**2)),i=1,3)=   4.123106       5.385165       6.708204\n >  (sqrt(sum(x(i,:)**2)),i=1,2)=   3.741657       8.774964\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**product**(3)](#product),\n[**sum**(3)](#sum),\n[**hypot**(3)](#hypot)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "NOT": "## not\n\n### **Name**\n\n**not** - \\[BIT:LOGICAL\\] Logical negation; flips all bits in an integer\n\n### **Synopsis**\n```fortran\n    result = not(i)\n```\n```fortran\n    elemental integer(kind=KIND) function not(i)\n\n     integer(kind=KIND), intent(in) :: i\n```\n### **Characteristics**\n\n- **i** may be an _integer_ of any valid kind\n- The returned _integer_ is of the same kind as the argument **i**.\n\n### **Description**\n\n  **not** returns the bitwise Boolean inverse of **i**. This is also\n  known as the \"Bitwise complement\" or \"Logical negation\" of the value.\n\n  If an input bit is a one, that position is a zero on output. Conversely\n  any input bit that is zero is a one on output.\n\n### **Options**\n\n- **i**\n  : The value to flip the bits of.\n\n### **Result**\n\n  The result has the value obtained by complementing **i** bit-by-bit\n  according to the following truth table:\n\n       >    I   |  NOT(I)\n       >    ----#----------\n       >    1   |   0\n       >    0   |   1\n\n  That is, every input bit is flipped.\n\n### **Examples**\n\nSample program\n\n```fortran\nprogram demo_not\nimplicit none\ninteger :: i\n  ! basics\n   i=-13741\n   print *,'the input value',i,'represented in bits is'\n   write(*,'(1x,b32.32,1x,i0)') i, i\n   i=not(i)\n   print *,'on output it is',i\n   write(*,'(1x,b32.32,1x,i0)') i, i\n   print *, \" on a two's complement machine flip the bits and add 1\"\n   print *, \" to get the value with the sign changed, for example.\"\n   print *, 1234, not(1234)+1\n   print *, -1234, not(-1234)+1\n   print *, \" of course 'x=-x' works just fine and more generally.\"\nend program demo_not\n```\nResults:\n```text\n    the input value      -13741 represented in bits is\n    11111111111111111100101001010011 -13741\n    on output it is       13740\n    00000000000000000011010110101100 13740\n     on a two's complement machine flip the bits and add 1\n     to get the value with the sign changed, for example.\n           1234       -1234\n          -1234        1234\n     of course 'x=-x' works just fine and more generally.\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**iand**(3)](#iand),\n[**ior**(3)](#ior),\n[**ieor**(3)](#ieor),\n[**ibits**(3)](#ibits),\n[**ibset**(3)](#ibset),\n\n[**ibclr**(3)](#ibclr)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "NULL": "## null\n\n### **Name**\n\n**null** - \\[TRANSFORMATIONAL\\] Function that returns a disassociated pointer\n\n### **Synopsis**\n```fortran\n    ptr => null( [mold] )\n```\n```fortran\n     function null(mold)\n\n      type(TYPE(kind=**)),pointer,optional :: mold\n```\n### **Characteristics**\n\n- **mold** is a pointer of any association status and of any type.\n- The result is a disassociated pointer or an unallocated allocatable entity.\n\n### **Description**\n\n  **null** returns a disassociated pointer.\n\n  If **mold** is present, a disassociated pointer of the same type is\n  returned, otherwise the type is determined by context.\n\n  In _Fortran 95_, **mold** is optional. Please note that _Fortran 2003_\n  includes cases where it is required.\n\n### **Options**\n\n- **mold**\n  : a pointer of any association status and of any\n  type.\n\n### **Result**\n\n   A disassociated pointer or an unallocated allocatable entity.\n\n### **Examples**\n\nSample program:\n\n```fortran\n!program demo_null\nmodule showit\nimplicit none\nprivate\ncharacter(len=*),parameter :: g='(*(g0,1x))'\npublic gen\n! a generic interface that only differs in the\n! type of the pointer the second argument is\ninterface gen\n module procedure s1\n module procedure s2\nend interface\n\ncontains\n\nsubroutine s1 (j, pi)\n integer j\n integer, pointer :: pi\n   if(associated(pi))then\n      write(*,g)'Two integers in S1:,',j,'and',pi\n   else\n      write(*,g)'One integer in S1:,',j\n   endif\nend subroutine s1\n\nsubroutine s2 (k, pr)\n integer k\n real, pointer :: pr\n   if(associated(pr))then\n      write(*,g)'integer and real in S2:,',k,'and',pr\n   else\n      write(*,g)'One integer in S2:,',k\n   endif\nend subroutine s2\n\nend module showit\n\nprogram demo_null\nuse showit, only : gen\n\nreal,target :: x = 200.0\ninteger,target :: i = 100\n\nreal, pointer :: real_ptr\ninteger, pointer :: integer_ptr\n\n! so how do we call S1() or S2() with a disassociated pointer?\n\n! the answer is the null() function with a mold value\n\n! since s1() and s2() both have a first integer\n! argument the NULL() pointer must be associated\n! to a real or integer type via the mold option\n! so the following can distinguish whether s1(1)\n! or s2() is called, even though the pointers are\n! not associated or defined\n\ncall gen (1, null (real_ptr) )    ! invokes s2\ncall gen (2, null (integer_ptr) ) ! invokes s1\nreal_ptr => x\ninteger_ptr => i\ncall gen (3, real_ptr ) ! invokes s2\ncall gen (4, integer_ptr ) ! invokes s1\n\nend program demo_null\n```\nResults:\n```text\n   One integer in S2:, 1\n   One integer in S1:, 2\n   integer and real in S2:, 3 and 200.000000\n   Two integers in S1:, 4 and 100\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**associated**(3)](#associated)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "NUM_IMAGES": "## num_images\n\n### **Name**\n\n**num_images** - \\[COLLECTIVE\\] Number of images\n\n### **Synopsis**\n```fortran\n    result = num_images([team|team_number])\n```\n```fortran\n     integer function num_images (team)\n\n      type(TEAM_TYPE),intent(in),optional    :: team\n      integer(kind=KIND),intent(in),optional :: team_number\n```\n### **Characteristics**\n\n - use of **team** and **team_number** is mutually exclusive\n - **team** is a scalar of type **TEAM_TYPE** from the intrinsic module ISO_FORTRAN_ENV.\n - **team_number** is an _integer_ scalar.\n - the result is a default _integer_ scalar.\n\n### **Description**\n\n**num_images** Returns the number of images.\n\n### **Options**\n\n- **team**\n  : shall  be a scalar of type TEAM_TYPE from the intrinsic module\n  ISO_FORTRAN_ENV, with a value that identifies the current or an\n  ancestor team.\n\n- **team_number**\n  : identifies the initial team or a team whose parent is the same as\n  that of the current team.\n\n### **Result**\n\n  The number of images in the specified team, or in the current team if\n  no team is specified.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_num_images\nimplicit none\ninteger :: value[*]\nreal    :: p[*]\ninteger :: i\n\n   value = this_image()\n   sync all\n   if (this_image() == 1) then\n     do i = 1, num_images()\n       write(*,'(2(a,i0))') 'value[', i, '] is ', value[i]\n     end do\n   endif\n\n ! The following code uses image 1 to read data and\n ! broadcast it to other images.\n   if (this_image()==1) then\n      p=1234.5678\n      do i = 2, num_images()\n         p[i] = p\n      end do\n   end if\n   sync all\n\nend program demo_num_images\n```\n### **Standard**\n\nFortran 2008 . With DISTANCE or FAILED argument, TS 18508\n\n### **See Also**\n\n[**this_image**(3)](#this_image),\n[**image_index**(3)](#this_index)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "OUT_OF_RANGE": "## out_of_range\n\n### **Name**\n\n**out_of_range** - \\[TYPE:NUMERIC\\] Whether a numeric value can be\nconverted safely to another type\n\n### **Synopsis**\n```fortran\n    result = out_of_range (x, mold [, round])\n```\n```fortran\n     elemental logical function(x, mold, round)\n\n      type(TYPE(kind=**)),intent(in) :: x\n      type(TYPE(kind=**)),intent(in) :: mold\n      logical,intent(in),optional    :: round\n```\n### **Characteristics**\n\n - **x** is of type _integer_ or _real_.\n - **mold** is an _integer_ or _real_ scalar.\n - **round** is a _logical_ scalar.\n - the result is a default _logical_.\n\n### **Description**\n\n   **out_of_range** determines whether a value **x** can be converted\n   safely to a _real_ or _integer_ variable the same type and kind\n   as **mold**.\n\n   For example, if **int8** is the __kind__ name for an 8-bit binary integer type,\n   then for\n```fortran\n    logical :: L1, L2\n    L1=out_of_range(-128.5, 0_int8)\n    L2=out_of_range(-128.5, 0_int8,.true.)\n    end\n```\n    L1 likely will have the value __.false.__ because the value will\n    be truncated to -128.0, which is a representable integer number on a two's\n    complement machine.\n\n    L2 will be __.true.__ because it will be rounded to -129.0, which is not\n    likely to be a representable eight-bit integer.\n\n### **Options**\n   - **x**\n     : a scalar to be tested for whether it can be stored in a variable\n     of the type and kind of **mold**\n\n   - **mold**\n     : the type and kind of the variable (but not the value) is used to\n     identify the characteristics of the variable type to fit **x** into.\n\n   - **round**\n     : flag whether to round the value of **x** before validating it as\n     a value like **mold**.\n\n     **round** can only be present if **x** is of type\n     _real_ and **mold** is of type _integer_.\n\n### **Result**\n\nFrom the standard:\n\n   Case (i):     If **mold** is of type integer, and **round** is absent or\n                 present with the value false, the result is true\n                 if and only if the value of X is an IEEE infinity or\n                 NaN, or if the integer with largest magnitude that lies\n                 between zero and X inclusive is not representable by\n                 objects with the type and kind of **mold**.\n\n   Case (ii):    If **mold** is of type integer, and **round** is present with\n                 the value true, the result is true if and only\n                 if the value of X is an IEEE infinity or NaN, or\n                 if the integer nearest X, or the integer of greater\n                 magnitude if two integers are equally near to X, is not\n                 representable by objects with the type and kind of **mold**.\n\n   Case (iii):   Otherwise, the result is true if and only if the value\n                 of X is an IEEE infinity or NaN that is not\n                 supported by objects of the type and kind of **mold**,\n                 or if X is a finite number and the result of rounding\n                 the value of X (according to the IEEE rounding mode if\n                 appropriate) to the extended model for the kind of **mold**\n                 has magnitude larger than that of the largest finite\n                 number with the same sign as X that is representable\n                 by objects with the type and kind of **mold**.\n\n   NOTE\n\n   **mold** is required to be a scalar because the only information\n   taken from it is its type and kind. Allowing an array **mold** would\n   require that it be conformable with **x**. **round** is scalar because\n   allowing an array rounding mode would have severe performance\n   difficulties on many processors.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_out_of_range\nuse, intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nuse, intrinsic :: iso_fortran_env, only : real32, real64, real128\nimplicit none\ninteger            :: i\ninteger(kind=int8) :: i8, j8\n\n    ! compilers are not required to produce an error on out of range.\n    ! here storing the default integers into 1-byte integers\n    ! incorrectly can have unexpected results\n    do i=127,130\n       i8=i\n       j8=-i\n       ! OUT_OF_RANGE(3f) can let you check if the value will fit\n       write(*,*)i8,j8,' might have expected',i,-i, &\n        & out_of_range( i,i8), &\n        & out_of_range(-i,i8)\n    enddo\n    write(*,*) 'RANGE IS ',-1-huge(0_int8),'TO',huge(0_int8)\n    ! the real -128.5 is truncated to -128 and is in range\n    write(*,*) out_of_range (  -128.5, 0_int8)         ! false\n\n    ! the real -128.5 is rounded to -129 and is not in range\n    write(*,*) out_of_range (  -128.5, 0_int8, .true.) ! true\n\nend program demo_out_of_range\n```\nResults:\n```text\n  >  127 -127  might have expected         127        -127 F F\n  > -128 -128  might have expected         128        -128 T F\n  > -127  127  might have expected         129        -129 T T\n  > -126  126  might have expected         130        -130 T T\n  > RANGE IS         -128 TO  127\n  > F\n  > T\n```\n### **Standard**\n\n   FORTRAN 2018\n\n### **See also**\n\n- [**aimag**(3)](#aimag) - Imaginary part of complex number\n- [**cmplx**(3)](#cmplx) - Convert values to a complex type\n- [**dble**(3)](#dble) - Double conversion function\n- [**int**(3)](#int) - Truncate towards zero and convert to integer\n- [**nint**(3)](#nint) - Nearest whole number\n- [**real**(3)](#real) - Convert to real type\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "PACK": "## pack\n\n### **Name**\n\n**pack** - \\[ARRAY:CONSTRUCTION\\] Pack an array into an array of rank one\n\n### **Synopsis**\n```fortran\n    result = pack( array, mask [,vector] )\n```\n```fortran\n     TYPE(kind=KIND) function pack(array,mask,vector)\n\n      TYPE(kind=KIND),option(in) :: array(..)\n      logical  :: mask(..)\n      TYPE(kind=KIND),option(in),optional :: vector(*)\n```\n### **Characteristics**\n\n  - **array** is an array of any type\n  - **mask** a _logical_ scalar as well as an array conformable with **array**.\n  - **vector** is of the same kind and type as **array** and of rank one\n  - the returned value is of the same kind and type as **array**\n\n### **Description**\n\n  **pack** stores the elements of **array** in an array of rank one.\n\n  The beginning of the resulting array is made up of elements whose\n  **mask** equals _.true._. Afterwards, remaining positions are filled with elements\n  taken from **vector**\n\n### **Options**\n\n- **array**\n  : The data from this array is used to fill the resulting vector\n\n- **mask**\n  : the _logical_ mask must be the same size as **array** or,\n  alternatively, it may be a _logical_ scalar.\n\n- **vector**\n  : an array of the same type as **array** and of rank\n  one. If present, the number of elements in **vector** shall be equal to\n  or greater than the number of true elements in **mask**. If **mask** is\n  scalar, the number of elements in **vector** shall be equal to or\n  greater than the number of elements in **array**.\n\n**vector** shall have at least as many elements as there are in **array**.\n\n### **Result**\n\nThe result is an array of rank one and the same type as that of **array**.\nIf **vector** is present, the result size is that of **vector**, the number of\n_.true._ values in **mask** otherwise.\n\nIf **mask** is scalar with the value _.true._, in which case the result\nsize is the size of **array**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_pack\nimplicit none\ninteger, allocatable :: m(:)\ncharacter(len=10) :: c(4)\n\n ! gathering nonzero elements from an array:\n   m = [ 1, 0, 0, 0, 5, 0 ]\n   write(*, fmt=\"(*(i0, ' '))\") pack(m, m /= 0)\n\n ! Gathering nonzero elements from an array and appending elements\n ! from VECTOR till the size of the mask array (or array size if the\n ! mask is scalar):\n   m = [ 1, 0, 0, 2 ]\n   write(*, fmt=\"(*(i0, ' '))\") pack(m, m /= 0, [ 0, 0, 3, 4 ])\n   write(*, fmt=\"(*(i0, ' '))\") pack(m, m /= 0 )\n\n ! select strings whose second character is \"a\"\n   c = [ character(len=10) :: 'ape', 'bat', 'cat', 'dog']\n   write(*, fmt=\"(*(g0, ' '))\") pack(c, c(:)(2:2) == 'a' )\n\nend program demo_pack\n```\nResults:\n```text\n > 1 5\n > 1 2 3 4\n > 1 2\n > bat        cat\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**merge**(3)](#merge),\n[**spread**(3)](#spread),\n[**unpack**(3)](#unpack)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "PARITY": "## parity\n\n### **Name**\n\n**parity** - \\[ARRAY:REDUCTION\\] Array reduction by .NEQV. operation\n\n### **Synopsis**\n```fortran\n    result = parity( mask [,dim] )\n```\n```fortran\n     logical(kind=KIND) function parity(mask, dim)\n\n      type(logical(kind=KIND)),intent(in)        :: mask(..)\n      type(integer(kind=**)),intent(in),optional :: dim\n```\n### **Characteristics**\n\n  - **mask** is a _logical_ array\n  - **dim** is an integer scalar\n  - the result is of type _logical_ with the same kind type parameter as **mask**.\n    It is a scalar if **dim** does not appear; otherwise it is the rank and shape\n    of **mask** with the dimension specified by **dim** removed.\n  - a kind designated as ** may be any supported kind for the type\n\n### **Description**\n\n**parity** calculates the parity array (i.e. the reduction using .neqv.) of\n**mask** along dimension **dim** if **dim** is present and not 1. Otherwise, it\nreturns the parity of the entire **mask** array as a scalar.\n\n### **Options**\n\n  - **mask**\n    : Shall be an array of type _logical_.\n\n  - **dim**\n    : (Optional) shall be a scalar of type _integer_ with a value in the\n    range from _1 to n_, where _n_ equals the rank of **mask**.\n\n### **Result**\n\n  The result is of the same type as **mask**.\n\n  If **dim** is absent, a scalar with the parity of all elements in **mask**\n  is returned: _.true._ if an odd number of elements are _.true._\n  and _.false._ otherwise.\n\n  If MASK has rank one, PARITY (MASK, DIM) is equal to PARITY (MASK). Otherwise, the\n  result is an array of parity values with dimension **dim** dropped.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_parity\nimplicit none\nlogical, parameter :: T=.true., F=.false.\nlogical :: x(3,4)\n  ! basics\n   print *, parity([T,F])\n   print *, parity([T,F,F])\n   print *, parity([T,F,F,T])\n   print *, parity([T,F,F,T,T])\n   x(1,:)=[T,T,T,T]\n   x(2,:)=[T,T,T,T]\n   x(3,:)=[T,T,T,T]\n   print *, parity(x)\n   print *, parity(x,dim=1)\n   print *, parity(x,dim=2)\nend program demo_parity\n```\nResults:\n```text\n >  T\n >  T\n >  F\n >  T\n >  F\n >  T T T T\n >  F F F\n```\n### **Standard**\n\nFortran 2008\n\n### **See also**\n\n - [**all**(3)](#all) - Determines if all the values are true\n - [**any**(3)](#any) - Determines if any of the values in the logical array are _.true._\n - [**count**(3)](#count) - Count true values in an array\n - [**sum**(3)](#sum) - Sum the elements of an array\n - [**maxval**(3)](#maxval) - Determines the maximum value in an array or row\n - [**minval**(3)](#minval) - Minimum value of an array\n - [**product**(3)](#product) - Product of array elements\n - [**reduce**(3)](#reduce) - General array reduction\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "POPCNT": "## popcnt\n\n### **Name**\n\n**popcnt** - \\[BIT:COUNT\\] Number of bits set\n\n### **Synopsis**\n```fortran\n    result = popcnt(i)\n```\n```fortran\n     elemental integer function popcnt(i)\n\n      integer(kind=KIND), intent(in) :: i\n```\n### **Characteristics**\n\n- **i** may be an _integer_ of any kind.\n- The return value is an _integer_ of the default integer kind.\n\n### **Description**\n\n  **popcnt** returns the number of bits set to one in the binary\n  representation of an _integer_.\n\n### **Options**\n\n- **i**\n  : value to count set bits in\n\n### **Result**\n\nThe number of bits set to one in **i**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_popcnt\nuse, intrinsic :: iso_fortran_env, only : integer_kinds, &\n   & int8, int16, int32, int64\nimplicit none\ncharacter(len=*),parameter :: pretty='(b64,1x,i0)'\n  ! basic usage\n   print pretty, 127,     popcnt(127)\n   print pretty, int(b\"01010\"), popcnt(int(b\"01010\"))\n\n  ! any kind of an integer can be used\n   print pretty, huge(0_int8),  popcnt(huge(0_int8))\n   print pretty, huge(0_int16), popcnt(huge(0_int16))\n   print pretty, huge(0_int32), popcnt(huge(0_int32))\n   print pretty, huge(0_int64), popcnt(huge(0_int64))\nend program demo_popcnt\n```\nResults:\n\nNote that on most machines the first bit is the sign bit, and a zero is\nused for positive values; but that this is system-dependent. These are\ntypical values, where the huge(3f) function has set all but the first\nbit to 1.\n```text\n >                                                         1111111 7\n >                                                            1010 2\n >                                                         1111111 7\n >                                                 111111111111111 15\n >                                 1111111111111111111111111111111 31\n > 111111111111111111111111111111111111111111111111111111111111111 63\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\nThere are many procedures that operator or query values at the bit level:\n\n[**poppar**(3)](#poppar),\n[**leadz**(3)](#leadz),\n[**trailz**(3)](#trailz)\n[**atomic_and**(3)](#atomic_and),\n[**atomic_fetch_and**(3)](#atomic_fetch_and),\n[**atomic_fetch_or**(3)](#atomic_fetch_or),\n[**atomic_fetch_xor**(3)](#atomic_fetch_xor),\n[**atomic_or**(3)](#atomic_or),\n[**atomic_xor**(3)](#atomic_xor),\n[**bge**(3)](#bge),\n[**bgt**(3)](#bgt),\n[**bit_size**(3)](#bit_size),\n[**ble**(3)](#ble),\n[**blt**(3)](#blt),\n[**btest**(3)](#btest),\n[**dshiftl**(3)](#dshiftl),\n[**dshiftr**(3)](#dshiftr),\n[**iall**(3)](#iall),\n[**iand**(3)](#iand),\n[**iany**(3)](#iany),\n[**ibclr**(3)](#ibclr),\n[**ibits**(3)](#ibits),\n[**ibset**(3)](#ibset),\n[**ieor**(3)](#ieor),\n[**ior**(3)](#ior),\n[**iparity**(3)](#iparity),\n[**ishftc**(3)](#ishftc),\n[**ishft**(3)](#ishft),\n[**maskl**(3)](#maskl),\n[**maskr**(3)](#maskr),\n[**merge_bits**(3)](#merge_bits),\n[**mvbits**(3)](#mvbits),\n[**not**(3)](#not),\n[**shifta**(3)](#shifta),\n[**shiftl**(3)](#shiftl),\n[**shiftr**(3)](#shiftr),\n[**storage_size**(3)](#storage_size)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "POPPAR": "## poppar\n\n### **Name**\n\n**poppar** - \\[BIT:COUNT\\] Parity of the number of bits set\n\n### **Synopsis**\n```fortran\n    result = poppar(i)\n```\n```fortran\n     elemental integer function poppar(i)\n\n      integer(kind=KIND), intent(in) :: i\n```\n### **Characteristics**\n\n- **i** is an _integer_ of any kind\n- the return value is a default kind _integer_\n\n### **Description**\n\n  **poppar** returns the parity of an integer's binary representation\n  (i.e., the parity of the number of bits set).\n\n  The parity is expressed as\n\n  + **0** (zero) if **i** has an even number of bits set to **1**.\n  + **1** (one) if the number of bits set to one **1** is odd,\n\n### **Options**\n\n- **i**\n  : The value to query for its bit parity\n\n### **Result**\n\n  The return value is equal to **0** if **i** has an even number of bits\n  set and **1** if an odd number of bits are set.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_poppar\nuse, intrinsic :: iso_fortran_env, only : integer_kinds, &\n   & int8, int16, int32, int64\nimplicit none\ncharacter(len=*),parameter :: pretty='(b64,1x,i0)'\n   ! basic usage\n   print pretty, 127,     poppar(127)\n   print pretty, 128,     poppar(128)\n   print pretty, int(b\"01010\"), poppar(int(b\"01010\"))\n\n   ! any kind of an integer can be used\n   print pretty, huge(0_int8),  poppar(huge(0_int8))\n   print pretty, huge(0_int16), poppar(huge(0_int16))\n   print pretty, huge(0_int32), poppar(huge(0_int32))\n   print pretty, huge(0_int64), poppar(huge(0_int64))\nend program demo_poppar\n```\nResults:\n```text\n >                                                          1111111 1\n >                                                         10000000 1\n >                                                             1010 0\n >                                  1111111111111111111111111111111 1\n >                                                          1111111 1\n >                                                  111111111111111 1\n >                                  1111111111111111111111111111111 1\n >  111111111111111111111111111111111111111111111111111111111111111 1\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\nThere are many procedures that operator or query values at the bit level:\n\n[**popcnt**(3)](#popcnt),\n[**leadz**(3)](#leadz),\n[**trailz**(3)](#trailz)\n[**atomic_and**(3)](#atomic_and),\n[**atomic_fetch_and**(3)](#atomic_fetch_and),\n[**atomic_fetch_or**(3)](#atomic_fetch_or),\n[**atomic_fetch_xor**(3)](#atomic_fetch_xor),\n[**atomic_or**(3)](#atomic_or),\n[**atomic_xor**(3)](#atomic_xor),\n[**bge**(3)](#bge),\n[**bgt**(3)](#bgt),\n[**bit_size**(3)](#bit_size),\n[**ble**(3)](#ble),\n[**blt**(3)](#blt),\n[**btest**(3)](#btest),\n[**dshiftl**(3)](#dshiftl),\n[**dshiftr**(3)](#dshiftr),\n[**iall**(3)](#iall),\n[**iand**(3)](#iand),\n[**iany**(3)](#iany),\n[**ibclr**(3)](#ibclr),\n[**ibits**(3)](#ibits),\n[**ibset**(3)](#ibset),\n[**ieor**(3)](#ieor),\n[**ior**(3)](#ior),\n[**iparity**(3)](#iparity),\n[**ishftc**(3)](#ishftc),\n[**ishft**(3)](#ishft),\n[**maskl**(3)](#maskl),\n[**maskr**(3)](#maskr),\n[**merge_bits**(3)](#merge_bits),\n[**mvbits**(3)](#mvbits),\n[**not**(3)](#not),\n[**shifta**(3)](#shifta),\n[**shiftl**(3)](#shiftl),\n[**shiftr**(3)](#shiftr),\n[**storage_size**(3)](#storage_size)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "PRECISION": "## precision\n\n### **Name**\n\n**precision** - \\[NUMERIC MODEL\\] Decimal precision of a real kind\n\n### **Synopsis**\n```fortran\n    result = precision(x)\n```\n```fortran\n     integer function precision(x)\n\n      TYPE(kind=**),intent(in) :: x\n```\n### **Characteristics**\n\n - **x** shall be of type _real_ or _complex_. It may be a scalar or an array.\n - the result is a default _integer_ scalar.\n\n### **Description**\n\n  **precision** returns the decimal precision in the model of the type\n  of **x**.\n\n### **Options**\n\n- **x**\n  : the type and kind of the argument are used to determine which number\n  model to query.  The value of the argument is not unused; it may even\n  be undefined.\n\n### **Result**\n\n   The precision of values of the type and kind of **x**\n<!--\n   Result Value. The result has the value INT ((p - 1) * LOG10 (b)) + k, where b and p are as defined in 16.4\n   for the model representing real numbers with the same value for the kind type parameter as X, and where k is 1\n   if b is an integral power of 10 and 0 otherwise.\n-->\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_precision\nuse,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32\nimplicit none\nreal(kind=sp)    :: x(2)\ncomplex(kind=dp) :: y\n\n   print *, precision(x), range(x)\n   print *, precision(y), range(y)\n\nend program demo_precision\n```\nResults:\n```text\n  >           6          37\n  >          15         307\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**exponent**(3)](#exponent),\n[**fraction**(3)](#fraction),\n[**huge**(3)](#huge),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**nearest**(3)](#nearest),\n[**radix**(3)](#radix),\n[**range**(3)](#range),\n[**rrspacing**(3)](#rrspacing),\n[**scale**(3)](#scale),\n[**set_exponent**(3)](#set_exponent),\n[**spacing**(3)](#spacing),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "PRESENT": "## present\n\n### **Name**\n\n**present** - [STATE:INQUIRY\\] Determine whether an optional dummy argument\nis specified\n\n### **Synopsis**\n```fortran\n    result = present(a)\n```\n```fortran\n     logical function present (a)\n\n      type(TYPE(kind=KIND)) :: a(..)\n```\n### **Characteristics**\n\n- **a** May be of any type and may be a pointer, scalar or array value,\n  or a dummy procedure.\n\n### **Description**\n\n  **present** can be used in a procedure to determine if an optional\n  dummy argument was present on the current call to the procedure.\n\n  **a** shall be the name of an optional dummy argument that is accessible\n  in the subprogram in which the **present** function reference\n  appears. There are no other requirements on **a**.\n\n  Note when an argument is not present when the current procedure is\n  invoked, you may only pass it as an optional argument to another\n  procedure or pass it as an argument to **present**.\n\n### **Options**\n\n- **a**\n  : the name of an optional dummy argument accessible within the current\n  subroutine or function.\n\n### **Result**\n\n  Returns _.true._ if the optional argument **a** is present (was passed\n  on the call to the procedure) , or _.false._ otherwise.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_present\nimplicit none\ninteger :: answer\n   ! argument to func() is not present\n   answer=func()\n   write(*,*) answer\n   ! argument to func() is present\n   answer=func(1492)\n   write(*,*) answer\ncontains\n!\ninteger function func(x)\n! the optional characteristic on this definition allows this variable\n! to not be specified on a call; and also allows it to subsequently\n! be passed to PRESENT(3):\ninteger, intent(in), optional :: x\ninteger :: x_local\n   !\n   ! basic\n   if(present(x))then\n     ! if present, you can use x like any other variable.\n     x_local=x\n   else\n     ! if not, you cannot define or reference x except to\n     ! pass it as an optional parameter to another procedure\n     ! or in a call to present(3f)\n     x_local=0\n   endif\n   !\n   func=x_local**2\n   !\n   ! passing the argument on to other procedures\n   ! so something like this is a bad idea because x is used\n   ! as the first argument to merge(3f) when it might not be\n   ! present\n   ! xlocal=merge(x,0,present(x)) ! NO!!\n   !\n   ! We can pass it to another procedure if another\n   ! procedure declares the argument as optional as well,\n   ! or we have tested that X is present\n   call tattle('optional argument x',x)\n   if(present(x))call not_optional(x)\nend function\n!\nsubroutine tattle(label,arg)\ncharacter(len=*),intent(in) :: label\ninteger,intent(in),optional :: arg\n   if(present(arg))then\n      write(*,*)label,' is present'\n   else\n      write(*,*)label,' is not present'\n   endif\nend subroutine tattle\n!\nsubroutine not_optional(arg)\ninteger,intent(in) :: arg\n   write(*,*)'already tested X is defined',arg\nend subroutine not_optional\n!\nend program demo_present\n```\nResults:\n```text\n    optional argument x is not present\n              0\n    optional argument x is present\n    already tested X is defined 1492\n        2226064\n```\n### **Standard**\n\nFortran 95\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "PRODUCT": "## product\n\n### **Name**\n\n**product** - \\[ARRAY:REDUCTION\\] Product of array elements\n\n### **Synopsis**\n```fortran\n    result = product(array [,dim] [,mask])\n```\n```fortran\n     NUMERIC function product(array, dim, mask)\n\n      NUMERIC,intent(in) :: array(..)\n      integer(kind=**),intent(in),optional :: dim\n      logical(kind=**),intent(in),optional :: mask(..)\n```\n### **Characteristics**\n\n  - a kind designated as ** may be any supported kind for the type\n  - **NUMERIC** is any numeric type and kind.\n\n### **Description**\n\n**product** multiplies together all the selected elements of **array**,\nor along dimension **dim** if the corresponding element in **mask**\nis _.true._.\n\nIf **dim** is absent, a scalar with the product of all elements in **array** is\nreturned. (Note a zero-sized **array** returns **1**).\n\nWhen **dim** is present, If the masked array has a dimension of one\n(ie. is a vector) the result is a scalar. Otherwise, an array of rank\n**n-1**, where **n** equals the rank of **array**, and a shape similar\nto that of **array** with dimension **dim** dropped is returned.\n\n### **Options**\n\n- **array**\n  : Shall be an array of type _integer_, _real_ or _complex_.\n\n- **dim**\n  : shall be a scalar of type _integer_ with a value in the\n  range from **1 to n**, where **n** equals the rank of **array**.\n\n- **mask**\n  : shall be of type _logical_ and either be a scalar or an\n  array of the same shape as **array**.\n\n### **Result**\n\nThe result is of the same type as **array**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_product\nimplicit none\ncharacter(len=*),parameter :: all='(*(g0,1x))' ! a handy format\ncharacter(len=1),parameter :: nl=new_line('a')\n\nNO_DIM: block\n!    If DIM is not specified, the result is the product of all the\n!    selected array elements.\ninteger :: i,n, p1, p2\ninteger,allocatable :: array(:)\n   ! all elements are selected by default\n   do n=1,10\n      print all, 'factorial of ',n,' is ', product([(real(i),i=1,n)])\n   enddo\n\n   ! using a mask\n   array=[10,12,13,15,20,25,30]\n   p1=product(array, mask=mod(array, 2)==1) ! only odd elements\n   p2=product(array, mask=mod(array, 2)/=1) ! only even elements\n   print all, nl,'product of all elements',product(array) ! all elements\n   print all, ' odd * even =',nl,p1,'*',p2,'=',p1*p2\n\n   ! NOTE: If ARRAY is a zero-sized array, the result is equal to one\n   print all\n   print all, 'zero-sized array=>',product([integer :: ])\n   ! NOTE: If nothing in the mask is true, this also results in a null\n   !       array\n   print all, 'all elements have a false mask=>', &\n            & product(array,mask=.false.)\n\nendblock NO_DIM\n\nWITH_DIM: block\ninteger :: rect(2,3)\ninteger :: box(2,3,4)\n\n!  lets fill a few arrays\n   rect = reshape([ &\n     1, 2, 3,       &\n     4, 5, 6        &\n   ],shape(rect),order=[2,1])\n   call print_matrix_int('rect',rect)\n\n!  Find the product of each column in RECT.\n   print all, 'product of columns=',product(rect, dim = 1)\n\n! Find the product of each row in RECT.\n   print all, 'product of rows=',product(rect, dim = 2)\n\n! now lets try a box\n   box(:,:,1)=rect\n   box(:,:,2)=rect*(+10)\n   box(:,:,3)=rect*(-10)\n   box(:,:,4)=rect*2\n   ! lets look at the values\n   call print_matrix_int('box 1',box(:,:,1))\n   call print_matrix_int('box 2',box(:,:,2))\n   call print_matrix_int('box 3',box(:,:,3))\n   call print_matrix_int('box 4',box(:,:,4))\n\n   ! remember without dim= even a box produces a scalar\n   print all, 'no dim gives a scalar',product(real(box))\n\n   ! only one plane has negative values, so note all the \"1\" values\n   ! for vectors with no elements\n   call print_matrix_int('negative values', &\n   & product(box,mask=box < 0,dim=1))\n\n!   If DIM is specified and ARRAY has rank greater than one, the\n!   result is a new array in which dimension DIM has been eliminated.\n\n   ! pick a dimension to multiply though\n   call print_matrix_int('dim=1',product(box,dim=1))\n\n   call print_matrix_int('dim=2',product(box,dim=2))\n\n   call print_matrix_int('dim=3',product(box,dim=3))\n\nendblock WITH_DIM\n\ncontains\n\nsubroutine print_matrix_int(title,arr)\nimplicit none\n\n!@(#) print small 2d integer arrays in row-column format\n\ncharacter(len=*),intent(in)  :: title\ninteger,intent(in)           :: arr(:,:)\ninteger                      :: i\ncharacter(len=:),allocatable :: biggest\n\n   print all\n   print all, trim(title),':(',shape(arr),')'  ! print title\n   biggest='           '  ! make buffer to write integer into\n   ! find how many characters to use for integers\n   write(biggest,'(i0)')ceiling(log10(max(1.0,real(maxval(abs(arr))))))+2\n   ! use this format to write a row\n   biggest='(\" > [\",*(i'//trim(biggest)//':,\",\"))'\n   ! print one row of array at a time\n   do i=1,size(arr,dim=1)\n      write(*,fmt=biggest,advance='no')arr(i,:)\n      write(*,'(\" ]\")')\n   enddo\n\nend subroutine print_matrix_int\n\nend program demo_product\n```\n\nResults:\n\n```text\nfactorial of  1  is  1.000000\nfactorial of  2  is  2.000000\nfactorial of  3  is  6.000000\nfactorial of  4  is  24.00000\nfactorial of  5  is  120.0000\nfactorial of  6  is  720.0000\nfactorial of  7  is  5040.000\nfactorial of  8  is  40320.00\nfactorial of  9  is  362880.0\nfactorial of  10  is  3628800.\n\n product of all elements 351000000\n odd * even =\n 4875 * 72000 = 351000000\n\nzero-sized array=> 1\nall elements have a false mask=> 1\n\nrect :( 2 3 )\n > [  1,  2,  3 ]\n > [  4,  5,  6 ]\nproduct of columns= 4 10 18\nproduct of rows= 6 120\n\nbox 1 :( 2 3 )\n > [  1,  2,  3 ]\n > [  4,  5,  6 ]\n\nbox 2 :( 2 3 )\n > [  10,  20,  30 ]\n > [  40,  50,  60 ]\n\nbox 3 :( 2 3 )\n > [ -10, -20, -30 ]\n > [ -40, -50, -60 ]\n\nbox 4 :( 2 3 )\n > [   2,   4,   6 ]\n > [   8,  10,  12 ]\nno dim gives a scalar .1719927E+26\n\nnegative values :( 3 4 )\n > [     1,     1,   400,     1 ]\n > [     1,     1,  1000,     1 ]\n > [     1,     1,  1800,     1 ]\n\ndim=1 :( 3 4 )\n > [     4,   400,   400,    16 ]\n > [    10,  1000,  1000,    40 ]\n > [    18,  1800,  1800,    72 ]\n\ndim=2 :( 2 4 )\n > [       6,    6000,   -6000,      48 ]\n > [     120,  120000, -120000,     960 ]\n\ndim=3 :( 2 3 )\n > [    -200,   -3200,  -16200 ]\n > [  -51200, -125000, -259200 ]\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**sum**(3)](#sum), note that an element by element multiplication is done\ndirectly using the star character.\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "RADIX": "## radix\n\n### **Name**\n\n**radix** - \\[NUMERIC MODEL\\] Base of a numeric model\n\n### **Synopsis**\n```fortran\n   result = radix(x)\n```\n```fortran\n    integer function radix(x)\n\n     TYPE(kind=**),intent(in) :: x(..)\n```\n### **Characteristics**\n\n   - **x** may be scalar or an array of any _real_ or _integer_ type.\n   - the result is a default integer scalar.\n\n### **Description**\n\n  **radix** returns the base of the internal model representing the\n  numeric entity **x**.\n\n  In a positional numeral system, the radix or base is the number of\n  unique digits, including the digit zero, used to represent numbers.\n\n  This function helps to represent the internal computing model\n  generically, but will be 2 (representing a binary machine) for any\n  common platform for all the numeric types.\n\n### **Options**\n\n- **x**\n  : used to identify the type of number to query.\n\n### **Result**\n\n  The returned value indicates what base is internally used to represent\n  the type of numeric value **x** represents.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_radix\nimplicit none\n   print *, \"The radix for the default integer kind is\", radix(0)\n   print *, \"The radix for the default real kind is\", radix(0.0)\n   print *, \"The radix for the doubleprecision real kind is\", radix(0.0d0)\nend program demo_radix\n```\nResults:\n```text\n >  The radix for the default integer kind is           2\n >  The radix for the default real kind is           2\n >  The radix for the doubleprecision real kind is           2\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**exponent**(3)](#exponent),\n[**fraction**(3)](#fraction),\n[**huge**(3)](#huge),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**nearest**(3)](#nearest),\n[**precision**(3)](#precision),\n[**range**(3)](#range),\n[**rrspacing**(3)](#rrspacing),\n[**scale**(3)](#scale),\n[**set_exponent**(3)](#set_exponent),\n[**spacing**(3)](#spacing),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "RANDOM_INIT": "## random_init\n\n### **Name**\n\n**random_init** - \\[MATHEMATICS:RANDOM\\] Initializes the state of\nthe pseudorandom number generator\n\n### **Synopsis**\n```fortran\n    call random_init(repeatable, image_distinct)\n\n     logical,intent(in) :: repeatable\n     logical,intent(in) :: image_distinct\n```\n### **Characteristics**\n\n- **harvest** and **image_distinct** are logical scalars\n\n### Description\n\nInitializes the state of the pseudorandom number generator used by\n**random_number**.\n\n### **Options**\n\n**repeatable**\n: If it is **.true.**, the seed is set to a processor-dependent\nvalue that is the same each time **random_init** is called from the\nsame image. The term \"same image\" means a single instance of program\nexecution. The sequence of random numbers is different for repeated\nexecution of the program.\n\nIf it is **.false.**, the seed is set to a processor-dependent value.\n\n**image_distinct**\n: If is `.true.`, the seed is set to a processor-dependent value that\nis distinct from the seed set by a call to **random_init**in another\nimage. If it is **.false.**, the seed is set value that does depend\nwhich image called **random_init**.\n\n\n### **Examples**\n\nSample program:\n\n```fortran\n    program demo_random_init\n    implicit none\n    real x(3), y(3)\n       call random_init(.true., .true.)\n       call random_number(x)\n       call random_init(.true., .true.)\n       call random_number(y)\n       ! x and y should be the same sequence\n       if ( any(x /= y) ) stop \"x(:) and y(:) are not all equal\"\n    end program demo_random_init\n```\n## **Standard**\n\nFortran 2018\n\n## **See also**\n\n[random_number](#random_number),\n[random_seed](random_seed)\n\n _fortran-lang intrinsic descriptions\n",
  "RANDOM_NUMBER": "## random_number\n\n### **Name**\n\n**random_number** - \\[MATHEMATICS:RANDOM\\] Pseudo-random number\n\n### **Synopsis**\n```fortran\n    call random_number(harvest)\n```\n```fortran\n     subroutine random_number(harvest)\n\n      real,intent(out) :: harvest(..)\n```\n### **Characteristics**\n\n- **harvest** and the result are default _real_ variables\n\n### **Description**\n\n**random_number** returns a single pseudorandom number or an array of\npseudorandom numbers from the uniform distribution over the range\n0 \\<= x \\< 1.\n\n### **Options**\n\n- **harvest**\n  : Shall be a scalar or an array of type _real_.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_random_number\nuse, intrinsic :: iso_fortran_env, only : dp=>real64\nimplicit none\ninteger, allocatable :: seed(:)\ninteger              :: n\ninteger              :: first,last\ninteger              :: i\ninteger              :: rand_int\ninteger,allocatable  :: count(:)\nreal(kind=dp)        :: rand_val\n   call random_seed(size = n)\n   allocate(seed(n))\n   call random_seed(get=seed)\n   first=1\n   last=10\n   allocate(count(last-first+1))\n   ! To have a discrete uniform distribution on the integers\n   ! [first, first+1, ..., last-1, last] carve the continuous\n   ! distribution up into last+1-first equal sized chunks,\n   ! mapping each chunk to an integer.\n   !\n   ! One way is:\n   !   call random_number(rand_val)\n   ! choose one from last-first+1 integers\n   !   rand_int = first + FLOOR((last+1-first)*rand_val)\n      count=0\n      ! generate a lot of random integers from 1 to 10 and count them.\n      ! with a large number of values you should get about the same\n      ! number of each value\n      do i=1,100000000\n         call random_number(rand_val)\n         rand_int=first+floor((last+1-first)*rand_val)\n         if(rand_int.ge.first.and.rand_int.le.last)then\n            count(rand_int)=count(rand_int)+1\n         else\n            write(*,*)rand_int,' is out of range'\n         endif\n      enddo\n      write(*,'(i0,1x,i0)')(i,count(i),i=1,size(count))\nend program demo_random_number\n```\nResults:\n```\n   1 10003588\n   2 10000104\n   3 10000169\n   4 9997996\n   5 9995349\n   6 10001304\n   7 10001909\n   8 9999133\n   9 10000252\n   10 10000196\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**random_seed**(3)](#random_seed)\n\n _fortran-lang intrinsic descriptions_\n",
  "RANDOM_SEED": "## random_seed\n\n### **Name**\n\n**random_seed** - \\[MATHEMATICS:RANDOM\\] Initialize a pseudo-random number sequence\n\n### **Synopsis**\n```fortran\n    call random_seed( [size] [,put] [,get] )\n```\n```fortran\n     subroutine random_seed( size, put, get )\n\n      integer,intent(out),optional :: size\n      integer,intent(in),optional :: put(*)\n      integer,intent(out),optional :: get(*)\n```\n### **Characteristics**\n - **size** a scalar default _integer_\n - **put** a rank-one default _integer_ array\n - **get** a rank-one default _integer_ array\n - the result\n\n### **Description**\n\n**random_seed** restarts or queries the state of the pseudorandom\nnumber generator used by random_number.\n\nIf random_seed is called without arguments, it is seeded with random\ndata retrieved from the operating system.\n\n### **Options**\n\n- **size**\n  : specifies the minimum size of the arrays used with the **put**\n  and **get** arguments.\n\n- **put**\n  : the size of the array must be larger than or equal to the number\n  returned by the **size** argument.\n\n- **get**\n  : It is **intent(out)** and the size of the array must be larger than\n  or equal to the number returned by the **size** argument.\n\n### **Examples**\n\nSample program:\n\n```fortran\n    program demo_random_seed\n    implicit none\n    integer, allocatable :: seed(:)\n    integer :: n\n\n       call random_seed(size = n)\n       allocate(seed(n))\n       call random_seed(get=seed)\n       write (*, *) seed\n\n    end program demo_random_seed\n```\nResults:\n```text\n     -674862499 -1750483360  -183136071  -317862567   682500039\n     349459   344020729 -1725483289\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**random_number**(3)](#random_number)\n\n _fortran-lang intrinsic descriptions_\n",
  "RANGE": "## range\n\n### **Name**\n\n**range** - \\[NUMERIC MODEL\\] Decimal exponent range of a numeric kind\n\n### **Synopsis**\n```fortran\n    result = range(x)\n```\n```fortran\n      integer function range (x)\n\n       TYPE(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **x** may be of type _integer_, _real_, or _complex_. It may be a scalar or an array.\n - **KIND** is any kind supported by the type of **x**\n - the result is a default _integer_ scalar\n\n### **Description**\n\n  **range** returns the decimal exponent range in the model of the\n  type of **x**.\n\n  Since **x** is only used to determine the type and kind being\n  interrogated, the value need not be defined.\n\n### **Options**\n\n- **x**\n  : the value whose type and kind are used for the query\n\n### **Result**\n\n  Case (i)\n  : For an integer argument, the result has the value\n```fortran\n    int (log10 (huge(x)))\n```\n  Case (ii)\n  : For a real argument, the result has the value\n```fortran\n     int(min (log10 (huge(x)), -log10(tiny(x) )))\n  ```\n  Case (iii)\n  : For a complex argument, the result has the value\n```fortran\n    range(real(x))\n```\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_range\nuse,intrinsic :: iso_fortran_env, only : dp=>real64,sp=>real32\nimplicit none\nreal(kind=sp)    :: x(2)\ncomplex(kind=dp) :: y\n   print *, precision(x), range(x)\n   print *, precision(y), range(y)\nend program demo_range\n```\nResults:\n```text\n >            6          37\n >           15         307\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**exponent**(3)](#exponent),\n[**fraction**(3)](#fraction),\n[**huge**(3)](#huge),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**nearest**(3)](#nearest),\n[**precision**(3)](#precision),\n[**radix**(3)](#radix),\n[**rrspacing**(3)](#rrspacing),\n[**scale**(3)](#scale),\n[**set_exponent**(3)](#set_exponent),\n[**spacing**(3)](#spacing),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "RANK": "## rank\n\n### **Name**\n\n**rank** - \\[ARRAY:INQUIRY\\] Rank of a data object\n\n### **Synopsis**\n```fortran\n    result = rank(a)\n```\n```fortran\n     integer function rank(a)\n\n      type(TYPE(kind=**)),intent(in) :: a(..)\n```\n### **Characteristics**\n\n -  **a** can be of any type **TYPE** and rank.\n - a kind designated as ** may be any supported kind for the type\n\n### **Description**\n\n  **rank** returns the rank of a scalar or array data object.\n\n  The rank of an array is the number of dimensions it has (zero for a scalar).\n\n### **Options**\n\n- **a** is the data object to query the dimensionality of. The rank returned\n  may be from 0 to 16.\n\n  The argument **a** may be any data object type, including an assumed-rank\n  array.\n\n### **Result**\n\n  For arrays, their rank is returned; for scalars zero is returned.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_rank\nimplicit none\n\n! a bunch of data objects to query\ninteger           :: a\nreal, allocatable :: b(:,:)\nreal, pointer     :: c(:)\ncomplex           :: d\n\n! make up a type\ntype mytype\n   integer :: int\n   real :: float\n   character :: char\nend type mytype\ntype(mytype) :: any_thing(1,2,3,4,5)\n\n  ! basics\n   print *, 'rank of scalar a=',rank(a)\n   ! you can query this array even though it is not allocated\n   print *, 'rank of matrix b=',rank(b)\n   print *, 'rank of vector pointer c=',rank(c)\n   print *, 'rank of complex scalar d=',rank(d)\n\n  ! you can query any type, not just intrinsics\n   print *, 'rank of any arbitrary type=',rank(any_thing)\n\n  ! an assumed-rank object may be queried\n   call query_int(10)\n   call query_int([20,30])\n   call query_int( reshape([40,50,60,70],[2,2]) )\n\n  ! you can even query an unlimited polymorphic entity\n   call query_anything(10.0)\n   call query_anything([.true.,.false.])\n   call query_anything( reshape([40.0,50.0,60.0,70.0],[2,2]) )\n\ncontains\n\nsubroutine query_int(data_object)\n! It is hard to do much with something dimensioned\n! name(..) if not calling C except inside of a\n! SELECT_RANK construct but one thing you can\n! do is call the inquiry functions ...\ninteger,intent(in) :: data_object(..)\ncharacter(len=*),parameter :: all='(*(g0,1x))'\n\n   if(rank(data_object).eq.0)then\n      print all,&\n      & 'passed a scalar to an assumed rank,  &\n      & rank=',rank(data_object)\n   else\n      print all,&\n      & 'passed an array to an assumed rank,  &\n      & rank=',rank(data_object)\n   endif\n\nend subroutine query_int\n\nsubroutine query_anything(data_object)\nclass(*),intent(in) ::data_object(..)\ncharacter(len=*),parameter :: all='(*(g0,1x))'\n  if(rank(data_object).eq.0)then\n    print all,&\n    &'passed a scalar to an unlimited polymorphic rank=', &\n    & rank(data_object)\n  else\n    print all,&\n    & 'passed an array to an unlimited polymorphic, rank=', &\n    & rank(data_object)\n  endif\nend subroutine query_anything\n\nend program demo_rank\n```\nResults:\n```text\n    rank of scalar a=           0\n    rank of matrix b=           2\n    rank of vector pointer c=           1\n    rank of complex scalar d=           0\n    rank of any arbitrary type=           5\n   passed a scalar to an assumed rank,   rank= 0\n   passed an array to an assumed rank,   rank= 1\n   passed an array to an assumed rank,   rank= 2\n   passed a scalar to an unlimited polymorphic rank= 0\n   passed an array to an unlimited polymorphic, rank= 1\n   passed an array to an unlimited polymorphic, rank= 2\n```\n### **Standard**\n\n### **See also**\n\n#### Array inquiry:\n\n- [**size**(3)](#size) -  Determine the size of an array\n- [**rank**](#rank) -  Rank of a data object\n- [**shape**(3)](#shape) -  Determine the shape of an array\n- [**ubound**(3)](#ubound) -  Upper dimension bounds of an array\n- [**lbound**(3)](#lbound) -  Lower dimension bounds of an array\n\n#### State Inquiry:\n\n- [**allocated**(3)](#allocated) -  Status of an allocatable entity\n- [**is_contiguous**(3)](#is_contiguous) -  Test if object is contiguous\n\n#### Kind Inquiry:\n\n- [**kind**(3)](#kind) - Kind of an entity\n\n#### Bit Inquiry:\n\n- [**storage_size**(3)](#storage_size) - Storage size in bits\n- [**bit_size**(3)](#bit_size) -  Bit size inquiry function\n- [**btest**(3)](#btest) - Tests a bit of an _integer_ value.\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n#\n",
  "REAL": "## real\n\n### **Name**\n\n**real** - \\[TYPE:NUMERIC\\] Convert to real type\n\n### **Synopsis**\n```fortran\n  result = real(x [,kind])\n```\n```fortran\n   elemental real(kind=KIND) function real(x,KIND)\n\n    TYPE(kind=**),intent(in) :: x\n    integer(kind=**),intent(in),optional :: KIND\n```\n### **Characteristics**\n\n - the type of **x** may be _integer_, _real_, or _complex_; or a BOZ-literal-constant.\n - **kind** is a _integer_ initialization expression (a constant expression)\n   + If **kind** is present it defines the kind of the _real_ result\n   + if **kind** is not present\n     - when **x** is _complex_ the result is a _real_ of the same kind as **x**.\n     - when **x** is _real_ or _integer_ the result is a _real_ of default kind\n - a kind designated as ** may be any supported kind for the type\n\n### **Description**\n\n**real** converts its argument **x** to a _real_ type.\n\nThe real part of a complex value is returned. For complex values this\nis similar to the modern complex-part-designator **%RE** which also\ndesignates the real part of a _complex_ value.\n\n```fortran\n      z=(3.0,4.0)     ! if z is a complex value\n      print *, z%re == real(z) ! these expressions are equivalent\n```\n### **Options**\n\n- **x**\n  : An _integer_, _real_, or _complex_ value to convert to _real_.\n\n- **kind**\n  : When present the value of **kind** defines the kind of the result.\n\n### **Result**\n\n1.  **real(x)** converts **x** to a default _real_ type if **x** is an _integer_\n    or _real_ variable.\n\n2.  **real(x)** converts a _complex_ value to a _real_ type with the\n    magnitude of the real component of the input with kind type\n    parameter the same as **x**.\n\n3.  **real(x, kind)** is converted to a _real_ type with kind type\n    parameter **kind** if **x** is a _complex_, _integer_, or _real_ variable.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_real\nuse,intrinsic :: iso_fortran_env, only : dp=>real64\nimplicit none\ncomplex              :: zr = (1.0, 2.0)\ndoubleprecision      :: xd=huge(3.0d0)\ncomplex(kind=dp) :: zd=cmplx(4.0e0_dp,5.0e0_dp,kind=dp)\n\n   print *, real(zr), aimag(zr)\n   print *, dble(zd), aimag(zd)\n\n   write(*,*)xd,real(xd,kind=kind(0.0d0)),dble(xd)\nend program demo_real\n```\nResults:\n```\n 1.00000000       2.00000000\n 4.0000000000000000       5.0000000000000000\n 1.7976931348623157E+308  1.7976931348623157E+308  1.7976931348623157E+308\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n- [**aimag**(3)](#aimag) - Imaginary part of complex number\n- [**cmplx**(3)](#cmplx) - Complex conversion function\n- [**conjg**(3)](#conjg) - Complex conjugate function\n\nFortran has strong support for _complex_ values, including many intrinsics\nthat take or produce _complex_ values in addition to algebraic and\nlogical expressions:\n\n[**abs**(3)](#abs),\n[**acosh**(3)](#acosh),\n[**acos**(3)](#acos),\n[**asinh**(3)](#asinh),\n[**asin**(3)](#asin),\n[**atan2**(3)](#atan2),\n[**atanh**(3)](#atanh),\n[**atan**(3)](#atan),\n[**cosh**(3)](#cosh),\n[**cos**(3)](#cos),\n[**co_sum**(3)](#co_sum),\n[**dble**(3)](#dble),\n[**dot_product**(3)](#dot_product),\n[**exp**(3)](#exp),\n[**int**(3)](#int),\n[**is_contiguous**(3)](#is_contiguous),\n[**kind**(3)](#kind),\n[**log**(3)](#log),\n[**matmul**(3)](#matmul),\n[**precision**(3)](#precision),\n[**product**(3)](#product),\n[**range**(3)](#range),\n[**rank**(3)](#rank),\n[**sinh**(3)](#sinh),\n[**sin**(3)](#sin),\n[**sqrt**(3)](#sqrt),\n[**storage_size**(3)](#storage_size),\n[**sum**(3)](#sum),\n[**tanh**(3)](#tanh),\n[**tan**(3)](#tan),\n[**unpack**(3)](#unpack),\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "REDUCE": "## reduce\n\n### **Name**\n\n**reduce** - \\[TRANSFORMATIONAL\\] General reduction of an array\n\n### **Synopsis**\n\nThere are two forms to this function:\n```fortran\n   result = reduce(array, operation [,mask]  [,identity]  [,ordered] )\n```\nor\n```fortran\n   result = reduce (array, operation, dim  &\n   & [,mask] [,identity] [,ordered] )\n```\n```fortran\n    type(TYPE(kind=KIND)) function reduce &\n    & (array, operation, dim, mask, identity, ordered )\n\n     type(TYPE(kind=KIND)),intent(in) :: array\n     pure function                  :: operation\n     integer,intent(in),optional    :: dim\n     logical,optional               :: mask\n     type(TYPE),intent(in),optional :: identity\n     logical,intent(in),optional    :: ordered\n```\n### **Characteristics**\n\n - **array** is an array of any type\n - **operation** is a pure function with exactly two arguments\n   + each argument is scalar, non-allocatable, a nonpointer,\n     nonpolymorphic and nonoptional with the same type and kind as array.\n   + if one argument has the asynchronous, target, or value attribute so\n     shall the other.\n - **dim** is an _integer_ scalar\n - **mask** is a logical conformable with **array**\n - **identity** is a scalar with the same type and type parameters as **array**\n - **ordered** is a logical scalar\n - the result is of the same type and type parameters as **array**.\n\n### **Description**\n\n   **reduce** reduces a list of conditionally selected values from\n   an array to a single value by iteratively applying a binary function.\n\n   Common in functional programming, a **reduce** function applies a\n   binary operator (a pure function with two arguments) to all elements\n   cumulatively.\n\n   **reduce** is a \"higher-order\" function; ie. it is a function that\n   receives other functions as arguments.\n\n   The **reduce** function receives a binary operator (a function with\n   two arguments, just like the basic arithmetic operators). It is first\n   applied to two unused values in the list to generate an accumulator\n   value which is subsequently used as the first argument to the function\n   as the function is recursively applied to all the remaining selected\n   values in the input array.\n\n### **Options**\n\n- **array**\n  : An array of any type and allowed rank to select values from.\n\n- **operation**\n  : shall be a pure function with exactly two arguments;\n  each argument shall be a scalar, nonallocatable,\n  nonpointer, nonpolymorphic, nonoptional dummy data object\n  with the same type and type parameters as **array**. If\n  one argument has the ASYNCHRONOUS, TARGET, or VALUE\n  attribute, the other shall have that attribute. Its result\n  shall be a nonpolymorphic scalar and have the same type\n  and type parameters as **array**. **operation** should\n  implement a mathematically associative operation. It\n  need not be commutative.\n\n  NOTE\n\n  If **operation** is not computationally associative, REDUCE\n  without ORDERED=.TRUE. with the same argument values\n  might not always produce the same result, as the processor\n  can apply the associative law to the evaluation.\n\n  Many operations that mathematically are associative are\n  not when applied to floating-point numbers. The order\n  you sum values in may affect the result, for example.\n\n- **dim**\n  : An integer scalar with a value in the range\n  1<= **dim** <= n, where n is the rank of **array**.\n\n- **mask**\n  : (optional) shall be of type logical and shall be\n  conformable with **array**.\n\n  When present only those elements of **array** are passed\n  to **operation** for which the corresponding elements\n  of **mask** are true, as if **array* was filtered with\n  **pack(3)**.\n\n- **identity**\n  : shall be scalar with the same type and type parameters as **array**.\n  If the initial sequence is empty, the result has the value **identify**\n  if **identify** is present, and otherwise, error termination is\n  initiated.\n\n- **ordered**\n  : shall be a logical scalar. If **ordered** is present with the value\n  _.true._, the calls to the **operator** function begins with the first\n  two elements of **array** and the process continues in row-column\n  order until the sequence has only one element which is the value of the\n  reduction. Otherwise, the compiler is free to assume that the operation\n  is commutative and may evaluate the reduction in the most optimal way.\n\n### **Result**\n\nThe result is of the same type and type parameters as **array**. It is\nscalar if **dim** does not appear.\n\nIf **dim** is present, it indicates the one dimension along which to\nperform the reduction, and the resultant array has a rank reduced by\none relative to the input array.\n\n### **Examples**\n\n   The following examples all use the function MY\\_MULT, which returns\n   the product of its two real arguments.\n```fortran\n   program demo_reduce\n   implicit none\n   character(len=*),parameter :: f='(\"[\",*(g0,\",\",1x),\"]\")'\n   integer,allocatable :: arr(:), b(:,:)\n\n   ! Basic usage:\n      ! the product of the elements of an array\n      arr=[1, 2, 3, 4 ]\n      write(*,*) arr\n      write(*,*) 'product=', reduce(arr, my_mult)\n      write(*,*) 'sum=', reduce(arr, my_sum)\n\n   ! Examples of masking:\n      ! the product of only the positive elements of an array\n      arr=[1, -1, 2, -2, 3, -3 ]\n      write(*,*)'positive value product=',reduce(arr, my_mult, mask=arr>0)\n   ! sum values ignoring negative values\n      write(*,*)'sum positive values=',reduce(arr, my_sum, mask=arr>0)\n\n   ! a single-valued array returns the single value as the\n   ! calls to the operator stop when only one element remains\n      arr=[ 1234 ]\n      write(*,*)'single value sum',reduce(arr, my_sum )\n      write(*,*)'single value product',reduce(arr, my_mult )\n\n   ! Example of operations along a dimension:\n   !  If B is the array   1 3 5\n   !                      2 4 6\n      b=reshape([1,2,3,4,5,6],[2,3])\n      write(*,f) REDUCE(B, MY_MULT),'should be [720]'\n      write(*,f) REDUCE(B, MY_MULT, DIM=1),'should be [2,12,30]'\n      write(*,f) REDUCE(B, MY_MULT, DIM=2),'should be [15, 48]'\n\n   contains\n\n   pure function my_mult(a,b) result(c)\n   integer,intent(in) :: a, b\n   integer            :: c\n      c=a*b\n   end function my_mult\n\n   pure function my_sum(a,b) result(c)\n   integer,intent(in) :: a, b\n   integer            :: c\n      c=a+b\n   end function my_sum\n\n   end program demo_reduce\n```\nResults:\n```text\n     >  1 2 3 4\n     >  product= 24\n     >  sum=     10\n     >  positive value sum= 6\n     >  sum positive values= 6\n     >  single value sum     1234\n     >  single value product 1234\n     > [720, should be [720],\n     > [2, 12, 30, should be [2,12,30],\n     > [15, 48, should be [15, 48],\n```\n### **Standard**\n\n   Fortran 2018\n\n### **See Also**\n- [co_reduce(3)](#co_reduce)\n\n### **Resources**\n\n- [associative:wikipedia](https://en.wikipedia.org/wiki/Associative_property)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "REPEAT": "## repeat\n\n### **Name**\n\n**repeat** - \\[CHARACTER\\] Repeated string concatenation\n\n### **Synopsis**\n```fortran\n    result = repeat(string, ncopies)\n```\n```fortran\n     character(len=len(string)*ncopies) function repeat(string, ncopies)\n\n      character(len=*),intent(in)   :: string\n      integer(kind=**),intent(in)   :: ncopies\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n - **string** is a scalar _character_ type.\n - **ncopies** is a scalar integer.\n - the result is a new scalar of type _character_ of the same kind as\n   **string**\n\n### **Description**\n\n  **repeat** concatenates copies of a string.\n\n### **Options**\n\n- **string**\n  : The input string to repeat\n\n- **ncopies**\n  : Number of copies to make of **string**, greater than or equal to zero (0).\n\n### **Result**\n\n  A new string built up from **ncopies** copies of **string**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_repeat\nimplicit none\n    write(*,'(a)') repeat(\"^v\", 35)         ! line break\n    write(*,'(a)') repeat(\"_\", 70)          ! line break\n    write(*,'(a)') repeat(\"1234567890\", 7)  ! number line\n    write(*,'(a)') repeat(\"         |\", 7)  !\nend program demo_repeat\n```\nResults:\n```text\n > ^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v^v\n > ______________________________________________________________________\n > 1234567890123456789012345678901234567890123456789012345678901234567890\n >          |         |         |         |         |         |         |\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\nFunctions that perform operations on character strings:\n\n- **Elemental:**\n  [**adjustl**(3)](#adjustl),\n  [**adjustr**(3)](#adjustr),\n  [**index**(3)](#index),\n  [**scan**(3)](#scan),\n  [**verify**(3)](#verify)\n\n- **Non-elemental:**\n  [**len_trim**(3)](#len_trim),\n  [**len**(3)](#len),\n  [**repeat**](#repeat),\n  [**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n#\n",
  "RESHAPE": "\n\n## reshape\n\n### **Name**\n\n**reshape** - \\[ARRAY:RESHAPE\\] Function to reshape an array\n\n### **Synopsis**\n```fortran\n    result = reshape( source, shape [,pad] [,order] )\n```\n```fortran\n     type(TYPE(kind=KIND)) function reshape\n\n      type(TYPE(kind=KIND)),intent(in)          :: source(..)\n      integer(kind=**),intent(in)               :: shape(:)\n      type(TYPE(kind=KIND)),intent(in),optional :: pad(..)\n      integer(kind=**),intent(in),optional      :: order(:)\n```\n### **Characteristics**\n\n - **source** is an array of any type\n - **shape** defines a Fortran shape and therefore an _integer_ vector\n   (of rank one) of constant size of up to 16 non-negative values.\n - **pad** is the same type as **source**\n - **order** is the same shape as **shape**\n - The result is an array of shape **shape** with the same type as **source**.\n - a kind designated as ** may be any supported kind for the type\n\n### **Description**\n\n**reshape** constructs an array of arbitrary shape **shape** using the elements\nfrom **source** and possibly **pad** to fill it.\n\nIf necessary, the new array may be padded with elements from **pad**\nor permuted as defined by **order**.\n\nAmong many other uses, **reshape** can be used to reorder a Fortran array\nto match C array ordering before the array is passed from Fortran to a\nC procedure.\n\n### **Options**\n\n- **source**\n  : an array containing the elements to be copied to the result.\n  there must be enough elements in the source to fill the new shape\n  if **pad** is omitted or has size zero. Expressed in Fortran ...\n```fortran\n   if(.not.present(pad))then\n      if(size(source) < product(shape))then\n        stop 'not enough elements in the old array to fill the new one'\n      endif\n   endif\n```\n- **shape**\n  : This is the shape of the new array being generated.\n    Being by definition a shape; all elements are either positive integers\n    or zero, the size but be 1 or greater, it may have up to 16 elements\n    but must be of constant fixed size and rank one.\n\n- **pad**\n  : used to fill in extra values if the result array is larger than **source**.\n    It will be used repeatedly after all the elements of **source** have been\n    placed in the result until the result has all elements assigned.\n  : If it is absent or is a zero-sized array, you can only make\n    **source** into another array of the same size as **source** or smaller.\n\n- **order**\n  : used to insert elements in the result in an order other\n    than the normal Fortran array element order, in which the first dimension\n    varies fastest.\n  : By definition of ranks the values have to be a permutation of the numbers\n    from 1 to n, where n is the rank of **shape**.\n  : the elements of **source** and pad are placed into the result in order;\n    changing the left-most rank most rapidly by default. To change the order by\n    which the elements are placed in the result use **order**.\n\n### **Result**\n\nThe result is an array of shape **shape** with the same type and type\nparameters as **source**. It is first filled with the values of elements\nof **source**, with the remainder filled with repeated copies of **pad**\nuntil all elements are filled. The new array may be smaller than\n**source**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_reshape\nimplicit none\n! notice the use of \"shape(box)\" on the RHS\ninteger :: box(3,4)=reshape([1,2,3,4,5,6,7,8,9,10,11,12],shape(box))\ninteger,allocatable :: v(:,:)\ninteger :: rc(2)\n   ! basics0\n    ! what is the current shape of the array?\n    call printi('shape of box is ',box)\n    ! change the shape\n    call printi('reshaped ',reshape(box,[2,6]))\n    call printi('reshaped ',reshape(box,[4,3]))\n\n   ! fill in row column order using order\n    v=reshape([1,2,3,4,10,20,30,40,100,200,300,400],[1,12])\n    call printi('here is some data to shape',v)\n    call printi('normally fills columns first ',reshape([v],[3,4]))\n    call printi('fill rows first', reshape([v],[3,4],order=[2,1]))\n\n    ! if we take the data and put in back in filling\n    ! rows first instead of columns, and flipping the\n    ! height and width of the box we not only fill in\n    ! a vector using row-column order we actually\n    ! transpose it.\n    rc(2:1:-1)=shape(box)\n    ! copy the data in changing column number fastest\n    v=reshape(box,rc,order=[2,1])\n    call printi('reshaped and reordered',v)\n    ! of course we could have just done a transpose\n    call printi('transposed',transpose(box))\n\n   ! making the result bigger than source using pad\n    v=reshape(box,rc*2,pad=[-1,-2,-3],order=[2,1])\n    call printi('bigger and padded and reordered',v)\ncontains\n\nsubroutine printi(title,arr)\nimplicit none\n\n!@(#) print small 2d integer arrays in row-column format\n\ncharacter(len=*),parameter :: all='(*(g0,1x))' ! a handy format\ncharacter(len=*),intent(in)  :: title\ninteger,intent(in)           :: arr(:,:)\ninteger                      :: i\ncharacter(len=:),allocatable :: biggest\n\n   print all\n   print all, trim(title),':(',shape(arr),')'  ! print title\n   biggest='           '  ! make buffer to write integer into\n   ! find how many characters to use for integers\n   write(biggest,'(i0)')ceiling(log10(max(1.0,real(maxval(abs(arr))))))+2\n   ! use this format to write a row\n   biggest='(\" > [\",*(i'//trim(biggest)//':,\",\"))'\n   ! print one row of array at a time\n   do i=1,size(arr,dim=1)\n      write(*,fmt=biggest,advance='no')arr(i,:)\n      write(*,'(\" ]\")')\n   enddo\n\nend subroutine printi\n\nend program demo_reshape\n```\nResults:\n```text\n   shape of box is :( 3 4 )\n    > [   1,   4,   7,  10 ]\n    > [   2,   5,   8,  11 ]\n    > [   3,   6,   9,  12 ]\n\n   reshaped :( 2 6 )\n    > [   1,   3,   5,   7,   9,  11 ]\n    > [   2,   4,   6,   8,  10,  12 ]\n\n   reshaped :( 4 3 )\n    > [   1,   5,   9 ]\n    > [   2,   6,  10 ]\n    > [   3,   7,  11 ]\n    > [   4,   8,  12 ]\n\n   here is some data to shape :( 1 12 )\n    > [   1,   2,   3,   4,  10,  20,  30,  40, 100, 200, 300, 400 ]\n\n   normally fills columns first :( 3 4 )\n    > [    1,    4,   30,  200 ]\n    > [    2,   10,   40,  300 ]\n    > [    3,   20,  100,  400 ]\n\n   fill rows first :( 3 4 )\n    > [    1,    2,    3,    4 ]\n    > [   10,   20,   30,   40 ]\n    > [  100,  200,  300,  400 ]\n\n   reshaped and reordered :( 4 3 )\n    > [   1,   2,   3 ]\n    > [   4,   5,   6 ]\n    > [   7,   8,   9 ]\n    > [  10,  11,  12 ]\n\n   transposed :( 4 3 )\n    > [   1,   2,   3 ]\n    > [   4,   5,   6 ]\n    > [   7,   8,   9 ]\n    > [  10,  11,  12 ]\n\n   bigger and padded and reordered :( 8 6 )\n    > [   1,   2,   3,   4,   5,   6 ]\n    > [   7,   8,   9,  10,  11,  12 ]\n    > [  -1,  -2,  -3,  -1,  -2,  -3 ]\n    > [  -1,  -2,  -3,  -1,  -2,  -3 ]\n    > [  -1,  -2,  -3,  -1,  -2,  -3 ]\n    > [  -1,  -2,  -3,  -1,  -2,  -3 ]\n    > [  -1,  -2,  -3,  -1,  -2,  -3 ]\n    > [  -1,  -2,  -3,  -1,  -2,  -3 ]\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**shape**(3)](#shape),\n[**pack**(3)](#pack),\n[**transpose**(3)](#transpose)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n\n",
  "RRSPACING": "## rrspacing\n\n### **Name**\n\n**rrspacing** - \\[MODEL_COMPONENTS\\] Reciprocal of the relative spacing of a numeric type\n\n### **Synopsis**\n```fortran\n    result = rrspacing(x)\n```\n```fortran\n     elemental real(kind=KIND) function rrspacing(x)\n\n      real(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **x** is type _real_ an any kind\n - The return value is of the same type and kind as **x**.\n\n### **Description**\n\n**rrspacing** returns the reciprocal of the relative spacing of model\nnumbers near **x**.\n\n<!--\n 5 Result Value. The result has the value |Y* b-e|*bp = ABS (FRACTION (Y)) * RADIX (X) / EPSILON (X),\n    where b, e, and p are as defined in 16.4 for Y, the value nearest to X in the model for real values whose kind type\n    parameter is that of X; if there are two such values, the value of greater absolute value is taken. If X is an IEEE\n    infinity, the result is an IEEE NaN. If X is an IEEE NaN, the result is that NaN.\n 6 Example. RRSPACING (-3.0) has the value 0:75x224 for reals whose model is as in 16.4, NOTE 1.\n-->\n\n### **Options**\n\n- **x**\n  : Shall be of type _real_.\n\n### **Result**\n\n  The return value is of the same type and kind as **x**. The value returned\n  is equal to **abs(fraction(x)) \\* float(radix(x))\\*\\*digits(x)**.\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**exponent**(3)](#exponent),\n[**fraction**(3)](#fraction),\n[**huge**(3)](#huge),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**nearest**(3)](#nearest),\n[**precision**(3)](#precision),\n[**radix**(3)](#radix),\n[**range**(3)](#range),\n[**scale**(3)](#scale),\n[**set_exponent**(3)](#set_exponent),\n[**spacing**(3)](#spacing),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions_\n",
  "SAME_TYPE_AS": "## same_type_as\n\n### **Name**\n\n**same_type_as** - \\[STATE:INQUIRY\\] Query dynamic types for equality\n\n### **Synopsis**\n```fortran\n    result = same_type_as(a, b)\n```\n```fortran\n     logical same_type_as(a, b)\n\n      type(TYPE(kind=KIND)),intent(in) :: a\n      type(TYPE(kind=KIND)),intent(in) :: b\n```\n### **Characteristics**\n\n- **a** shall be an object of extensible declared type or unlimited\n  polymorphic. If it is a polymorphic pointer, it shall not have\n  an undefined association status.\n\n- **b** shall be an object of extensible declared type or unlimited\n  polymorphic. If it is a polymorphic pointer, it shall not have\n  an undefined association status.\n\n### **Description**\n\n**same_type_as** queries the dynamic types of objects for equality.\n\n### **Options**\n\n- **a**\n  : object to compare to **b** for equality of type\n\n- **b**\n  : object to be compared to for equality of type\n\n### **Result**\n\n  If the dynamic type of **a** or **b** is extensible, the result is true\n  if and only if the dynamic type of **a** is the same as the dynamic\n  type of **b**. If neither **a** nor **b** has extensible dynamic type,\n  the result is processor dependent.\n\n    NOTE1\n\n  The dynamic type of a disassociated pointer or unallocated allocatable\n  variable is its declared type. An unlimited polymorphic entity has no\n  declared type.\n\n    NOTE2\n\n  The test performed by SAME_TYPE_AS is not the same as the test performed\n  by the type guard TYPE IS. The test performed by SAME_TYPE_AS does\n  not consider kind type parameters.\n\nSample program:\n```fortran\n  ! program demo_same_type_as\n  module M_ether\n  implicit none\n  private\n\n  type   :: dot\n    real :: x=0\n    real :: y=0\n  end type dot\n\n  type, extends(dot) :: point\n    real :: z=0\n  end type point\n\n  type something_else\n  end type something_else\n\n  public :: dot\n  public :: point\n  public :: something_else\n\n  end module M_ether\n\n  program demo_same_type_as\n  use M_ether, only : dot, point, something_else\n  implicit none\n  type(dot) :: dad, mom\n  type(point) :: me\n  type(something_else) :: alien\n\n   write(*,*)same_type_as(me,dad),'I am descended from Dad, but equal?'\n   write(*,*)same_type_as(me,me) ,'I am what I am'\n   write(*,*)same_type_as(dad,mom) ,'what a pair!'\n\n   write(*,*)same_type_as(dad,me),'no paradox here'\n   write(*,*)same_type_as(dad,alien),'no relation'\n\n   call pointers()\n   contains\n   subroutine pointers()\n   ! Given the declarations and assignments\n   type t1\n      real c\n   end type\n   type, extends(t1) :: t2\n   end type\n   class(t1), pointer :: p, q, r\n      allocate (p, q)\n      allocate (t2 :: r)\n      ! the result of SAME_TYPE_AS (P, Q) will be true, and the result\n      ! of SAME_TYPE_AS (P, R) will be false.\n      write(*,*)'(P,Q)',same_type_as(p,q),\"mind your P's and Q's\"\n      write(*,*)'(P,R)',same_type_as(p,r)\n   end subroutine pointers\n\n  end program demo_same_type_as\n```\nResults:\n```text\n    F I am descended from Dad, but equal?\n    T I am what I am\n    T what a pair!\n    F no paradox here\n    F no relation\n    (P,Q) T mind your P's and Q's\n    (P,R) F\n```\n### **Standard**\n\nFortran 2003\n\n### **See Also**\n\n[**extends_type_of**(3)](#extends_type_of)\n\n _fortran-lang intrinsic descriptions_\n",
  "SCALE": "## scale\n\n### **Name**\n\n**scale** - \\[MODEL_COMPONENTS\\] Scale a real value by a whole power of the radix\n\n### **Synopsis**\n```fortran\n    result = scale(x, i)\n```\n```fortran\n     elemental real(kind=KIND) function scale(x, i)\n\n      real(kind=KIND),intent(in)   :: x\n      integer(kind=**),intent(in)  :: i\n```\n### **Characteristics**\n\n   - **x** is type _real_ of any kind\n   - **i** is type an _integer_ of any kind\n   - the result is _real_ of the same kind as **x**\n\n### **Description**\n\n   **scale** returns x \\* **radix(x)\\*\\*i**.\n\n   It is almost certain the radix(base) of the platform is two, therefore\n   **scale** is generally the same as **x*2\\*\\*i**\n\n### **Options**\n\n- **x**\n  : the value to multiply by **radix(x)\\*\\*i**. Its type and kind is used\n  to determine the radix for values with its characteristics and determines\n  the characteristics of the result, so care must be taken the returned\n  value is within the range of the characteristics of **x**.\n\n- **i**\n  : The power to raise the radix of the machine to\n\n### **Result**\n\nThe return value is **x \\* radix(x)\\*\\*i**, assuming that value can be\nrepresented by a value of the type and kind of **x**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_scale\nimplicit none\nreal :: x\ncomplex :: c\ninteger :: i\n   x = 1.0\n   print *, (scale(x,i),i=1,5)\n   x = 3.0\n   print *, (scale(x,i),i=1,5)\n   print *, (scale(log(1.0),i),i=1,5)\n   ! on modern machines radix(x) is almost certainly 2\n   x = 178.1387e-4\n   i = 5\n   print *, x, i, scale(x, i), x*radix(x)**i\n   ! x*radix(x)**i is the same except roundoff errors are not restricted\n   i = 2\n   print *, x, i, scale(x, i), x*radix(x)**i\n   ! relatively easy to do complex values as well\n   c=(3.0,4.0)\n   print *, c, i, scale_complex(c, i)!, c*radix(c)**i\ncontains\nfunction scale_complex(x, n)\n! example supporting complex value for default kinds\ncomplex, intent(in) :: x\ninteger, intent(in) :: n\ncomplex :: scale_complex\n   scale_complex=cmplx(scale(x%re, n), scale(x%im, n), kind=kind(x%im))\nend function scale_complex\nend program demo_scale\n```\nResults:\n```text\n > 2.00000000 4.00000000  8.00000000     16.0000000 32.0000000\n > 6.00000000 12.0000000 24.0000000      48.0000000 96.0000000\n > 0.00000000 0.00000000  0.00000000     0.00000000 0.00000000\n > 1.78138707E-02    5   0.570043862      0.570043862\n > 1.78138707E-02    2   7.12554827E-02   7.12554827E-02\n > (3.00000000,4.00000000) 2 (12.0000000,16.0000000)\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**exponent**(3)](#exponent),\n[**fraction**(3)](#fraction),\n[**huge**(3)](#huge),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**nearest**(3)](#nearest),\n[**precision**(3)](#precision),\n[**radix**(3)](#radix),\n[**range**(3)](#range),\n[**rrspacing**(3)](#rrspacing),\n[**set_exponent**(3)](#set_exponent),\n[**spacing**(3)](#spacing),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SCAN": "## scan\n\n### **Name**\n\n**scan** - \\[CHARACTER:SEARCH\\] Scan a string for the presence of a set of characters\n\n### **Synopsis**\n```fortran\n    result = scan( string, set, [,back] [,kind] )\n```\n```fortran\n     elemental integer(kind=KIND) function scan(string,set,back,kind)\n\n      character(len=*,kind=**),intent(in) :: string\n      character(len=*,kind=**),intent(in) :: set\n      logical,intent(in),optional :: back\n      integer,intent(in),optional :: kind\n```\n### **Characteristics**\n\n - **string** is a _character_ string of any kind\n - **set** must be a _character_ string with the same kind as **string**\n - **back** is a _logical_\n - **kind** is a scalar _integer_ constant expression\n - the result is an _integer_ with the kind specified by **kind**. If\n   **kind** is not present the result is a default _integer_.\n\n### **Description**\n\n  **scan** scans a **string** for any of the characters in a **set**\n  of characters.\n\n  If **back** is either absent or equals _.false._, this function\n  returns the position of the leftmost character of **STRING** that is\n  in **set**. If **back** equals _.true._, the rightmost position is\n  returned. If no character of **set** is found in **string**, the result\n  is zero.\n\n### **Options**\n\n- **string**\n  : the string to be scanned\n\n- **set**\n  : the set of characters which will be matched\n\n- **back**\n  : if _.true._ the position of the rightmost character matched is\n  returned, instead of the leftmost.\n\n- **kind**\n  : the kind of the returned value is the same as **kind** if\n  present. Otherwise a default _integer_ kind is returned.\n\n### **Result**\n\n  If **back** is absent or is present with the value false and if\n  **string** contains at least one character that is in **set**, the value\n  of the result is the position of the leftmost character of **string**\n  that is in **set**.\n\n  If **back** is present with the value true and if **string** contains at\n  least one character that is in **set**, the value of the result is the\n  position of the rightmost character of **string** that is in **set**.\n\n  The value of the result is zero if no character of STRING is in SET\n  or if the length of STRING or SET is zero.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_scan\nimplicit none\n   write(*,*) scan(\"fortran\", \"ao\")          ! 2, found 'o'\n   write(*,*) scan(\"fortran\", \"ao\", .true.)  ! 6, found 'a'\n   write(*,*) scan(\"fortran\", \"c++\")         ! 0, found none\nend program demo_scan\n```\nResults:\n```text\n >            2\n >            6\n >            0\n```\n### **Standard**\n\nFortran 95 , with KIND argument - Fortran 2003\n\n### **See Also**\n\nFunctions that perform operations on character strings, return lengths\nof arguments, and search for certain arguments:\n\n- **Elemental:**\n  [**adjustl**(3)](#adjustl), [**adjustr**(3)](#adjustr), [**index**(3)](#index),\n  [**verify**(3)](#verify)\n\n- **Nonelemental:**\n  [**len\\_trim**(3)](#len_trim),\n  [**len**(3)](#len),\n  [**repeat**(3)](#repeat), [**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SELECTED_CHAR_KIND": "## selected_char_kind\n\n### **Name**\n\n**selected_char_kind** - \\[KIND\\] Select character kind such as \"Unicode\"\n\n### **Synopsis**\n```fortran\n    result = selected_char_kind(name)\n```\n```fortran\n     integer function selected_char_kind(name)\n\n      character(len=*),intent(in) :: name\n```\n### **Characteristics**\n\n - **name** is a default _character_ scalar\n - the result is a default _integer_ scalar\n\n### **Description**\n\n  **selected_char_kind** returns a kind parameter value for the\n  character set named **name**.\n\n  If a name is not supported, -1 is returned. Otherwise the result is a\n  value equal to that kind type parameter value.\n\n  The list of supported names is processor-dependent except for \"DEFAULT\".\n\n + If **name** has the value \"DEFAULT\", then the result has a value equal to\n   that of the kind type parameter of default character. This name is\n   always supported.\n\n + If **name** has the value \"ASCII\", then the result has a value equal\n   to that of the kind type parameter of ASCII character.\n\n + If **name** has the value \"ISO_10646\", then the result has a value equal\n   to that of the kind type parameter of the ISO 10646 character kind\n   (corresponding to UCS-4 as specified in ISO/IEC 10646).\n\n + If **name** is a processor-defined name of some other character kind\n   supported by the processor, then the result has a value equal to that\n   kind type parameter value.\n  Pre-defined names include \"ASCII\" and \"ISO_10646\".\n\n  The NAME is interpreted without respect to case or trailing blanks.\n\n### **Options**\n\n- **name**\n  : A name to query the processor-dependent kind value of, and/or to determine\n  if supported. **name**, interpreted without respect to case or\n  trailing blanks.\n\n  Currently, supported character sets include \"ASCII\" and \"DEFAULT\" and\n  \"ISO_10646\" (Universal Character Set, UCS-4) which is commonly known as\n  \"Unicode\". Supported names other than \"DEFAULT\" are processor dependent.\n\n### **Result**\n\n\n### **Examples**\n\nSample program:\n\n```fortran\nLinux\nprogram demo_selected_char_kind\nuse iso_fortran_env\nimplicit none\n\nintrinsic date_and_time,selected_char_kind\n\n! set some aliases for common character kinds\n! as the numbers can vary from platform to platform\n\ninteger, parameter :: default = selected_char_kind (\"default\")\ninteger, parameter :: ascii =   selected_char_kind (\"ascii\")\ninteger, parameter :: ucs4  =   selected_char_kind ('ISO_10646')\ninteger, parameter :: utf8  =   selected_char_kind ('utf-8')\n\n! assuming ASCII and UCS4 are supported (ie. not equal to -1)\n! define some string variables\ncharacter(len=26, kind=ascii ) :: alphabet\ncharacter(len=30, kind=ucs4  ) :: hello_world\ncharacter(len=30, kind=ucs4  ) :: string\n\n   write(*,*)'ASCII     ',&\n    & merge('Supported    ','Not Supported',ascii /= -1)\n   write(*,*)'ISO_10646 ',&\n    & merge('Supported    ','Not Supported',ucs4 /= -1)\n   write(*,*)'UTF-8     ',&\n    & merge('Supported    ','Not Supported',utf8 /= -1)\n\n   if(default.eq.ascii)then\n       write(*,*)'ASCII is the default on this processor'\n   endif\n\n  ! for constants the kind precedes the value, somewhat like a\n  ! BOZ constant\n   alphabet = ascii_\"abcdefghijklmnopqrstuvwxyz\"\n   write (*,*) alphabet\n\n   hello_world = ucs4_'Hello World and Ni Hao -- ' &\n                 // char (int (z'4F60'), ucs4)     &\n                 // char (int (z'597D'), ucs4)\n\n  ! an encoding option is required on OPEN for non-default I/O\n   if(ucs4 /= -1 )then\n      open (output_unit, encoding='UTF-8')\n      write (*,*) trim (hello_world)\n   else\n      write (*,*) 'cannot use utf-8'\n   endif\n\n   call create_date_string(string)\n   write (*,*) trim (string)\n\ncontains\n\n! The following produces a Japanese date stamp.\nsubroutine create_date_string(string)\nintrinsic date_and_time,selected_char_kind\ninteger,parameter :: ucs4 = selected_char_kind(\"ISO_10646\")\ncharacter(len=1,kind=ucs4),parameter :: &\n       nen =   char(int( z'5e74' ),ucs4), & ! year\n       gatsu = char(int( z'6708' ),ucs4), & ! month\n       nichi = char(int( z'65e5' ),ucs4)    ! day\ncharacter(len= *, kind= ucs4) string\ninteger values(8)\n   call date_and_time(values=values)\n   write(string,101) values(1),nen,values(2),gatsu,values(3),nichi\n 101 format(*(i0,a))\nend subroutine create_date_string\n\nend program demo_selected_char_kind\n```\nResults:\n\nThe results are very processor-dependent\n```text\n >  ASCII     Supported\n >  ISO_10646 Supported\n >  UTF-8     Not Supported\n >  ASCII is the default on this processor\n >  abcdefghijklmnopqrstuvwxyz\n >  Hello World and Ni Hao -- \u4f60\u597d\n >  2022\u5e7410\u670815\u65e5\n```\n### **Standard**\n\nFortran 2003\n\n### **See also**\n\n[**selected_int_kind**(3)](#selected_int_kind),\n[**selected_real_kind**(3)](#selected_real_kind)\n\n[**achar**(3)](#achar),\n[**char**(3)](#char),\n[**ichar**(3)](#ichar),\n[**iachar**(3)](#iachar)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SELECTED_INT_KIND": "## selected_int_kind\n\n### **Name**\n\n**selected_int_kind** - \\[KIND\\] Choose integer kind\n\n### **Synopsis**\n```fortran\n    result = selected_int_kind(r)\n```\n```fortran\n    integer function selected_int_kind(r)\n\n     integer(kind=KIND),intent(in) :: r\n```\n### **Characteristics**\n\n - **r** is an _integer_ scalar.\n - the result is an default integer scalar.\n\n### **Description**\n\n  **selected_int_kind** return the kind value of the smallest\n  integer type that can represent all values ranging from **-10\\*\\*r**\n  (exclusive) to **10\\*\\*r** (exclusive). If there is no integer kind\n  that accommodates this range, selected_int_kind returns **-1**.\n\n### **Options**\n\n- **r**\n  : The value specifies the required range of powers of ten that need\n    supported by the kind type being returned.\n\n### **Result**\n\n  The result has a value equal to the value of the kind type parameter\n  of an integer type that represents all values in the requested range.\n\n  if no such kind type parameter is available on the processor, the\n  result is -1.\n\n  If more than one kind type parameter meets the criterion, the value\n  returned is the one with the smallest decimal exponent range, unless\n  there are several such values, in which case the smallest of these\n  kind values is returned.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_selected_int_kind\nimplicit none\ninteger,parameter :: k5 = selected_int_kind(5)\ninteger,parameter :: k15 = selected_int_kind(15)\ninteger(kind=k5) :: i5\ninteger(kind=k15) :: i15\n\n    print *, huge(i5), huge(i15)\n\n    ! the following inequalities are always true\n    print *, huge(i5) >= 10_k5**5-1\n    print *, huge(i15) >= 10_k15**15-1\nend program demo_selected_int_kind\n```\nResults:\n```text\n  >   2147483647  9223372036854775807\n  >  T\n  >  T\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**aint**(3)](#aint),\n[**anint**(3)](#anint),\n[**int**(3)](#int),\n[**nint**(3)](#nint),\n[**ceiling**(3)](#ceiling),\n[**floor**(3)](#floor)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SELECTED_REAL_KIND": "## selected_real_kind\n\n### **Name**\n\n**selected_real_kind** - \\[KIND\\] Choose real kind\n\n### **Synopsis**\n```fortran\n    result = selected_real_kind([p] [,r] [,radix] )\n```\n```fortran\n    integer function selected_int_kind(r)\n\n     real(kind=KIND),intent(in),optional :: p\n     real(kind=KIND),intent(in),optional :: r\n     real(kind=KIND),intent(in),optional :: radix\n```\n### **Characteristics**\n\n - **p** is an _integer_ scalar\n - **r** is an _integer_ scalar\n - **radix** is an _integer_ scalar\n - the result is an default _integer_ scalar\n\n### **Description**\n\n   **selected_real_kind** return the kind value of a _real_ data type with\n   decimal precision of at least **p** digits, exponent range of at least\n   **r**, and with a radix of **radix**. That is, if such a kind exists\n\n    + it has the decimal precision as returned by **precision**(3) of at\n      least **p** digits.\n    + a decimal exponent range, as returned by the function **range**(3)\n      of at least **r**\n    + a radix, as returned by the function **radix**(3) , of **radix**,\n\n   If the requested kind does not exist, -1 is returned.\n\n   At least one argument shall be present.\n\n### **Options**\n\n- **p**\n  : the requested precision\n\n- **r**\n  : the requested range\n\n- **radix**\n  : the desired radix\n\n  Before **Fortran 2008**, at least one of the arguments **r** or **p** shall\n  be present; since **Fortran 2008**, they are assumed to be zero if\n  absent.\n\n### **Result**\n\n  selected_real_kind returns the value of the kind type parameter of\n  a real data type with decimal precision of at least **p** digits,\n  a decimal exponent range of at least R, and with the requested\n  **radix**.\n\n  If **p** or **r** is absent, the result value is the same as if it\n  were present with the value zero.\n\n\n  If the **radix** parameter is absent, there is no requirement on\n  the radix of the selected kind and real kinds with any radix can be\n  returned.\n\n  If more than one real data type meet the criteria, the kind\n  of the data type with the smallest decimal precision is returned. If\n  no real data type matches the criteria, the result is\n\n  - **-1**\n  : if the processor does not support a real data type with a\n    precision greater than or equal to **p**, but the **r** and **radix**\n    requirements can be fulfilled\n\n  - **-2**\n  : if the processor does not support a real type with an\n    exponent range greater than or equal to **r**, but **p** and **radix** are\n    fulfillable\n\n  - **-3**\n  : if **radix** but not **p** and **r** requirements are fulfillable\n\n  - **-4**\n  : if **radix** and either **p** or **r** requirements are fulfillable\n\n  - **-5**\n  : if there is no real type with the given **radix**\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_selected_real_kind\nimplicit none\ninteger,parameter :: p6 = selected_real_kind(6)\ninteger,parameter :: p10r100 = selected_real_kind(10,100)\ninteger,parameter :: r400 = selected_real_kind(r=400)\nreal(kind=p6) :: x\nreal(kind=p10r100) :: y\nreal(kind=r400) :: z\n\n   print *, precision(x), range(x)\n   print *, precision(y), range(y)\n   print *, precision(z), range(z)\nend program demo_selected_real_kind\n```\nResults:\n```text\n  >            6          37\n  >           15         307\n  >           18        4931\n```\n### **Standard**\n\nFortran 95 ; with RADIX - Fortran 2008\n\n### **See Also**\n\n[**precision**(3)](#precision),\n[**range**(3)](#range),\n[**radix**(3)](#radix)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SET_EXPONENT": "## set_exponent\n\n### **Name**\n\n**set_exponent** - \\[MODEL_COMPONENTS\\] real value with specified exponent\n\n### **Synopsis**\n```fortran\n    result = set_exponent(x, i)\n```\n```fortran\n     elemental real(kind=KIND) function set_exponent(x,i)\n\n      real(kind=KIND),intent(in) :: x\n      integer(kind=**),intent(in) :: i\n```\n### **Characteristics**\n\n - **x** is type _real_\n - **i** is type _integer_\n - a kind designated as ** may be any supported kind for the type\n\n - The return value is of the same type and kind as **x**.\n\n### **Description**\n\n  **set_exponent** returns the real number whose fractional part is\n  that of **x** and whose exponent part is **i**.\n\n### **Options**\n\n- **x**\n  : Shall be of type _real_.\n\n- **i**\n  : Shall be of type _integer_.\n\n### **Result**\n\n  The return value is of the same type and kind as **x**. The real number\n  whose fractional part is that of **x** and whose exponent part\n  if **i** is returned; it is **fraction(x) \\* radix(x)\\*\\*i**.\n\n  If **x** has the value zero, the result has the same value as **x**.\n\n  If **x** is an IEEE infinity, the result is an IEEE NaN.\n\n  If **x** is an IEEE NaN, the result is the same NaN.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_setexp\nimplicit none\nreal :: x = 178.1387e-4\ninteger :: i = 17\n   print *, set_exponent(x, i), fraction(x) * radix(x)**i\nend program demo_setexp\n```\nResults:\n```text\n      74716.7891       74716.7891\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**exponent**(3)](#exponent),\n[**fraction**(3)](#fraction),\n[**huge**(3)](#huge),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**nearest**(3)](#nearest),\n[**precision**(3)](#precision),\n[**radix**(3)](#radix),\n[**range**(3)](#range),\n[**rrspacing**(3)](#rrspacing),\n[**scale**(3)](#scale),\n[**spacing**(3)](#spacing),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions_\n",
  "SHAPE": "## shape\n\n### **Name**\n\n**shape** - \\[ARRAY:INQUIRY\\] Determine the shape of an array or scalar\n\n### **Synopsis**\n```fortran\n  result = shape( source [,kind] )\n```\n```fortran\n   integer(kind=KIND) function shape( source, KIND )\n\n    type(TYPE(kind=**)),intent(in)       :: source(..)\n    integer(kind=**),intent(in),optional :: KIND\n```\n### **Characteristics**\n\n  - a kind designated as ** may be any supported kind for the type\n\n  - **source** is an array or scalar of any type. If **source** is a pointer\n    it must be associated and allocatable arrays must be allocated. It shall\n    not be an assumed-size array.\n\n  - **KIND** is a constant _integer_ initialization expression.\n\n  - the result is an _integer_ array of rank one with size equal to the\n    rank of **source** of the kind specified by **KIND** if **KIND**\n    is present, otherwise it has the default integer kind.\n\n### **Description**\n\n  **shape** queries the shape of an array.\n\n### **Options**\n\n- **source**\n  : an array or scalar of any type. If **source** is a pointer it\n  must be associated and allocatable arrays must be allocated.\n\n- **kind**\n  : indicates the kind parameter of the result.\n\n### **Result**\n\n  An _integer_ array of rank one with as many elements as **source**\n  has dimensions.\n\n  The elements of the resulting array correspond to the extent of\n  **source** along the respective dimensions.\n\n  If **source** is a scalar, the result is an empty array (a rank-one\n  array of size zero).\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_shape\nimplicit none\ncharacter(len=*),parameter :: all='(*(g0,1x))'\ninteger, dimension(-1:1, -1:2) :: a\n   print all, 'shape of array=',shape(a)\n   print all, 'shape of constant=',shape(42)\n   print all, 'size of shape of constant=',size(shape(42))\n   print all, 'ubound of array=',ubound(a)\n   print all, 'lbound of array=',lbound(a)\nend program demo_shape\n```\nResults:\n```text\n   shape of array= 3 4\n   shape of constant=\n   size of shape of constant= 0\n   ubound of array= 1 2\n   lbound of array= -1 -1\n```\n### **Standard**\n\nFortran 95 ; with KIND argument Fortran 2003\n\n### **See Also**\n\n#### Array inquiry:\n\n- [**size**(3)](#size) -  Determine the size of an array\n- [**rank**(3)](#rank) -  Rank of a data object\n- [**ubound**(3)](#ubound) -  Upper dimension bounds of an array\n- [**lbound**(3)](#lbound) -  Lower dimension bounds of an array\n\n#### State Inquiry:\n\n- [**allocated**(3)](#allocated) -  Status of an allocatable entity\n- [**is_contiguous**(3)](#is_contiguous) -  Test if object is contiguous\n\n#### Kind Inquiry:\n\n- [**kind**(3)](#kind) - Kind of an entity\n\n#### Bit Inquiry:\n\n- [**storage_size**(3)](#storage_size) - Storage size in bits\n- [**bit_size**(3)](#bit_size) -  Bit size inquiry function\n- [**btest**(3)](#btest) - Tests a bit of an _integer_ value.\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SHIFTA": "## shifta\n\n### **Name**\n\n**shifta** - \\[BIT:SHIFT\\] Right shift with fill\n\n### **Synopsis**\n```fortran\n    result = shifta(i, shift )\n```\n```fortran\n     elemental integer(kind=KIND) function shifta(i, shift)\n\n      integer(kind=KIND),intent(in) :: i\n      integer(kind=**),intent(in) :: shift\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n - **i** is an _integer_ of any kind\n - **shift** is an _integer_ of any kind\n - the result will automatically be of the same type, kind and rank as **i**.\n\n### **Description**\n\n  **shifta** returns a value corresponding to **i** with all of the\n  bits shifted right by **shift** places and the vacated bits on the\n  left filled with the value of the original left-most bit.\n\n### **Options**\n\n- **i**\n  : The initial value to shift and fill\n\n- **shift**\n  : how many bits to shift right.\n    It shall be nonnegative and less than or equal to **bit_size(i)**.\n    or the value is undefined. If **shift** is zero the result is **i**.\n\n### **Result**\n\n  The result has the value obtained by shifting the bits of **i** to\n  the right **shift**  bits and replicating the leftmost bit of **i**\n  in the left **shift** bits (Note the leftmost bit in \"two's complement\"\n  representation is the sign bit).\n\n  Bits shifted out from the right end are lost.\n\n  If **shift** is zero the result is **i**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_shifta\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger(kind=int32) :: ival\ninteger             :: shift\ninteger(kind=int32) :: oval\ninteger(kind=int32),allocatable :: ivals(:)\ninteger             :: i\ninteger(kind=int8)  :: arr(2,2)=reshape([2,4,8,16],[2,2])\n\n  ! basic usage\n  write(*,*)shifta(100,3)\n\n  ! loop through some interesting values\n   shift=5\n\n   ivals=[ -1, -0, +0, +1, &\n   & int(b\"01010101010101010101010101010101\"), &\n   & int(b\"10101010101010101010101010101010\"), &\n   & int(b\"00000000000000000000000000011111\") ]\n\n   ! does your platform distinguish between +0 and -0?\n   ! note the original leftmost bit is used to fill in the vacated bits\n\n   write(*,'(/,\"SHIFT =  \",i0)') shift\n   do i=1,size(ivals)\n      ival=ivals(i)\n      write(*,'(  \"I =      \",b32.32,\" == \",i0)') ival,ival\n      oval=shifta(ival,shift)\n      write(*,'(  \"RESULT = \",b32.32,\" == \",i0)') oval,oval\n   enddo\n   ! elemental\n   write(*,*)\"characteristics of the result are the same as input\"\n   write(*,'(*(g0,1x))') &\n     & \"kind=\",kind(shifta(arr,3)), \"shape=\",shape(shifta(arr,3)), &\n     & \"size=\",size(shifta(arr,3)) !, \"rank=\",rank(shifta(arr,3))\n\nend program demo_shifta\n```\nResults:\n\n```text\n >           12\n >\n > SHIFT =  5\n > I =      11111111111111111111111111111111 == -1\n > RESULT = 11111111111111111111111111111111 == -1\n > I =      00000000000000000000000000000000 == 0\n > RESULT = 00000000000000000000000000000000 == 0\n > I =      00000000000000000000000000000000 == 0\n > RESULT = 00000000000000000000000000000000 == 0\n > I =      00000000000000000000000000000001 == 1\n > RESULT = 00000000000000000000000000000000 == 0\n > I =      01010101010101010101010101010101 == 1431655765\n > RESULT = 00000010101010101010101010101010 == 44739242\n > I =      10101010101010101010101010101010 == -1431655766\n > RESULT = 11111101010101010101010101010101 == -44739243\n > I =      00000000000000000000000000011111 == 31\n > RESULT = 00000000000000000000000000000000 == 0\n >  characteristics of the result are the same as input\n > kind= 1 shape= 2 2 size= 4\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**shiftl**(3)](#shiftl),\n[**shiftr**(3)](#shiftr),\n[**ishft**(3)](#ishft),\n[**ishftc**(3)](#ishftc)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SHIFTL": "## shiftl\n\n### **Name**\n\n**shiftl** - \\[BIT:SHIFT\\] Shift bits left\n\n### **Synopsis**\n```fortran\n    result = shiftl( i, shift )\n```\n```fortran\n     elemental integer(kind=KIND) function shiftl(i, shift)\n\n      integer(kind=KIND),intent(in) :: i\n      integer(kind=**),intent(in) :: shift\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n - **i** is an _integer_ of any kind\n - **shift** is an _integer_ of any kind\n - the result will automatically be of the same type, kind and rank as **i**.\n\n### **Description**\n\n  **shiftl** returns a value corresponding to **i** with all of the\n  bits shifted left by **shift** places.\n\n  Bits shifted out from the left end are lost, and bits shifted in from\n  the right end are set to **0**.\n\n  If the absolute value of **shift** is greater than **bit_size(i)**,\n  the value is undefined.\n\n  For example, for a 16-bit integer left-shifted five ...\n```text\n    >  |a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p| <- original 16-bit example\n    >  |f|g|h|i|j|k|l|m|n|o|p|           <- left-shifted five\n    >  |f|g|h|i|j|k|l|m|n|o|p|0|0|0|0|0| <- right-padded with zeros\n```\nNote the value of the result is the same as **ishft (i, shift)**.\n\n### **Options**\n\n- **i**\n  : The initial value to shift and fill in with zeros\n\n- **shift**\n  : how many bits to shift left.\n    It shall be nonnegative and less than or equal to **bit_size(i)**.\n\n### **Result**\n\nThe return value is of type _integer_ and of the same kind as **i**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_shiftl\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger             :: shift\ninteger(kind=int32) :: oval\ninteger(kind=int32) :: ival\ninteger(kind=int32),allocatable :: ivals(:)\ninteger             :: i\n\n  print *, ' basic usage'\n  ival=100\n  write(*,*)ival, shiftl(ival,3)\n\n ! elemental (input values may be conformant arrays)\n  print *, ' elemental'\n\n ! loop through some ivalues\n   shift=9\n   ivals=[ &\n   & int(b\"01010101010101010101010101010101\"), &\n   & int(b\"10101010101010101010101010101010\"), &\n   & int(b\"11111111111111111111111111111111\") ]\n\n   write(*,'(/,\"SHIFT =  \",i0)') shift\n   do i=1,size(ivals)\n      ! print initial value as binary and decimal\n      write(*,'(  \"I =      \",b32.32,\" == \",i0)') ivals(i),ivals(i)\n      ! print shifted value as binary and decimal\n      oval=shiftl(ivals(i),shift)\n      write(*,'(  \"RESULT = \",b32.32,\" == \",i0)') oval,oval\n   enddo\n\n  ! more about elemental\n   ELEM : block\n   integer(kind=int8)  :: arr(2,2)=reshape([2,4,8,16],[2,2])\n   write(*,*)\"characteristics of the result are the same as input\"\n   write(*,'(*(g0,1x))') &\n     & \"kind=\",kind(shiftl(arr,3)), \"shape=\",shape(shiftl(arr,3)), &\n     & \"size=\",size(shiftl(arr,3)) !, \"rank=\",rank(shiftl(arr,3))\n   endblock ELEM\n\nend program demo_shiftl\n```\nResults:\n```text\n >    basic usage\n >           100         800\n >    elemental\n >\n >  SHIFT =  9\n >  I =      01010101010101010101010101010101 == 1431655765\n >  RESULT = 10101010101010101010101000000000 == -1431655936\n >  I =      10101010101010101010101010101010 == -1431655766\n >  RESULT = 01010101010101010101010000000000 == 1431655424\n >  I =      11111111111111111111111111111111 == -1\n >  RESULT = 11111111111111111111111000000000 == -512\n >   characteristics of the result are the same as input\n >  kind= 1 shape= 2 2 size= 4\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**shifta**(3)](#shifta),\n[**shiftr**(3)](#shiftr),\n[**ishft**(3)](#ishft),\n[**ishftc**(3)](#ishftc)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SHIFTR": "## shiftr\n\n### **Name**\n\n**shiftr** - \\[BIT:SHIFT\\] Shift bits right\n\n### **Synopsis**\n```fortran\n    result = shiftr( i, shift )\n```\n```fortran\n     elemental integer(kind=KIND) function shiftr(i, shift)\n\n      integer(kind=KIND),intent(in) :: i\n      integer(kind=**),intent(in) :: shift\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n - **i** is an _integer_ of any kind\n - **shift** is an _integer_ of any kind\n - the result will automatically be of the same type, kind and rank as **i**.\n\n### **Description**\n\n  **shiftr** returns a value corresponding to **i** with all of the\n  bits shifted right by **shift** places.\n\n  If the absolute value of **shift** is greater than **bit_size(i)**,\n  the value is undefined.\n\n  Bits shifted out from the right end are lost, and bits shifted in from\n  the left end are set to 0.\n\n  For example, for a 16-bit integer right-shifted five ...\n```text\n    >  |a|b|c|d|e|f|g|h|i|j|k|l|m|n|o|p| <- original 16-bit example\n    >            |a|b|c|d|e|f|g|h|i|j|k| <- right-shifted five\n    >  |0|0|0|0|0|f|g|h|i|j|k|l|m|n|o|p| <- left-padded with zeros\n```\n  Note the value of the result is the same as **ishft (i, -shift)**.\n\n### **Options**\n\n- **i**\n  : The value to shift\n\n- **shift**\n  : How many bits to shift right.\n    It shall be nonnegative and less than or equal to **bit_size(i)**.\n\n### **Result**\n\n  The remaining bits shifted right **shift** positions.\n  Vacated positions on the left are filled with zeros.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_shiftr\nuse,intrinsic :: iso_fortran_env, only : int8, int16, int32, int64\nimplicit none\ninteger             :: shift\ninteger(kind=int32) :: oval\ninteger(kind=int32) :: ival\ninteger(kind=int32),allocatable :: ivals(:)\ninteger             :: i\n\n  print *,' basic usage'\n  ival=100\n  write(*,*)ival, shiftr(100,3)\n\n  ! elemental (input values may be conformant arrays)\n  print *,' elemental'\n   shift=9\n   ivals=[ &\n   & int(b\"01010101010101010101010101010101\"), &\n   & int(b\"10101010101010101010101010101010\"), &\n   & int(b\"11111111111111111111111111111111\") ]\n\n   write(*,'(/,\"SHIFT =  \",i0)') shift\n   do i=1,size(ivals)\n      ! print initial value as binary and decimal\n      write(*,'(  \"I =      \",b32.32,\" == \",i0)') ivals(i),ivals(i)\n      ! print shifted value as binary and decimal\n      oval=shiftr(ivals(i),shift)\n      write(*,'(  \"RESULT = \",b32.32,\" == \",i0,/)') oval,oval\n   enddo\n\n   ! more on elemental\n   ELEM : block\n   integer(kind=int8)  :: arr(2,2)=reshape([2,4,8,16],[2,2])\n   write(*,*)\"characteristics of the result are the same as input\"\n   write(*,'(*(g0,1x))') &\n     & \"kind=\",kind(shiftr(arr,3)), \"shape=\",shape(shiftr(arr,3)), &\n     & \"size=\",size(shiftr(arr,3)) !, \"rank=\",rank(shiftr(arr,3))\n   endblock ELEM\n\nend program demo_shiftr\n```\nResults:\n```text\n  >    basic usage\n  >           100          12\n  >    elemental\n  >\n  >  SHIFT =  9\n  >  I =      01010101010101010101010101010101 == 1431655765\n  >  RESULT = 00000000001010101010101010101010 == 2796202\n  >\n  >  I =      10101010101010101010101010101010 == -1431655766\n  >  RESULT = 00000000010101010101010101010101 == 5592405\n  >\n  >  I =      11111111111111111111111111111111 == -1\n  >  RESULT = 00000000011111111111111111111111 == 8388607\n  >\n  >   characteristics of the result are the same as input\n  >  kind= 1 shape= 2 2 size= 4\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**shifta**(3)](#shifta),\n[**shiftl**(3)](#shiftl),\n[**ishft**(3)](#ishft),\n[**ishftc**(3)](#ishftc)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SIGN": "## sign\n\n### **Name**\n\n**sign** - \\[NUMERIC\\] Sign copying function\n\n### **Synopsis**\n```fortran\n    result = sign(a, b)\n```\n```fortran\n     elemental type(TYPE(kind=KIND))function sign(a, b)\n\n      type(TYPE(kind=KIND)),intent(in) :: a, b\n```\n### **Characteristics**\n\n - **a** shall be of type integer or real.\n - **b** shall be of the same type as **a**.\n - the characteristics of the result are the same as **a**.\n\n### **Description**\n\n  **sign** returns a value with the magnitude of _a_ but with the\n  sign of _b_.\n\n  For processors that distinguish between positive and negative zeros\n  _sign()_ may be used to distinguish between _real_ values 0.0 and\n  -0.0. SIGN (1.0, -0.0) will return  -1.0 when a negative zero is\n  distinguishable.\n\n### **Options**\n\n  - **a**\n    : The value whose magnitude will be returned.\n\n  - **b**\n    : The value whose sign will be returned.\n\n### **Result**\n\n  a value with the magnitude of **a** with the sign of **b**. That is,\n\n  - If _b \\>= 0_ then the result is _abs(a)_\n  - else if _b < 0_ it is -_abs(a)_.\n  - if _b_ is _real_ and the processor distinguishes between _-0.0_\n    and _0.0_ then the\n    result is _-abs(a)_\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_sign\nimplicit none\n  ! basics\n   print *,  sign( -12,  1 )\n   print *,  sign( -12,  0 )\n   print *,  sign( -12, -1 )\n   print *,  sign(  12,  1 )\n   print *,  sign(  12,  0 )\n   print *,  sign(  12, -1 )\n\n   if(sign(1.0,-0.0)== -1.0)then\n      print *, 'this processor distinguishes +0 from -0'\n   else\n      print *, 'this processor does not distinguish +0 from -0'\n   endif\n\n   print *,  'elemental', sign( -12.0, [1.0, 0.0, -1.0] )\n\nend program demo_sign\n```\nResults:\n```text\n             12\n             12\n            -12\n             12\n             12\n            -12\n    this processor does not distinguish +0 from -0\n    elemental   12.00000       12.00000      -12.00000\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See also**\n\n[**abs**(3)](#abs)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SIN": "## sin\n\n### **Name**\n\n**sin** - \\[MATHEMATICS:TRIGONOMETRIC\\] Sine function\n\n### **Synopsis**\n```fortran\n    result = sin(x)\n```\n```fortran\n     elemental TYPE(kind=KIND) function sin(x)\n\n      TYPE(kind=KIND) :: x\n```\n### **Characteristics**\n\n  - **x** may be any _real_ or _complex_ type\n  - **KIND** may be any kind supported by the associated type of **x**.\n  - The returned value will be of the same type and kind as the argument\n    **x**.\n\n### **Description**\n\n  **sin** computes the sine of an angle given the size of the angle\n  in radians.\n\n  The sine of an angle in a right-angled triangle is the ratio of the\n  length of the side opposite the given angle divided by the length of\n  the hypotenuse.\n\n### **Options**\n\n- **x**\n  : The angle in radians to compute the sine of.\n\n### **Result**\n\n  The return value contains the processor-dependent approximation of\n  the sine of **x**\n\n  If X is of type _real_, it is regarded as a value in radians.\n\n  If X is of type _complex_, its real part is regarded as a value\n  in radians.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram sample_sin\nimplicit none\nreal :: x = 0.0\n   x = sin(x)\n   write(*,*)'X=',x\nend program sample_sin\n```\nResults:\n```text\n >  X=  0.0000000E+00\n```\n### Extended Example\n\n#### Haversine Formula\n\n  From the article on \"Haversine formula\" in Wikipedia:\n```text\n   The haversine formula is an equation important in navigation,\n   giving great-circle distances between two points on a sphere from\n   their longitudes and latitudes.\n```\n  So to show the great-circle distance between the Nashville International\n  Airport (BNA) in TN, USA, and the Los Angeles International Airport\n  (LAX) in CA, USA you would start with their latitude and longitude,\n  commonly given as\n```text\n  BNA: N 36 degrees 7.2',   W 86 degrees 40.2'\n  LAX: N 33 degrees 56.4',  W 118 degrees 24.0'\n```\n  which converted to floating-point values in degrees is:\n\n     - BNA\n       latitude=36.12, longitude=-86.67\n\n     - LAX\n       latitude=33.94, longitude=-118.40\n\n  And then use the haversine formula to roughly calculate the distance\n  along the surface of the Earth between the locations:\n\nSample program:\n```fortran\nprogram demo_sin\nimplicit none\nreal :: d\n    d = haversine(36.12,-86.67, 33.94,-118.40) ! BNA to LAX\n    print '(A,F9.4,A)', 'distance: ',d,' km'\ncontains\nfunction haversine(latA,lonA,latB,lonB) result (dist)\n!\n! calculate great circle distance in kilometers\n! given latitude and longitude in degrees\n!\nreal,intent(in) :: latA,lonA,latB,lonB\nreal :: a,c,dist,delta_lat,delta_lon,lat1,lat2\nreal,parameter :: radius = 6371 ! mean earth radius in kilometers,\n! recommended by the International Union of Geodesy and Geophysics\n\n! generate constant pi/180\nreal, parameter :: deg_to_rad = atan(1.0)/45.0\n   delta_lat = deg_to_rad*(latB-latA)\n   delta_lon = deg_to_rad*(lonB-lonA)\n   lat1 = deg_to_rad*(latA)\n   lat2 = deg_to_rad*(latB)\n   a = (sin(delta_lat/2))**2 + &\n          & cos(lat1)*cos(lat2)*(sin(delta_lon/2))**2\n   c = 2*asin(sqrt(a))\n   dist = radius*c\nend function haversine\nend program demo_sin\n```\nResults:\n```text\n > distance: 2886.4446 km\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See Also**\n\n[**asin**(3)](#asin),\n[**cos**(3)](#cos),\n[**tan**(3)](#tan),\n[**acosh**(3)](#acosh),\n[**acos**(3)](#acos),\n[**asinh**(3)](#asinh),\n[**atan2**(3)](#atan2),\n[**atanh**(3)](#atanh),\n[**acosh**(3)](#acosh),\n[**asinh**(3)](#asinh),\n[**atanh**(3)](#atanh)\n\n### **Resources**\n\n- [Wikipedia:sine and cosine](https://en.wikipedia.org/wiki/Sine_and_cosine)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SINH": "## sinh\n\n### **Name**\n\n**sinh** - \\[MATHEMATICS:TRIGONOMETRIC\\] Hyperbolic sine function\n\n### **Synopsis**\n```fortran\n    result = sinh(x)\n```\n```fortran\n     elemental TYPE(kind=KIND) function sinh(x)\n\n      TYPE(kind=KIND) :: x\n```\n### **Characteristics**\n\n - **TYPE** may be _real_ or _complex_\n - **KIND** may be any kind supported by the associated type.\n - The returned value will be of the same type and kind as the argument.\n\n### **Description**\n\n  **sinh** computes the hyperbolic sine of **x**.\n\n  The hyperbolic sine of x is defined mathematically as:\n```fortran\n     sinh(x) = (exp(x) - exp(-x)) / 2.0\n```\n\n### **Options**\n\n- **x**\n  : The value to calculate the hyperbolic sine of\n\n### **Result**\n\n  The result has a value equal to a processor-dependent approximation\n  to sinh(X). If X is of type complex its imaginary part is regarded\n  as a value in radians.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_sinh\nuse, intrinsic :: iso_fortran_env, only : &\n& real_kinds, real32, real64, real128\nimplicit none\nreal(kind=real64) :: x = - 1.0_real64\nreal(kind=real64) :: nan, inf\ncharacter(len=20) :: line\n\n  ! basics\n   print *, sinh(x)\n   print *, (exp(x)-exp(-x))/2.0\n\n  ! sinh(3) is elemental and can handle an array\n   print *, sinh([x,2.0*x,x/3.0])\n\n   ! a NaN input returns NaN\n   line='NAN'\n   read(line,*) nan\n   print *, sinh(nan)\n\n   ! a Inf input returns Inf\n   line='Infinity'\n   read(line,*) inf\n   print *, sinh(inf)\n\n   ! an overflow returns Inf\n   x=huge(0.0d0)\n   print *, sinh(x)\n\nend program demo_sinh\n```\nResults:\n```text\n  -1.1752011936438014\n  -1.1752011936438014\n  -1.1752011936438014       -3.6268604078470190      -0.33954055725615012\n                       NaN\n                  Infinity\n                  Infinity\n```\n### **Standard**\n\nFortran 95 , for a complex argument Fortran 2008\n\n### **See Also**\n\n[**asinh**(3)](#asinh)\n\n### **Resources**\n\n- [Wikipedia:hyperbolic functions](https://en.wikipedia.org/wiki/Hyperbolic_functions)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SIZE": "## size\n\n### **Name**\n\n**size** - \\[ARRAY:INQUIRY\\] Determine the size of an array or extent of one dimension\n\n### **Synopsis**\n```fortran\n    result = size(array [,dim] [,kind])\n```\n```fortran\n     integer(kind=KIND) function size(array,dim,kind)\n\n      type(TYPE(kind=KIND)),intent(in) :: array(..)\n      integer(kind=**),intent(in),optional :: dim\n      integer(kind=**),intent(in),optional :: KIND\n```\n### **Characteristics**\n\n- **array** is an assumed-rank array or array of any type and associated\n  kind.\n\n  If **array** is a pointer it must be associated and allocatable arrays\n  must be allocated.\n- **dim** is an integer scalar\n- **kind** is a scalar integer constant expression.\n- the result is an integer scalar of kind **KIND**. If **KIND** is absent\n  a _integer_ of default kind is returned.\n- a kind designated as ** may be any supported kind for the type\n\n\n### **Description**\n\n  **size(3)** returns the total number of elements in an array, or\n  if **dim** is specified returns the number of elements along that\n  dimension.\n\n  **size** determines the extent of **array** along a specified\n  dimension **dim**, or the total number of elements in **array** if\n  **dim** is absent.\n\n### **Options**\n\n- **array**\n  : the array to measure the number of elements of.\n  If **array* is an assumed-size array, **dim** shall be present with a value less\n  than the rank of **array**.\n\n- **dim**\n  : a value shall be\n  in the range from 1 to n, where n equals the rank of **array**.\n\n  If not present the total number of elements of the entire array\n  are returned.\n\n- **kind**\n  : An _integer_ initialization expression indicating the kind\n  parameter of the result.\n\n  If absent the kind type parameter of the returned value is that of\n  default integer type.\n\n  The **kind** must allow for the magnitude returned by **size** or\n  results are undefined.\n\n  If **kind** is absent, the return value is of default _integer_ kind.\n\n### **Result**\n\n  If **dim** is not present **array** is assumed-rank, the result has a\n  value equal to **PRODUCT(SHAPE(ARRAY,KIND))**. Otherwise, the result\n  has a value equal to the total number of elements of **array**.\n\n  If **dim** is present the number of elements along that dimension\n  are returned, except that if ARRAY is assumed-rank and associated\n  with an assumed-size array and DIM is present with a value equal to\n  the rank of **array**, the value is -1.\n\n  NOTE1\n\n  If **array** is assumed-rank and has rank zero, **dim** cannot be\n  present since it cannot satisfy the requirement\n\n   1 <= DIM <= 0.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_size\nimplicit none\ninteger :: arr(0:2,-5:5)\n   write(*,*)'SIZE of simple two-dimensional array'\n   write(*,*)'SIZE(arr)       :total count of elements:',size(arr)\n   write(*,*)'SIZE(arr,DIM=1) :number of rows         :',size(arr,dim=1)\n   write(*,*)'SIZE(arr,DIM=2) :number of columns      :',size(arr,dim=2)\n\n   ! pass the same array to a procedure that passes the value two\n   ! different ways\n   call interfaced(arr,arr)\ncontains\n\nsubroutine interfaced(arr1,arr2)\n! notice the difference in the array specification\n! for arr1 and arr2.\ninteger,intent(in) :: arr1(:,:)\ninteger,intent(in) :: arr2(2,*)\n   !\n   write(*,*)'interfaced assumed-shape array'\n   write(*,*)'SIZE(arr1)        :',size(arr1)\n   write(*,*)'SIZE(arr1,DIM=1)  :',size(arr1,dim=1)\n   write(*,*)'SIZE(arr1,DIM=2)  :',size(arr1,dim=2)\n\n!  write(*,*)'SIZE(arr2)        :',size(arr2)\n   write(*,*)'SIZE(arr2,DIM=1)  :',size(arr2,dim=1)\n!\n! CANNOT DETERMINE SIZE OF ASSUMED SIZE ARRAY LAST DIMENSION\n!  write(*,*)'SIZE(arr2,DIM=2)  :',size(arr2,dim=2)\n\nend subroutine interfaced\n\nend program demo_size\n```\nResults:\n```text\n    SIZE of simple two-dimensional array\n    SIZE(arr)       :total count of elements:          33\n    SIZE(arr,DIM=1) :number of rows         :           3\n    SIZE(arr,DIM=2) :number of columns      :          11\n    interfaced assumed-shape array\n    SIZE(arr1)        :          33\n    SIZE(arr1,DIM=1)  :           3\n    SIZE(arr1,DIM=2)  :          11\n    SIZE(arr2,DIM=1)  :           2\n```\n### **Standard**\n\nFortran 95 , with **kind** argument - Fortran 2003\n\n### **See Also**\n\n#### Array inquiry:\n\n- [**size**](#size) -  Determine the size of an array\n- [**rank**(3)](#rank) -  Rank of a data object\n- [**shape**(3)](#shape) -  Determine the shape of an array\n- [**ubound**(3)](#ubound) -  Upper dimension bounds of an array\n- [**lbound**(3)](#lbound) -  Lower dimension bounds of an array\n\n#### State Inquiry:\n\n- [**allocated**(3)](#allocated) -  Status of an allocatable entity\n- [**is_contiguous**(3)](#is_contiguous) -  Test if object is contiguous\n\n#### Kind Inquiry:\n\n- [**kind**(3)](#kind) - Kind of an entity\n\n#### Bit Inquiry:\n\n- [**storage_size**(3)](#storage_size) - Storage size in bits\n- [**bit_size**(3)](#bit_size) -  Bit size inquiry function\n- [**btest**(3)](#btest) - Tests a bit of an _integer_ value.\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SPACING": "## spacing\n\n### **Name**\n\n**spacing** - \\[MODEL_COMPONENTS\\] Smallest distance between two numbers of a given type\n\n### **Synopsis**\n```fortran\n    result = spacing(x)\n```\n```fortran\n     elemental real(kind=KIND) function spacing(x)\n\n      real(kind=KIND), intent(in) :: x\n```\n### **Characteristics**\n\n  - **x** is type real of any valid kind\n  - The result is of the same type as the input argument **x**.\n\n### **Description**\n\n  **spacing** determines the distance between the argument **x**\n  and the nearest adjacent number of the same type.\n\n### **Options**\n\n- **x**\n  : Shall be of type _real_.\n\n### **Result**\n\n   If **x** does not have the value zero and is not an IEEE infinity or NaN, the result has the value\n   nearest to **x** for values of the same type and kind assuming the value is representable.\n\n   Otherwise, the value is the same as **tiny(x)**.\n     + zero produces **tiny(x)**\n     + IEEE Infinity produces an IEEE Nan\n     + if an IEEE NaN, that NaN is returned\n\n   If there are two extended model values equally near to **x**, the\n   value of greater absolute value is taken.\n<!--\n       b**(e-p), where b, e, and p are as defined in 16.4\n-->\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_spacing\nimplicit none\ninteger, parameter :: sgl = selected_real_kind(p=6, r=37)\ninteger, parameter :: dbl = selected_real_kind(p=13, r=200)\n\n   write(*,*) spacing(1.0_sgl)\n   write(*,*) nearest(1.0_sgl,+1.0),nearest(1.0_sgl,+1.0)-1.0\n\n   write(*,*) spacing(1.0_dbl)\nend program demo_spacing\n```\nResults:\n\nTypical values ...\n\n```text\n     1.1920929E-07\n      1.000000      1.1920929E-07\n     0.9999999     -5.9604645E-08\n     2.220446049250313E-016\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**exponent**(3)](#exponent),\n[**fraction**(3)](#fraction),\n[**huge**(3)](#huge),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**nearest**(3)](#nearest),\n[**precision**(3)](#precision),\n[**radix**(3)](#radix),\n[**range**(3)](#range),\n[**rrspacing**(3)](#rrspacing),\n[**scale**(3)](#scale),\n[**set_exponent**(3)](#set_exponent),\n[**tiny**(3)](#tiny)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SPREAD": "## spread\n\n### **Name**\n\n**spread** - \\[ARRAY:CONSTRUCTION\\] Add a dimension and replicate data\n\n### **Synopsis**\n```fortran\n    result = spread(source, dim, ncopies)\n```\n```fortran\n     TYPE(kind=KIND) function spread(source, dim, ncopies)\n\n      TYPE(kind=KIND)             :: source(..)\n      integer(kind=**),intent(in) :: dim\n      integer(kind=**),intent(in) :: ncopies\n```\n### **Characteristics**\n\n- **source** is a scalar or array of any type and a rank less than fifteen.\n- **dim** is an _integer_ scalar\n- **ncopies** is an integer scalar\n\n### **Description**\n\n**spread** replicates a **source** array along a specified dimension\n**dim**. The copy is repeated **ncopies** times.\n\nSo to add additional rows to a matrix **dim=1** would be used, but to\nadd additional rows **dim=2** would be used, for example.\n\nIf **source** is scalar, the size of the resulting vector is **ncopies**\nand each element of the result has a value equal to **source**.\n\n### **Options**\n\n- **source**\n  : the input data to duplicate\n\n- **dim**\n  : The additional dimension value in the range from\n  **1** to **n+1**, where **n** equals the rank of **source**.\n\n- **ncopies**\n  : the number of copies of the original data to generate\n\n### **Result**\n\nThe result is an array of the same type as **source** and has rank **n+1**\nwhere **n** equals the rank of **source**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_spread\nimplicit none\n\ninteger a1(4,3), a2(3,4), v(4), s\n\n   write(*,'(a)' ) &\n   'TEST SPREAD(3)                                      ', &\n   '  SPREAD(3) is a FORTRAN90 function which replicates', &\n   '  an array by adding a dimension.                   ', &\n   ' '\n\n   s = 99\n   call printi('suppose we have a scalar S',s)\n\n   write(*,*) 'to add a new dimension (1) of extent 4 call'\n   call printi('spread( s, dim=1, ncopies=4 )',spread ( s, 1, 4 ))\n\n   v = [ 1, 2, 3, 4 ]\n   call printi(' first we will set V to',v)\n\n   write(*,'(a)')' and then do \"spread ( v, dim=2, ncopies=3 )\"'\n   a1 = spread ( v, dim=2, ncopies=3 )\n   call printi('uses v as a column and makes 3 columns',a1)\n\n   a2 = spread ( v, 1, 3 )\n   call printi(' spread(v,1,3) uses v as a row and makes 3 rows',a2)\n\ncontains\n! CONVENIENCE ROUTINE; NOT DIRECTLY CONNECTED TO SPREAD(3)\nsubroutine printi(title,a)\nuse, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT,&\n & stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT\nimplicit none\n\n!@(#) print small 2d integer scalar, vector, matrix in row-column format\n\ncharacter(len=*),parameter   :: all='(\" \",*(g0,1x))'\ncharacter(len=*),intent(in)  :: title\ncharacter(len=20)            :: row\ninteger,intent(in)           :: a(..)\ninteger                      :: i\n\n   write(*,all,advance='no')trim(title)\n   ! select rank of input\n   select rank(a)\n   rank (0); write(*,'(a)')' (a scalar)'\n      write(*,'(\" > [ \",i0,\" ]\")')a\n   rank (1); write(*,'(a)')' (a vector)'\n      ! find how many characters to use for integers\n      write(row,'(i0)')ceiling(log10(max(1.0,real(maxval(abs(a))))))+2\n      ! use this format to write a row\n      row='(\" > [\",*(i'//trim(row)//':,\",\"))'\n      do i=1,size(a)\n         write(*,fmt=row,advance='no')a(i)\n         write(*,'(\" ]\")')\n      enddo\n   rank (2); write(*,'(a)')' (a matrix) '\n      ! find how many characters to use for integers\n      write(row,'(i0)')ceiling(log10(max(1.0,real(maxval(abs(a))))))+2\n      ! use this format to write a row\n      row='(\" > [\",*(i'//trim(row)//':,\",\"))'\n      do i=1,size(a,dim=1)\n         write(*,fmt=row,advance='no')a(i,:)\n         write(*,'(\" ]\")')\n      enddo\n   rank default\n      write(stderr,*)'*printi* did not expect rank=', rank(a), &\n       & 'shape=', shape(a),'size=',size(a)\n      stop '*printi* unexpected rank'\n   end select\n   write(*,all) '>shape=',shape(a),',rank=',rank(a),',size=',size(a)\n   write(*,*)\n\nend subroutine printi\n\nend program demo_spread\n```\nResults:\n```text\n > TEST SPREAD(3)\n >   SPREAD(3) is a FORTRAN90 function which replicates\n >   an array by adding a dimension.\n >\n >  suppose we have a scalar S  (a scalar)\n >  > [ 99 ]\n >  >shape= ,rank= 0 ,size= 1\n >\n >  to add a new dimension (1) of extent 4 call\n >  spread( s, dim=1, ncopies=4 )  (a vector)\n >  > [  99 ]\n >  > [  99 ]\n >  > [  99 ]\n >  > [   0 ]\n >  >shape= 4 ,rank= 1 ,size= 4\n >\n >   first we will set V to  (a vector)\n >  > [  1 ]\n >  > [  2 ]\n >  > [  3 ]\n >  > [  4 ]\n >  >shape= 4 ,rank= 1 ,size= 4\n >\n >  and then do \"spread ( v, dim=2, ncopies=3 )\"\n >  uses v as a column and makes 3 columns  (a matrix)\n >  > [  1,  1,  1 ]\n >  > [  2,  2,  2 ]\n >  > [  3,  3,  3 ]\n >  > [  4,  4,  4 ]\n >  >shape= 4 3 ,rank= 2 ,size= 12\n >\n >   spread(v,1,3) uses v as a row and makes 3 rows  (a matrix)\n >  > [  1,  2,  3,  4 ]\n >  > [  1,  2,  3,  4 ]\n >  > [  1,  2,  3,  4 ]\n >  >shape= 3 4 ,rank= 2 ,size= 12\n >\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**merge**(3)](#merge),\n[**pack**(3)](#pack),\n[**unpack**(3)](#unpack)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n<!--\nwhen adding dimension 3,4,5, ... why is 15 not allowed if 16 is allowed?\n\nneed an illustration of what happens with higher dimension array\n-->\n",
  "SQRT": "## sqrt\n\n### **Name**\n\n**sqrt** - \\[MATHEMATICS\\] Square-root function\n\n### **Synopsis**\n```fortran\n    result = sqrt(x)\n```\n```fortran\n     elemental TYPE(kind=KIND) function sqrt(x)\n\n      TYPE(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **TYPE** may be _real_ or _complex_.\n - **KIND** may be any kind valid for the declared type.\n - the result has the same characteristics as **x**.\n\n### **Description**\n\n  **sqrt** computes the principal square root of **x**.\n\n  The number whose square root is being considered is known as the\n  _radicand_.\n\n  In mathematics, a square root of a radicand **x** is a number **y**\n  such that **y\\*y = x**.\n\n  Every nonnegative radicand  **x** has two square roots of the same unique\n  magnitude, one positive and one negative. The nonnegative square root\n  is called the principal square root.\n\n  The principal square root of 9 is 3, for example, even though (-3)\\*(-3)\n  is also 9.\n\n  Square roots of negative numbers are a special case of complex numbers,\n  where with **complex** input the components of the _radicand_ need\n  not be positive in order to have a valid square root.\n\n### **Options**\n\n- **x**\n  : The radicand to find the principal square root of.\n  If **x** is _real_ its value must be greater than or equal to zero.\n\n### **Result**\n\n  The principal square root of **x** is returned.\n\n  For a _complex_ result the real part is greater than or equal to zero.\n\n  When the real part of the result is zero, the imaginary part has the\n  same sign as the imaginary part of **x**.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_sqrt\nuse, intrinsic :: iso_fortran_env, only : real_kinds, &\n & real32, real64, real128\nimplicit none\nreal(kind=real64) :: x, x2\ncomplex :: z, z2\n\n  ! basics\n   x = 2.0_real64\n   ! complex\n   z = (1.0, 2.0)\n   write(*,*)'input values ',x,z\n\n   x2 = sqrt(x)\n   z2 = sqrt(z)\n   write(*,*)'output values ',x2,z2\n\n  ! elemental\n  write(*,*)'elemental',sqrt([64.0,121.0,30.0])\n\n  ! alternatives\n   x2 = x**0.5\n   z2 = z**0.5\n   write(*,*)'alternatively',x2,z2\n\nend program demo_sqrt\n```\nResults:\n```text\n    input values    2.00000000000000      (1.000000,2.000000)\n    output values    1.41421356237310      (1.272020,0.7861513)\n    elemental   8.000000       11.00000       5.477226\n    alternatively   1.41421356237310      (1.272020,0.7861513)\n```\n### **Standard**\n\nFORTRAN 77\n\n### **See also**\n\n[**exp**(3)](#exp),\n[**log**(3)](#log),\n[**log10**(3)](#log10)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "STORAGE_SIZE": "\n## storage_size\n\n### **Name**\n\n**storage_size** - \\[BIT:INQUIRY\\] Storage size in bits\n\n### **Synopsis**\n```fortran\n    result = storage_size(a [,KIND] )\n```\n```fortran\n     integer(kind=KIND) storage_size(a,KIND)\n\n      type(TYPE(kind=**)) :: a\n      integer,intent(in),optional :: KIND\n```\n### **Characteristics**\n  - a kind designated as ** may be any supported kind for the type\n\n  - **a** may be of any type and kind. If it is polymorphic it shall not\n    be an undefined pointer. If it is unlimited polymorphic or has any\n    deferred type parameters, it shall not be an unallocated allocatable\n    variable or a disassociated or undefined pointer.\n\n  - The kind type parameter of the returned value is that specified by\n    the value of **kind**; otherwise, the kind type parameter is that of\n    default integer type.\n\n  - The result is an _integer_ scalar of default kind unless **kind** is\n    specified, in which case it has the kind specified by **kind**.\n\n### **Description**\n\n**storage_size** returns the storage size of argument **a** in bits.\n\n### **Options**\n\n- **a**\n  : The entity to determine the storage size of\n\n- **kind**\n  : a scalar integer constant expression that defines the kind of the\n  output value.\n\n### **Result**\n\n  The result value is the size expressed in bits for an element of an\n  array that has the dynamic type and type parameters of **a**.\n\n  If the type and type parameters are such that storage association\n  applies, the result is consistent with the named constants\n  defined in the intrinsic module ISO_FORTRAN_ENV.\n\n  NOTE1\n\n   An array element might take \"type\" more bits to store than an isolated\n   scalar, since any hardware-imposed alignment requirements for array\n   elements might not apply to a simple scalar variable.\n\n  NOTE2\n\n   This is intended to be the size in memory that an object takes when it\n   is stored; this might differ from the size it takes during expression\n   handling (which might be the native register size) or when stored in a\n   file. If an object is never stored in memory but only in a register,\n   this function nonetheless returns the size it would take if it were\n   stored in memory.\n\n### **Examples**\n\nSample program\n```fortran\nprogram demo_storage_size\nimplicit none\n\n   ! a default real, integer, and logical are the same storage size\n   write(*,*)'size of integer       ',storage_size(0)\n   write(*,*)'size of real          ',storage_size(0.0)\n   write(*,*)'size of logical       ',storage_size(.true.)\n   write(*,*)'size of complex       ',storage_size((0.0,0.0))\n\n   ! note the size of an element of the array, not the storage size of\n   ! the entire array is returned for array arguments\n   write(*,*)'size of integer array ',storage_size([0,1,2,3,4,5,6,7,8,9])\n\nend program demo_storage_size\n```\nResults:\n```text\n    size of integer                 32\n    size of real                    32\n    size of logical                 32\n    size of complex                 64\n    size of integer array           32\n```\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**c_sizeof**(3)](#c_sizeof)\n\n _fortran-lang intrinsic descriptions_\n",
  "SUM": "## sum\n\n### **Name**\n\n**sum** - \\[ARRAY:REDUCTION\\] Sum the elements of an array\n\n### **Synopsis**\n```fortran\n   result = sum(array [,dim[,mask]] | [mask] )\n```\n```fortran\n     TYPE(kind=KIND) function sum(array, dim, mask)\n\n      TYPE(kind=KIND),intent(in) :: array(..)\n      integer(kind=**),intent(in),optional :: dim\n      logical(kind=**),intent(in),optional :: mask(..)\n```\n### **Characteristics**\n\n  - a kind designated as ** may be any supported kind for the type\n  - **array** may be of any numeric type - _integer_, _real_ or _complex_.\n  - **dim** is an _integer_\n  - **mask** is _logical_ and conformable with **array**.\n  - The result is of the same type and kind as **array**. It is scalar\n    if **dim** is not present or **array** is a vector, else it is an array.\n\n### **Description**\n\n  **sum** adds the elements of **array**.\n\n  When only **array** is specified all elements are summed, but groups\n  of sums may be returned along the dimension specified by **dim**\n  and/or elements to add may be selected by a logical mask.\n\n  No method is designated for how the sum is conducted, so whether or not\n  accumulated error is compensated for is processor-dependent.\n\n### **Options**\n\n- **array**\n  : an array containing the elements to add\n\n- **dim**\n  : a value in the range from 1 to n, where n equals the rank (the number\n  of dimensions) of **array**. **dim** designates the dimension\n  along which to create sums. When absent a scalar sum of the elements\n  optionally selected by **mask** is returned.\n\n- **mask**\n  : an array of the same shape as **array** that designates\n  which elements to add. If absent all elements are used in the sum(s).\n\n### **Result**\n\n  If **dim** is absent, a scalar with the sum of all selected elements\n  in **array** is returned. Otherwise, an array of rank n-1, where n\n  equals the rank of **array**, and a shape similar to that of **array**\n  with dimension **dim** dropped is returned. Since a vector has a rank\n  of one, the result is a scalar (if n==1, n-1 is zero; and a rank of\n  zero means a scalar).\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_sum\nimplicit none\ninteger :: vector(5) , matrix(3,4), box(5,6,7)\n\n   vector = [ 1, 2, -3, 4, 5 ]\n\n   matrix(1,:)=[  -1,   2,    -3,   4    ]\n   matrix(2,:)=[  10,   -20,  30,   -40  ]\n   matrix(3,:)=[  100,  200, -300,  400  ]\n\n   box=11\n\n  ! basics\n   print *, 'sum all elements:',sum(vector)\n   print *, 'real :',sum([11.0,-5.0,20.0])\n   print *, 'complex :',sum([(1.1,-3.3),(4.0,5.0),(8.0,-6.0)])\n  ! with MASK option\n   print *, 'sum odd elements:',sum(vector, mask=mod(vector, 2)==1)\n   print *, 'sum positive values:', sum(vector, mask=vector>0)\n\n   call printi('the input array', matrix )\n   call printi('sum of all elements in matrix', sum(matrix) )\n   call printi('sum of positive elements', sum(matrix,matrix>=0) )\n  ! along dimensions\n   call printi('sum along rows', sum(matrix,dim=1) )\n   call printi('sum along columns', sum(matrix,dim=2) )\n   call printi('sum of a vector is always a scalar', sum(vector,dim=1) )\n   call printi('sum of a volume by row', sum(box,dim=1) )\n   call printi('sum of a volume by column', sum(box,dim=2) )\n   call printi('sum of a volume by depth', sum(box,dim=3) )\n\ncontains\n! CONVENIENCE ROUTINE; NOT DIRECTLY CONNECTED TO SPREAD(3)\nsubroutine printi(title,a)\nuse, intrinsic :: iso_fortran_env, only : stderr=>ERROR_UNIT,&\n & stdin=>INPUT_UNIT, stdout=>OUTPUT_UNIT\nimplicit none\n\n!@(#) print small 2d integer scalar, vector, matrix in row-column format\n\ncharacter(len=*),intent(in)  :: title\ninteger,intent(in)           :: a(..)\n\ncharacter(len=*),parameter   :: all='(\" \",*(g0,1x))'\ncharacter(len=20)            :: row\ninteger,allocatable          :: b(:,:)\ninteger                      :: i\n   write(*,all,advance='no')trim(title)\n   ! copy everything to a matrix to keep code simple\n   select rank(a)\n   rank (0); write(*,'(a)')' (a scalar)'; b=reshape([a],[1,1])\n   rank (1); write(*,'(a)')' (a vector)'; b=reshape(a,[size(a),1])\n   rank (2); write(*,'(a)')' (a matrix)'; b=a\n   rank default; stop '*printi* unexpected rank'\n   end select\n   ! find how many characters to use for integers\n   write(row,'(i0)')ceiling(log10(max(1.0,real(maxval(abs(b))))))+2\n   ! use this format to write a row\n   row='(\" > [\",*(i'//trim(row)//':,\",\"))'\n   do i=1,size(b,dim=1)\n      write(*,fmt=row,advance='no')b(i,:)\n      write(*,'(\" ]\")')\n   enddo\n   write(*,all) '>shape=',shape(a),',rank=',rank(a),',size=',size(a)\n   write(*,*)\nend subroutine printi\nend program demo_sum\n```\nResults:\n```text\n    sum all elements:           9\n    real :   26.00000\n    complex : (13.10000,-4.300000)\n    sum odd elements:           6\n    sum positive values:          12\n    the input array  (a matrix)\n    > [   -1,    2,   -3,    4 ]\n    > [   10,  -20,   30,  -40 ]\n    > [  100,  200, -300,  400 ]\n    >shape= 3 4 ,rank= 2 ,size= 12\n\n    sum of all elements in matrix  (a scalar)\n    > [  382 ]\n    >shape= ,rank= 0 ,size= 1\n\n    sum of positive elements  (a scalar)\n    > [  746 ]\n    >shape= ,rank= 0 ,size= 1\n\n    sum along rows  (a vector)\n    > [  109 ]\n    > [  182 ]\n    > [ -273 ]\n    > [  364 ]\n    >shape= 4 ,rank= 1 ,size= 4\n\n    sum along columns  (a vector)\n    > [    2 ]\n    > [  -20 ]\n    > [  400 ]\n    >shape= 3 ,rank= 1 ,size= 3\n\n    sum of a vector is always a scalar  (a scalar)\n    > [  9 ]\n    >shape= ,rank= 0 ,size= 1\n\n    sum of a volume by row  (a matrix)\n    > [  55,  55,  55,  55,  55,  55,  55 ]\n    > [  55,  55,  55,  55,  55,  55,  55 ]\n    > [  55,  55,  55,  55,  55,  55,  55 ]\n    > [  55,  55,  55,  55,  55,  55,  55 ]\n    > [  55,  55,  55,  55,  55,  55,  55 ]\n    > [  55,  55,  55,  55,  55,  55,  55 ]\n    >shape= 6 7 ,rank= 2 ,size= 42\n\n    sum of a volume by column  (a matrix)\n    > [  66,  66,  66,  66,  66,  66,  66 ]\n    > [  66,  66,  66,  66,  66,  66,  66 ]\n    > [  66,  66,  66,  66,  66,  66,  66 ]\n    > [  66,  66,  66,  66,  66,  66,  66 ]\n    > [  66,  66,  66,  66,  66,  66,  66 ]\n    >shape= 5 7 ,rank= 2 ,size= 35\n\n    sum of a volume by depth  (a matrix)\n    > [  77,  77,  77,  77,  77,  77 ]\n    > [  77,  77,  77,  77,  77,  77 ]\n    > [  77,  77,  77,  77,  77,  77 ]\n    > [  77,  77,  77,  77,  77,  77 ]\n    > [  77,  77,  77,  77,  77,  77 ]\n    >shape= 5 6 ,rank= 2 ,size= 30\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n - [**all**(3)](#all) - Determines if all the values are true\n - [**any**(3)](#any) - Determines if any of the values in the logical array are true.\n - [**count**(3)](#count) - Count true values in an array\n - [**maxval**(3)](#maxval) - Determines the maximum value in an array\n - [**minval**(3)](#minval) - Minimum value of an array\n - [**product**(3)](#product) - Product of array elements\n - [**merge**(3)](#merge) - Merge variables\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "SYSTEM_CLOCK": "## system_clock\n\n### **Name**\n\n**system_clock** - \\[SYSTEM:TIME\\] Query system clock\n\n### **Synopsis**\n```fortran\n    call system_clock([count] [,count_rate] [,count_max] )\n```\n```fortran\n     subroutine system_clock(count, count_rate, count_max)\n\n      integer(kind=**),intent(out),optional    :: count\n      type(TYPE(kind=**)),intent(out),optional :: count_rate\n      integer(kind=**),intent(out),optional    :: count_max\n```\n### **Characteristics**\n\n - **count** is an _integer_ scalar\n - **count_rate** is an _integer_ or _real_ scalar\n - **count_max** is an _integer_ scalar\n\n### **Description**\n\n  **system_clock** lets you measure durations of time with the\n  precision of the smallest time increment generally available on a\n  system by returning processor-dependent values based on the current\n  value of the processor clock.\n\n  **system_clock** is typically used to measure short time intervals\n  (system clocks may be 24-hour clocks or measure processor clock ticks\n  since boot, for example). It is most often used for measuring or\n  tracking the time spent in code blocks in lieu of using profiling tools.\n\n  **count_rate** and **count_max** are assumed constant (even though\n  CPU rates can vary on a single platform).\n\n  Whether an image has no clock, has a single clock of its own, or shares\n  a clock with another image, is processor dependent.\n\n  If there is no clock, or querying the clock fails, **count** is set to\n  **-huge(count)**, and **count_rate** and **count_max** are set to zero.\n\n  The accuracy of the measurements may depend on the kind of the\n  arguments!\n\n  Timing-related procedures are obviously processor and system-dependent.\n  More specific information may generally be found in compiler-specific\n  documentation.\n\n### **Options**\n\n- **count**\n  If there is no clock, the returned value for **count** is the negative\n  value **-huge(count)**.\n\n  Otherwise, the **clock** value is incremented by one for each clock\n  count until the value **count_max** is reached and is then reset to\n  zero at the next count. **clock** therefore is a modulo value that\n  lies in the range **0 to count_max**.\n\n- **count_rate**\n  : is assigned a processor-dependent approximation to the number of\n  processor clock counts per second, or zero if there is no clock.\n  **count_rate** is system dependent and can vary depending on the kind\n  of the arguments. Generally, a large _real_ may generate a more precise\n  interval.\n\n- **count_max**\n  : is assigned the maximum value that **COUNT** can have, or zero if\n  there is no clock.\n\n### **Examples**\n\n  If the processor clock is a 24-hour clock that registers time at\n  approximately 18.20648193 ticks per second, at 11:30 A.M. the reference\n\n```fortran\n      call system_clock (count = c, count_rate = r, count_max = m)\n```\n  defines\n```text\n      C = (11*3600+30*60)*18.20648193 = 753748,\n      R = 18.20648193, and\n      M = 24*3600*18.20648193-1 = 1573039.\n```\n\nSample program:\n```fortran\nprogram demo_system_clock\nuse, intrinsic :: iso_fortran_env, only: wp => real64, int32, int64\nimplicit none\ncharacter(len=*), parameter :: g = '(1x,*(g0,1x))'\n\ninteger(kind=int64) :: count64, count_rate64, count_max64\ninteger(kind=int64) :: start64, finish64\n\ninteger(kind=int32) :: count32, count_rate32, count_max32\ninteger(kind=int32) :: start32, finish32\n\nreal(kind=wp)       :: time_read\nreal(kind=wp)       :: sum\ninteger             :: i\n\n   print g, 'accuracy may vary with argument type!'\n\n   print g, 'query all arguments'\n\n   call system_clock(count64, count_rate64, count_max64)\n   print g, 'COUNT_MAX(64bit)=', count_max64\n   print g, 'COUNT_RATE(64bit)=', count_rate64\n   print g, 'CURRENT COUNT(64bit)=', count64\n\n   call system_clock(count32, count_rate32, count_max32)\n   print g, 'COUNT_MAX(32bit)=', count_max32\n   print g, 'COUNT_RATE(32bit)=', count_rate32\n   print g, 'CURRENT COUNT(32bit)=', count32\n\n   print g, 'time some computation'\n   call system_clock(start64)\n\n   ! some code to time\n   sum = 0.0_wp\n   do i = -0, huge(0) - 1\n      sum = sum + sqrt(real(i))\n   end do\n   print g, 'SUM=', sum\n\n   call system_clock(finish64)\n\n   time_read = (finish64 - start64)/real(count_rate64, wp)\n   write (*, '(1x,a,1x,g0,1x,a)') 'time : ', time_read, ' seconds'\n\nend program demo_system_clock\n```\nResults:\n```text\n >  accuracy may vary with argument type!\n >  query all arguments\n >  COUNT_MAX(64bit)= 9223372036854775807\n >  COUNT_RATE(64bit)= 1000000000\n >  CURRENT COUNT(64bit)= 1105422387865806\n >  COUNT_MAX(32bit)= 2147483647\n >  COUNT_RATE(32bit)= 1000\n >  CURRENT COUNT(32bit)= 1105422387\n >  time some computation\n >  SUM= 66344288183024.266\n >  time :  6.1341038460000004  seconds\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**date_and_time**(3)](#date_and_time),\n[**cpu_time**(3)](#cpu_time)\n\n _fortran-lang intrinsic descriptions_\n",
  "TAN": "## tan\n\n### **Name**\n\n**tan** - \\[MATHEMATICS:TRIGONOMETRIC\\] Tangent function\n\n### **Synopsis**\n```fortran\nresult = tan(x)\n```\n```fortran\n elemental TYPE(kind=KIND) function tan(x)\n\n  TYPE(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n  - the **TYPE** of **x** may be _real_ or _complex_ of any supported kind\n  - The returned value will be of the same type and kind as the argument\n    **x**.\n\n### **Description**\n\n**tan** computes the tangent of **x**.\n\n### **Options**\n\n- **x**\n  : The angle in radians to compute the tangent of for _real_ input.\n    If **x** is of type _complex_, its real part is regarded as a value\n    in radians.\n\n### **Result**\n\n  The return value is the tangent of the value **x**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_tan\nuse, intrinsic :: iso_fortran_env, only : real_kinds, &\n& real32, real64, real128\nimplicit none\nreal(kind=real64) :: x = 0.165_real64\n     write(*,*)x, tan(x)\nend program demo_tan\n```\nResults:\n```text\n     0.16500000000000001       0.16651386310913616\n```\n### **Standard**\n\nFORTRAN 77 . For a complex argument, Fortran 2008 .\n\n### **See Also**\n\n[**atan**(3)](#atan),\n[**atan2**(3)](#atan2),\n[**cos**(3)](#cos),\n[**sin**(3)](#sin)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "TANH": "## tanh\n\n### **Name**\n\n**tanh** - \\[MATHEMATICS:TRIGONOMETRIC\\] Hyperbolic tangent function\n\n### **Synopsis**\n```fortran\n    result = tanh(x)\n```\n```fortran\n     elemental TYPE(kind=KIND) function tanh(x)\n\n      TYPE(kind=KIND),intent(in) :: x\n```\n### **Characteristics**\n\n - **x** may be _real_ or _complex_ and any associated kind supported by\n   the processor.\n - The returned value will be of the same type and kind as the argument.\n\n### **Description**\n\n**tanh** computes the hyperbolic tangent of **x**.\n\n### **Options**\n\n- **x**\n  : The value to compute the Hyperbolic tangent of.\n\n### **Result**\n\nReturns the hyperbolic tangent of **x**.\n\n  If **x** is _complex_, the imaginary part of the result is regarded as\n  a radian value.\n\n  If **x** is _real_, the return value lies in the range\n```\n      -1 <= tanh(x) <= 1.\n```\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_tanh\nuse, intrinsic :: iso_fortran_env, only : &\n& real_kinds, real32, real64, real128\nimplicit none\nreal(kind=real64) :: x = 2.1_real64\n   write(*,*)x, tanh(x)\nend program demo_tanh\n```\nResults:\n```text\n      2.1000000000000001       0.97045193661345386\n```\n### **Standard**\n\nFORTRAN 77 , for a complex argument Fortran 2008\n\n### **See Also**\n\n[**atanh**(3)](#atanh)\n\n### **Resources**\n\n- [Wikipedia:hyperbolic functions](https://en.wikipedia.org/wiki/Hyperbolic_functions)\n\n _fortran-lang intrinsic descriptions_\n",
  "THIS_IMAGE": "## this_image\n\n### **Name**\n\n**this_image** - \\[COLLECTIVE\\] Cosubscript index of this image\n\n### **Synopsis**\n\n```fortran\nresult = this_image() | = this_image(distance) | = this_image(coarray,dim)\n```\n```fortran\n   integer function this_image( distance ,coarray, dim )\n\n    type(TYPE(kind=**)),optional :: coarray[*]\n    integer,intent(in),optional  :: distance\n    integer,intent(in),optional  :: dim\n```\n### **Characteristics**\n\n - a kind designated as ** may be any supported kind for the type\n - **coarray** can be of any type. If **dim** is present it is required.\n - **distance** is not permitted together with **coarray**\n - if **dim** if present, coarray is required.\n\n### **Description**\n\n**this_image** returns the cosubscript for this image.\n\n### **Options**\n\n- **distance**\n  : Nonnegative scalar _integer_ (not permitted together with **coarray**).\n\n- **coarray**\n  : if **dim** present, required).\n\n- **dim**\n  : If present, **dim** shall be between one and the corank of **coarray**.\n\n### **Result**\n\nDefault integer. If **coarray** is not present, it is scalar; if **distance** is\nnot present or has value **0**, its value is the image index on the invoking\nimage for the current team, for values smaller or equal distance to the\ninitial team, it returns the image index on the ancestor team which has\na distance of **distance** from the invoking team. If **distance** is larger\nthan the distance to the initial team, the image index of the initial\nteam is returned. Otherwise when the **coarray** is present, if **dim** is not\npresent, a rank-1 array with corank elements is returned, containing the\ncosubscripts for **coarray** specifying the invoking image. If **dim** is\npresent, a scalar is returned, with the value of the **dim** element of\n**this_image(coarray)**.\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_this_image\nimplicit none\ninteger :: value[*]\ninteger :: i\n   value = this_image()\n   sync all\n   if (this_image() == 1) then\n      do i = 1, num_images()\n         write(*,'(2(a,i0))') 'value[', i, '] is ', value[i]\n      end do\n   endif\nend program demo_this_image\n```\nResults:\n```text\n   value[1] is 1\n```\n### **Standard**\n\nFortran 2008. With DISTANCE argument, TS 18508\n\n### **See Also**\n\n[**num\\_images**(3)](#num_images),\n[**image\\_index**(3)](#image_index)\n\n _fortran-lang intrinsic descriptions_\n",
  "TINY": "## tiny\n\n### **Name**\n\n**tiny** - \\[NUMERIC MODEL\\] Smallest positive number of a real kind\n\n### **Synopsis**\n```fortran\n    result = tiny(x)\n```\n```fortran\n     real(kind=KIND) function tiny(x)\n\n      real(kind=KIND) :: x\n```\n### **Characteristics**\n\n - **x** may be any _real_ scalar or array\n - the result has the same type and kind as **x**\n\n### **Description**\n\n  **tiny** returns the smallest positive (non zero) number of the\n  type and kind of **x**.\n\n  For real **x**\n```fortran\n   result = 2.0**(minexponent(x)-1)\n```\n### **Options**\n\n- **x**\n  : The value whose kind is used to determine the model type to query\n\n### **Result**\n\n  The smallest positive value for the _real_ type of the specified kind.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_tiny\nimplicit none\n   print *, 'default real is from', tiny(0.0), 'to',huge(0.0)\n   print *, 'doubleprecision is from ', tiny(0.0d0), 'to',huge(0.0d0)\nend program demo_tiny\n```\nResults:\n\n```text\n default real is from 1.17549435E-38 to 3.40282347E+38\n doubleprecision is from 2.2250738585072014E-308 to\n 1.7976931348623157E+308\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**digits**(3)](#digits),\n[**epsilon**(3)](#epsilon),\n[**exponent**(3)](#exponent),\n[**fraction**(3)](#fraction),\n[**huge**(3)](#huge),\n[**maxexponent**(3)](#maxexponent),\n[**minexponent**(3)](#minexponent),\n[**nearest**(3)](#nearest),\n[**precision**(3)](#precision),\n[**radix**(3)](#radix),\n[**range**(3)](#range),\n[**rrspacing**(3)](#rrspacing),\n[**scale**(3)](#scale),\n[**set_exponent**(3)](#set_exponent),\n[**spacing**(3)](#spacing)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "TRAILZ": "## trailz\n\n### **Name**\n\n**trailz** - \\[BIT:COUNT\\] Number of trailing zero bits of an integer\n\n### **Synopsis**\n```fortran\n result = trailz(i)\n```\n```fortran\n  elemental integer function trailz(i)\n\n   integer(kind=**),intent(in) :: i\n```\n### **Characteristics**\n\n - **i** is an _integer_ of any kind.\n - the result is an _integer_ of default kind\n\n### **Description**\n\n  **trailz** returns the number of trailing zero bits of an _integer_\n  value.\n\n### **Options**\n\n- **i**\n  : the value to count trailing zero bits in\n\n### **Result**\n  The number of trailing rightmost zero bits in an _integer_ value after\n  the last non-zero bit.\n```text\n       >      right-most non-zero bit\n       >                 V\n       >  |0|0|0|1|1|1|0|1|0|0|0|0|0|0|\n       >  ^               |___________| trailing zero bits\n       >   bit_size(i)\n```\n  If all the bits of **i** are zero, the result is the size of the input\n  value in bits, ie. **bit_size(i)**.\n\n  The result may also be seen as the position of the rightmost 1 bit\n  in **i**, starting with the rightmost bit being zero and counting to\n  the left.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_trailz\n\n! some common integer kinds\nuse, intrinsic :: iso_fortran_env, only : &\n & integer_kinds, int8, int16, int32, int64\n\nimplicit none\n\n! a handy format\ncharacter(len=*),parameter :: &\n & show = '(1x,\"value=\",i4,\", value(bits)=\",b32.32,1x,\", trailz=\",i3)'\n\ninteger(kind=int64) :: bigi\n  ! basics\n   write(*,*)'Note default integer is',bit_size(0),'bits'\n   print  show,  -1, -1,  trailz(-1)\n   print  show,   0,  0,  trailz(0)\n   print  show,   1,  1,  trailz(1)\n   print  show,  96, 96,  trailz(96)\n  ! elemental\n   print *, 'elemental and any integer kind:'\n   bigi=2**5\n   write(*,*) trailz( [ bigi, bigi*256, bigi/2 ] )\n   write(*,'(1x,b64.64)')[ bigi, bigi*256, bigi/2 ]\n\nend program demo_trailz\n```\nResults:\n```text\n    Note default integer is          32 bits\n    value=  -1, value(bits)=11111111111111111111111111111111 , trailz=  0\n    value=   0, value(bits)=00000000000000000000000000000000 , trailz= 32\n    value=   1, value(bits)=00000000000000000000000000000001 , trailz=  0\n    value=  96, value(bits)=00000000000000000000000001100000 , trailz=  5\n    elemental and any integer kind:\n              5          13           4\n    0000000000000000000000000000000000000000000000000000000000100000\n    0000000000000000000000000000000000000000000000000010000000000000\n    0000000000000000000000000000000000000000000000000000000000010000\n```\n### **Standard**\n\n  Fortran 2008\n\n### **See Also**\n\n[**bit_size**(3)](#bit_size),\n[**popcnt**(3)](#popcnt),\n[**poppar**(3)](#poppar),\n[**leadz**(3)](#leadz)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "TRANSFER": "## transfer\n\n### **Name**\n\n**transfer** - \\[TYPE:MOLD\\] Transfer bit patterns\n\n### **Synopsis**\n```fortran\n    result = transfer(source, mold [,size] )\n```\n```fortran\n     type(TYPE(kind=KIND)) function transfer(source,mold,size)\n\n      type(TYPE(kind=KIND)),intent(in) :: source(..)\n      type(TYPE(kind=KIND)),intent(in) :: mold(..)\n      integer(kind=**),intent(in),optional :: size\n```\n### **Characteristics**\n\n- **source** shall be a scalar or an array of any type.\n- **mold** shall be a scalar or an array of any type.\n- **size** shall be a scalar of type _integer_.\n- **result** has the same type as **mold**\n\n### **Description**\n\n**transfer** copies the bitwise representation of **source** in memory\ninto a variable or array of the same type and type parameters as **mold**.\n\nThis is approximately equivalent to the C concept of \"casting\" one type\nto another.\n\n### **Options**\n\n- **source**\n  : Holds the bit pattern to be copied\n\n- **mold**\n  : the type of **mold** is used to define the type of the returned\n  value. In addition, if it is an array the returned value is a\n  one-dimensional array. If it is a scalar the returned value is a scalar.\n\n- **size**\n  : If **size** is present, the result is a one-dimensional array of\n    length **size**.\n\nIf **size** is absent but **mold** is an array (of any size or\nshape), the result is a one-dimensional array of the minimum length\nneeded to contain the entirety of the bitwise representation of **source**.\n\nIf **size** is absent and **mold** is a scalar, the result is a scalar.\n\n### **Result**\n\nThe result has the bit level representation of **source**.\n\nIf the bitwise representation of the result is longer than that of\n**source**, then the leading bits of the result correspond to those of\n**source** but any trailing bits are filled arbitrarily.\n\nWhen the resulting bit representation does not correspond to a valid\nrepresentation of a variable of the same type as **mold**, the results are\nundefined, and subsequent operations on the result cannot be guaranteed to\nproduce sensible behavior. For example, it is possible to create _logical_\nvariables for which **var** and .not. var both appear to be true.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_transfer\nuse,intrinsic :: iso_fortran_env, only : int32, real32\ninteger(kind=int32) :: i = 2143289344\nreal(kind=real32)   :: x\ncharacter(len=10)   :: string\ncharacter(len=1)    :: chars(10)\n   x=transfer(i, 1.0)    ! prints \"nan\" on i686\n   ! the bit patterns are the same\n   write(*,'(b0,1x,g0)')x,x ! create a NaN\n   write(*,'(b0,1x,g0)')i,i\n\n   ! a string to an array of characters\n   string='abcdefghij'\n   chars=transfer(string,chars)\n   write(*,'(*(\"[\",a,\"]\":,1x))')string\n   write(*,'(*(\"[\",a,\"]\":,1x))')chars\nend program demo_transfer\n```\n\nResults:\n\n```text\n   1111111110000000000000000000000 NaN\n   1111111110000000000000000000000 2143289344\n   [abcdefghij]\n   [a] [b] [c] [d] [e] [f] [g] [h] [i] [j]\n```\n\n### **Comments**\n\n_Joe Krahn_: Fortran uses **molding** rather than **casting**.\n\nCasting, as in C, is an in-place reinterpretation. A cast is a device\nthat is built around an object to change its shape.\n\nFortran **transfer** reinterprets data out-of-place. It can be\nconsidered **molding** rather than casting. A **mold** is a device that\nconfers a shape onto an object placed into it.\n\nThe advantage of molding is that data is always valid in the context\nof the variable that holds it. For many cases, a decent compiler should\noptimize **transfer** into a simple assignment.\n\nThere are disadvantages of this approach. It is problematic to define a\nunion of data types because you must know the largest data object, which\ncan vary by compiler or compile options. In many cases, an _EQUIVALENCE_\nwould be far more effective, but Fortran Standards committees seem\noblivious to the benefits of _EQUIVALENCE_ when used sparingly.\n\n### **Standard**\n\nFortran 90\n\n### **See also**\n\n[****(3)](#)\n\n _fortran-lang intrinsic descriptions_\n",
  "TRANSPOSE": "## transpose\n\n### **Name**\n\n**transpose** - \\[ARRAY:MANIPULATION\\] Transpose an array of rank two\n\n### **Synopsis**\n```fortran\n    result = transpose(matrix)\n```\n```fortran\n     function transpose(matrix)\n\n      type(TYPE(kind=KIND))            :: transpose(N,M)\n      type(TYPE(kind=KIND)),intent(in) :: matrix(M,N)\n```\n### **Characteristics**\n\n  - **matrix** is an array of any type with a rank of two.\n  - The result will be the same type and kind as **matrix** and the\n    reversed shape of the input array\n\n### **Description**\n\n  **transpose** transposes an array of rank two.\n\n  An array is transposed by interchanging the rows and columns of the\n  given matrix. That is, element (i,j) of the result has the value of\n  element (j,i) of the input for all (i,j).\n\n### **Options**\n\n- **matrix**\n  : The array to transpose\n\n### **Result**\n\nThe transpose of the input array. The result has the same type as\n**matrix**, and has shape \\[ m, n \\] if **matrix** has shape \\[ n, m \\].\n\n### **Examples**\n\nSample program:\n```fortran\nprogram demo_transpose\nimplicit none\ninteger,save :: xx(3,5)= reshape([&\n    1,  2,  3,  4,  5,    &\n   10, 20, 30, 40, 50,    &\n   11, 22, 33, 44, -1055  &\n ],shape(xx),order=[2,1])\n\ncall print_matrix_int('xx array:',xx)\ncall print_matrix_int('xx array transposed:',transpose(xx))\n\ncontains\n\nsubroutine print_matrix_int(title,arr)\n! print small 2d integer arrays in row-column format\nimplicit none\ncharacter(len=*),intent(in)  :: title\ninteger,intent(in)           :: arr(:,:)\ninteger                      :: i\ncharacter(len=:),allocatable :: biggest\n   write(*,*)trim(title)  ! print title\n   biggest='           '  ! make buffer to write integer into\n   ! find how many characters to use for integers\n   write(biggest,'(i0)')ceiling(log10(max(1.0,real(maxval(abs(arr))))))+2\n   ! use this format to write a row\n   biggest='(\" > [\",*(i'//trim(biggest)//':,\",\"))'\n   ! print one row of array at a time\n   do i=1,size(arr,dim=1)\n      write(*,fmt=biggest,advance='no')arr(i,:)\n      write(*,'(\" ]\")')\n   enddo\nend subroutine print_matrix_int\n\nend program demo_transpose\n```\nResults:\n```\n    xx array:\n    > [     1,     2,     3,     4,     5 ]\n    > [    10,    20,    30,    40,    50 ]\n    > [    11,    22,    33,    44, -1055 ]\n    xx array transposed:\n    > [     1,    10,    11 ]\n    > [     2,    20,    22 ]\n    > [     3,    30,    33 ]\n    > [     4,    40,    44 ]\n    > [     5,    50, -1055 ]\n```\n### **Standard**\n\nFortran 95\n\n### **See also**\n\n- [**merge**(3)](#merge) - Merge variables\n- [**pack**(3)](#pack) - Pack an array into an array of rank one\n- [**spread**(3)](#spread) - Add a dimension and replicate data\n- [**unpack**(3)](#unpack) - Scatter the elements of a vector\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "TRIM": "## trim\n\n### **Name**\n\n**trim** - \\[CHARACTER:WHITESPACE\\] Remove trailing blank characters from a string\n\n### **Synopsis**\n```fortran\n    result = trim(string)\n```\n```fortran\n     character(len=:,kind=KIND) function trim(string)\n\n      character(len=*,kind=KIND),intent(in) :: string\n```\n### **Characteristics**\n\n - **KIND** can be any kind supported for the _character_ type.\n - The result has the same type and kind as the input argument **string**.\n\n### **Description**\n\n  **trim** removes trailing blank characters from a string.\n\n### **Options**\n\n- **string**\n  : A string to trim\n\n### **Result**\n\n  The result is the same as **string** except trailing blanks are removed.\n\n  If **string** is composed entirely of blanks or has zero length,\n  the result has zero length.\n\n### **Examples**\n\nSample program:\n\n```fortran\nprogram demo_trim\nimplicit none\ncharacter(len=:), allocatable :: str, strs(:)\ncharacter(len=*),parameter :: brackets='( *(\"[\",a,\"]\":,1x) )'\ninteger :: i\n\n   str='   trailing    '\n   print brackets, str,trim(str) ! trims it\n\n   str='   leading'\n   print brackets, str,trim(str) ! no effect\n\n   str='            '\n   print brackets, str,trim(str) ! becomes zero length\n   print *,  len(str), len(trim('               '))\n\n  ! array elements are all the same length, so you often\n  ! want to print them\n   strs=[character(len=10) :: \"Z\",\" a b c\",\"ABC\",\"\"]\n\n   write(*,*)'untrimmed:'\n   ! everything prints as ten characters; nice for neat columns\n   print brackets, (strs(i), i=1,size(strs))\n   print brackets, (strs(i), i=size(strs),1,-1)\n   write(*,*)'trimmed:'\n   ! everything prints trimmed\n   print brackets, (trim(strs(i)), i=1,size(strs))\n   print brackets, (trim(strs(i)), i=size(strs),1,-1)\n\nend program demo_trim\n```\nResults:\n```text\n    > [   trailing    ] [   trailing]\n    > [   leading] [   leading]\n    > [            ] []\n    >           12           0\n    >  untrimmed:\n    > [Z         ] [ a b c    ] [ABC       ] [          ]\n    > [          ] [ABC       ] [ a b c    ] [Z         ]\n    >  trimmed:\n    > [Z] [ a b c] [ABC] []\n    > [] [ABC] [ a b c] [Z]\n```\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\nFunctions that perform operations on character strings, return lengths\nof arguments, and search for certain arguments:\n\n- **Elemental:**\n  [**adjustl**(3)](#adjustl),\n  [**adjustr**(3)](#adjustr),\n  [**index**(3)](#index),\n  [**scan**(3)](#scan),\n  [**verify**(3)](#verify)\n\n- **Nonelemental:**\n  [**len_trim**(3)](#len_trim),\n  [**len**(3)](#len),\n  [**repeat**(3)](#repeat),\n  [**trim**](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "UBOUND": "## ubound\n\n### **Name**\n\n**ubound** - \\[ARRAY:INQUIRY\\] Upper dimension bounds of an array\n\n### **Synopsis**\n```fortran\n    result = ubound(array [,dim] [,kind] )\n```\n```fortran\n     elemental TYPE(kind=KIND) function ubound(array,dim,kind)\n\n      TYPE(kind=KIND),intent(in)           :: array\n      integer(kind=**),intent(in),optional :: dim\n      integer(kind=**),intent(in),optional :: kind\n```\n### **Characteristics**\n\n- **array** shall be assumed-rank or an array, of any type.\n  It cannot be an unallocated allocatable array or a pointer that is not associated.\n\n- **dim** shall be a scalar _integer_.\n  The corresponding actual argument shall not be an optional dummy\n  argument, a disassociated pointer, or an unallocated allocatable.\n\n- **kind** an _integer_ initialization expression indicating the kind\n  parameter of the result.\n\n- The return value is of type _integer_ and of kind **kind**. If **kind**\n  is absent, the return value is of default integer kind.\n  The result is scalar if **dim** is present; otherwise, the result is\n  an array of rank one and size n, where n is the rank of **array**.\n\n- a kind designated as ** may be any supported kind for the type\n\n### **Description**\n\n**ubound** returns the upper bounds of an array, or a single upper\nbound along the **dim** dimension.\n\n### **Options**\n\n- **array**\n  : The assumed-rank or array of any type whose upper bounds are to be\n    determined. If allocatable it must be allocated; if a pointer it must\n    be associated. If an assumed-size array, **dim** must be present.\n\n- **dim**\n  : a specific dimension of **array** to determine the bounds of.\n  If **dim** is absent, the result is an array of the upper bounds of\n  **array**. **dim** is required if **array** is an assumed-size array,\n  and in that case must be less than or equal to the rank of **array**.\n\n- **kind**\n  : indicates the kind parameter of the result. If absent, an _integer_\n  of the default kind is returned.\n\n### **Result**\n\nThe return value is of type _integer_ and of kind **kind**. If **kind**\nis absent, the return value is of default integer kind.\n\nIf **dim** is absent, the result is an array of the upper bounds of\neach dimension of the **array**.\n\nIf **dim** is present, the result is a scalar corresponding to the upper\nbound of the array along that dimension.\n\nIf **array** is an expression rather than a whole array or array\nstructure component, or if it has a zero extent along the relevant\ndimension, the upper bound is taken to be the number of elements along\nthe relevant dimension.\n\n  NOTE1\n  If ARRAY is assumed-rank and has rank zero, DIM cannot be present\n  since it cannot satisfy the requirement\n  **1 <=  DIM <= 0**.\n\n### **Examples**\n\nNote this function should not be used on assumed-size arrays or in any\nfunction without an explicit interface. Errors can occur if there is no\ninterface defined.\n\nSample program\n\n```fortran\n! program demo_ubound\nmodule m2_bounds\nimplicit none\n\ncontains\n\nsubroutine msub(arr)\n!!integer,intent(in) :: arr(*)  ! cannot be assumed-size array\ninteger,intent(in) :: arr(:)\n   write(*,*)'MSUB: LOWER=',lbound(arr),'UPPER=',ubound(arr), &\n   & 'SIZE=',size(arr)\nend subroutine msub\n\nend module m2_bounds\n!\nprogram demo_ubound\nuse m2_bounds, only : msub\nimplicit none\ninterface\n   subroutine esub(arr)\n   integer,intent(in) :: arr(:)\n   end subroutine esub\nend interface\ninteger :: arr(-10:10)\n   write(*,*)'MAIN: LOWER=',lbound(arr),'UPPER=',ubound(arr), &\n   & 'SIZE=',size(arr)\n   call csub()\n   call msub(arr)\n   call esub(arr)\ncontains\nsubroutine csub\n   write(*,*)'CSUB: LOWER=',lbound(arr),'UPPER=',ubound(arr), &\n   & 'SIZE=',size(arr)\nend subroutine csub\n\nend\n\nsubroutine esub(arr)\nimplicit none\ninteger,intent(in) :: arr(:)\n   ! WARNING: IF CALLED WITHOUT AN EXPLICIT INTERFACE\n   ! THIS WILL GIVE UNDEFINED ANSWERS (like 0,0,0)\n   write(*,*)'ESUB: LOWER=',lbound(arr),'UPPER=',ubound(arr), &\n   & 'SIZE=',size(arr)\nend subroutine esub\n!end program demo_ubound\n```\nResults:\n```text\n >  MAIN: LOWER=         -10 UPPER=          10 SIZE=          21\n >  CSUB: LOWER=         -10 UPPER=          10 SIZE=          21\n >  MSUB: LOWER=           1 UPPER=          21 SIZE=          21\n >  ESUB: LOWER=           1 UPPER=          21 SIZE=          21\n```\n### **Standard**\n\nFortran 95 , with KIND argument Fortran 2003\n\n### **See Also**\n\n#### Array inquiry:\n\n- [**size**(3)](#size) -  Determine the size of an array\n- [**rank**(3)](#rank) -  Rank of a data object\n- [**shape**(3)](#shape) -  Determine the shape of an array\n- [**lbound**(3)](#lbound) -  Lower dimension bounds of an array\n\n[**co\\_ubound**(3)](#ucobound),\n[**co\\_lbound**(3)](lcobound)\n\n#### State Inquiry:\n\n- [**allocated**(3)](#allocated) -  Status of an allocatable entity\n- [**is_contiguous**(3)](#is_contiguous) -  Test if object is contiguous\n\n#### Kind Inquiry:\n\n- [**kind**(3)](#kind) - Kind of an entity\n\n#### Bit Inquiry:\n\n- [**storage_size**(3)](#storage_size) - Storage size in bits\n- [**bit_size**(3)](#bit_size) -  Bit size inquiry function\n- [**btest**(3)](#btest) - Tests a bit of an _integer_ value.\n- [**lbound**(3)](#lbound),\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "UCOBOUND": "## ucobound\n\n### **Name**\n\n**ucobound** - \\[COLLECTIVE\\] Upper codimension bounds of an array\n\n### **Synopsis**\n```fortran\n    result = ucobound(coarray [,dim] [,kind] )\n```\n```fortran\n```\n### **Characteristics**\n\n### **Description**\n\n**ucobound** returns the upper cobounds of a coarray, or a single\nupper cobound along the **dim** codimension.\n\n### **Options**\n\n- **array**\n  : Shall be an coarray, of any type.\n\n- **dim**\n  : (Optional) Shall be a scalar _integer_.\n\n- **kind**\n  : (Optional) An _integer_ initialization expression indicating the kind\n  parameter of the result.\n\n### **Result**\n\nThe return value is of type _integer_ and of kind **kind**. If **kind** is absent,\nthe return value is of default integer kind. If **dim** is absent, the\nresult is an array of the lower cobounds of **coarray**. If **dim** is present,\nthe result is a scalar corresponding to the lower cobound of the array\nalong that codimension.\n\n### **Standard**\n\nFortran 2008\n\n### **See Also**\n\n[**lcobound**(3)](#lcobound),\n[**lbound**(3)](#lbound),\n[**ubound**(3)](#ubound)\n",
  "UNPACK": "## unpack\n\n### **Name**\n\n**unpack** - \\[ARRAY:CONSTRUCTION\\] Scatter the elements of a vector\ninto an array using a mask\n\n### **Synopsis**\n```fortran\n    result = unpack(vector, mask, field)\n```\n```fortran\n     type(TYPE(kind=KIND)) unpack(vector, mask, field)\n\n      type(TYPE(kind=KIND)),intent(in) :: vector(:)\n      logical,intent(in)               :: mask(..)\n      type(TYPE(kind=KIND)),intent(in) :: field(..)\n```\n### **Characteristics**\n\n - **vector** is a rank-one array of any type\n - **mask** is a logical array\n - **field** is the same type and type parameters as VECTOR conformable with **mask**.\n - The result is an array of the same type and type parameters as **vector**\n   and the same shape as **mask**.\n\n### **Description**\n\n**unpack** scatters the elements of **vector** into a copy of an\narray **field** of any rank using _.true._ values from **mask** in array\nelement order to specify placement of the **vector** values.\n\nSo a copy of **field** is generated with select elements replaced with\nvalues from **vector**. This allows for complex replacement patterns\nthat would be difficult when using array syntax or multiple assignment\nstatements, particularly when the replacements are conditional.\n\n### **Options**\n\n- **vector**\n  : New values to place into specified locations in **field**.\n  It shall have at least as many elements as **mask** has _.true._\n  values.\n\n- **mask**\n  : Shall be an array that specifies which values\n  in **field** are to be replaced with values from **vector**.\n\n- **field**\n  : The input array to be altered.\n\n### **Result**\n\n  The element of the result that corresponds to the ith true element\n  of **mask**, in array element order, has the value **vector(i)** for i =\n  1, 2, . . ., t, where t is the number of true values in **mask**. Each\n  other element has a value equal to **field* if **field* is scalar or to the\n  corresponding element of **field* if it is an array.\n\n  The resulting array corresponds to **field** with _.true._ elements\n  of **mask** replaced by values from **vector** in array element order.\n\n### **Examples**\nParticular values may be \"scattered\" to particular positions in an array by using\n```text\n                       1 0 0\n    If M is the array  0 1 0\n                       0 0 1\n\n    V is the array [1, 2, 3],\n                               . T .\n    and Q is the logical mask  T . .\n                               . . T\n    where \"T\" represents true and \".\" represents false, then the result of\n\n    UNPACK (V, MASK = Q, FIELD = M) has the value\n\n      1 2 0\n      1 1 0\n      0 0 3\n\n    and the result of UNPACK (V, MASK = Q, FIELD = 0) has the value\n\n      0 2 0\n      1 0 0\n      0 0 3\n```\n\nSample program:\n\n```fortran\nprogram demo_unpack\nimplicit none\nlogical,parameter :: T=.true., F=.false.\n\ninteger :: vector(2)  = [1,1]\n\n! mask and field must conform\ninteger,parameter :: r=2, c=2\nlogical :: mask(r,c)  = reshape([ T,F,F,T ],[2,2])\ninteger :: field(r,c) = 0, unity(2,2)\n\n   ! basic usage\n   unity = unpack( vector, mask, field )\n   call print_matrix_int('unity=', unity)\n\n   ! if FIELD is a scalar it is used to fill all the elements\n   ! not assigned to by the vector and mask.\n   call print_matrix_int('scalar field',         &\n   & unpack(                                     &\n   & vector=[ 1, 2, 3, 4 ],                      &\n   & mask=reshape([ T,F,T,F,F,F,T,F,T ], [3,3]), &\n   & field=0) )\n\ncontains\n\nsubroutine print_matrix_int(title,arr)\n! convenience routine:\n! just prints small integer arrays in row-column format\nimplicit none\ncharacter(len=*),intent(in)  :: title\ninteger,intent(in)           :: arr(:,:)\ninteger                      :: i\ncharacter(len=:),allocatable :: biggest\n\n   write(*,*)trim(title)\n   ! make buffer to write integer into\n   biggest='           '\n   ! find how many characters to use for integers\n   write(biggest,'(i0)')ceiling(log10(max(1.0,real(maxval(abs(arr))))))+2\n   ! use this format to write a row\n   biggest='(\"  [\",*(i'//trim(biggest)//':,\",\"))'\n   ! print one row of array at a time\n   do i=1,size(arr,dim=1)\n      write(*,fmt=biggest,advance='no')arr(i,:)\n      write(*,'(\" ]\")')\n   enddo\nend subroutine print_matrix_int\n\nend program demo_unpack\n```\nResults:\n\n```text\n   > unity=\n   >  [ 1, 0 ]\n   >  [ 0, 1 ]\n   > scalar field\n   >  [  1,  0,  3 ]\n   >  [  0,  0,  0 ]\n   >  [  2,  0,  4 ]\n```\n\n### **Standard**\n\nFortran 95\n\n### **See Also**\n\n[**merge**(3)](#merge),\n[**pack**(3)](#pack),\n[**spread**(3)](#spread)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n",
  "VERIFY": "## verify\n\n### **Name**\n\n**verify** - \\[CHARACTER:SEARCH\\] Position of a character in a string\nof characters that does not appear in a given set of characters.\n\n### **Synopsis**\n```fortran\n    result = verify(string, set [,back] [,kind] )\n```\n```fortran\n     elemental integer(kind=KIND) function verify(string,set,back,KIND)\n\n      character(len=*,kind=**),intent(in) :: string\n      character(len=*,kind=**),intent(in) :: set\n      logical,intent(in),optional :: back\n      integer,intent(in),optional :: KIND\n```\n### **Characteristics**\n\n - **string** and **set** must be of type _character_ and have the same kind for any\n   individual call, but that can be any supported _character_ kind.\n - **KIND** must be a constant _integer_ initialization expression and a\n   valid kind for the _integer_ type.\n - **back** shall be of type logical.\n - the kind of the returned value is the same as **kind** if\n   present. Otherwise a default _integer_ kind is returned.\n\n### **Description**\n\n  **verify** verifies that all the characters in **string** belong\n  to the set of characters in **set** by identifying the position of\n  the first character in the string that is not in the set.\n\n  This makes it easy to verify strings are all uppercase or lowercase,\n  follow a basic syntax, only contain printable characters, and many\n  of the conditions tested for with the C routines **isalnum**(3c),\n  **isalpha**(3c), **isascii**(3c), **isblank**(3c), **iscntrl**(3c),\n  **isdigit**(3c), **isgraph**(3c), **islower**(3c), **isprint**(3c),\n  **ispunct**(3c), **isspace**(3c), **isupper**(3c), and **isxdigit**(3c);\n  but for a string as well as an array of strings.\n\n### **Options**\n\n- **string**\n  : The string to search in for an unmatched character.\n\n- **set**\n  : The set of characters that must be matched.\n\n- **back**\n  : The direction to look for an unmatched character. The left-most\n  unmatched character position is returned unless **back** is present\n  and _.false._, which causes the position of the right-most unmatched\n  character to be returned instead of the left-most unmatched character.\n\n- **kind**\n  : An _integer_ initialization expression indicating the kind\n  parameter of the result.\n\n### **Result**\n\nIf all characters of **string** are found in **set**, the result is zero.\n\nIf **string** is of zero length a zero (0) is always returned.\n\nOtherwise, if an unmatched character is found\nThe position of the first or last (if **back** is _.false._) unmatched\ncharacter in **string** is returned, starting with position one on the\nleft end of the string.\n\n### **Examples**\n\n#### Sample program I:\n```fortran\nprogram demo_verify\nimplicit none\n! some useful character sets\ncharacter,parameter :: &\n & int*(*)   = '1234567890', &\n & low*(*)   = 'abcdefghijklmnopqrstuvwxyz', &\n & upp*(*)   = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ', &\n & punc*(*)  = \"!\"\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~\", &\n & blank*(*) = ' ', &\n & tab       = char(11), &\n & prnt*(*) = int//low//upp//blank//punc\n\ncharacter(len=:),allocatable :: string\ninteger :: i\n    print *, 'basics:'\n    print *, VERIFY ('ABBA', 'A')                ! has the value 2.\n    print *, VERIFY ('ABBA', 'A', BACK = .TRUE.) ! has the value 3.\n    print *, VERIFY ('ABBA', 'AB')               ! has the value 0.\n\n   print *,'find first non-uppercase letter'\n   ! will produce the location of \"d\", because there is no match in UPP\n   write(*,*) 'something unmatched',verify(\"ABCdEFG\", upp)\n\n   print *,'if everything is matched return zero'\n   ! will produce 0 as all letters have a match\n   write(*,*) 'everything matched',verify(\"ffoorrttrraann\", \"nartrof\")\n\n   print *,'easily categorize strings as uppercase, lowercase, ...'\n   ! easy C-like functionality but does entire strings not just characters\n   write(*,*)'isdigit 123?',verify(\"123\", int) == 0\n   write(*,*)'islower abc?',verify(\"abc\", low) == 0\n   write(*,*)'isalpha aBc?',verify(\"aBc\", low//upp) == 0\n   write(*,*)'isblank aBc dEf?',verify(\"aBc dEf\", blank//tab ) /= 0\n   ! check if all printable characters\n   string=\"aB;cde,fgHI!Jklmno PQRSTU vwxyz\"\n   write(*,*)'isprint?',verify(string,prnt) == 0\n   ! this now has a nonprintable tab character in it\n   string(10:10)=char(11)\n   write(*,*)'isprint?',verify(string,prnt) == 0\n\n   print *,'VERIFY(3) is very powerful using expressions as masks'\n   ! verify(3f) is often used in a logical expression\n   string=\" This is NOT all UPPERCASE \"\n   write(*,*)'all uppercase/spaces?',verify(string, blank//upp) == 0\n   string=\" This IS all uppercase \"\n   write(*,*) 'string=['//string//']'\n   write(*,*)'all uppercase/spaces?',verify(string, blank//upp) == 0\n\n  ! set and show complex string to be tested\n   string='  Check this out. Let me know  '\n   ! show the string being examined\n   write(*,*) 'string=['//string//']'\n   write(*,*) '        '//repeat(int,4) ! number line\n\n   ! the Fortran functions returns a position just not a logical like C\n   print *, 'returning a position not just a logical is useful'\n   ! which can be very useful for parsing strings\n   write(*,*)'first non-blank character',verify(string, blank)\n   write(*,*)'last non-blank character',verify(string, blank,back=.true.)\n   write(*,*)'first non-letter non-blank',verify(string,low//upp//blank)\n\n  !VERIFY(3) is elemental so you can check an array of strings in one call\n  print *, 'elemental'\n   ! are strings all letters (or blanks)?\n   write(*,*) 'array of strings',verify( &\n   ! strings must all be same length, so force to length 10\n   & [character(len=10) :: \"YES\",\"ok\",\"000\",\"good one\",\"Nope!\"], &\n   & low//upp//blank) == 0\n\n   ! rarer, but the set can be an array, not just the strings to test\n   ! you could do ISPRINT() this (harder) way :>\n   write(*,*)'isprint?',.not.all(verify(\"aBc\", [(char(i),i=32,126)])==1)\n   ! instead of this way\n   write(*,*)'isprint?',verify(\"aBc\",prnt) == 0\n\nend program demo_verify\n```\nResults:\n```text\n >  basics:\n >            2\n >            3\n >            0\n >  find first non-uppercase letter\n >  something unmatched           4\n >  if everything is matched return zero\n >  everything matched           0\n >  easily categorize strings as uppercase, lowercase, ...\n >  isdigit 123? T\n >  islower abc? T\n >  isalpha aBc? T\n >  isblank aBc dEf? T\n >  isprint? T\n >  isprint? F\n >  VERIFY(3) is very powerful using expressions as masks\n >  all uppercase/spaces? F\n >  string=[ This IS all uppercase ]\n >  all uppercase/spaces? F\n >  string=[  Check this out. Let me know  ]\n >          1234567890123456789012345678901234567890\n >  returning a position not just a logical is useful\n >  first non-blank character           3\n >  last non-blank character          29\n >  first non-letter non-blank          17\n >  elemental\n >  array of strings T T F T F\n >  isprint? T\n >  isprint? T\n```\n#### Sample program II:\n\nDetermine if strings are valid integer representations\n\n```fortran\nprogram fortran_ints\nimplicit none\ninteger :: i\ncharacter(len=*),parameter :: ints(*)=[character(len=10) :: &\n '+1 ', &\n '3044848 ', &\n '30.40 ', &\n 'September ', &\n '1 2 3', &\n '  -3000 ', &\n ' ']\n   ! show the strings to test\n   write(*,'(\"|\",*(g0,\"|\"))') ints\n   ! show if strings pass or fail the test done by isint(3f)\n   write(*,'(\"|\",*(1x,l1,8x,\"|\"))') isint(ints)\n\ncontains\n\nelemental function isint(line) result (lout)\n!\n! determine if string is a valid integer representation\n! ignoring trailing spaces and leading spaces\n!\ncharacter(len=*),parameter   :: digits='0123456789'\ncharacter(len=*),intent(in)  :: line\ncharacter(len=:),allocatable :: name\nlogical                      :: lout\n   lout=.false.\n   ! make sure at least two characters long to simplify tests\n   name=adjustl(line)//'  '\n   ! blank string\n   if( name == '' )return\n   ! allow one leading sign\n   if( verify(name(1:1),'+-') == 0 ) name=name(2:)\n   ! was just a sign\n   if( name == '' )return\n   lout=verify(trim(name), digits)  == 0\nend function isint\n\nend program fortran_ints\n```\nResults:\n```text\n|+1       |3044848  |30.40    |September|1 2 3    |  -3000  |         |\n| T       | T       | F       | F       | F       | T       | F       |\n```\n#### Sample program III:\n\nDetermine if strings represent valid Fortran symbol names\n\n```fortran\nprogram fortran_symbol_name\nimplicit none\ninteger :: i\ncharacter(len=*),parameter :: symbols(*)=[character(len=10) :: &\n 'A_ ', &\n '10 ', &\n 'September ', &\n 'A B', &\n '_A ', &\n ' ']\n\n   write(*,'(\"|\",*(g0,\"|\"))') symbols\n   write(*,'(\"|\",*(1x,l1,8x,\"|\"))') fortran_name(symbols)\n\ncontains\n\nelemental function fortran_name(line) result (lout)\n!\n! determine if a string is a valid Fortran name\n! ignoring trailing spaces (but not leading spaces)\n!\ncharacter(len=*),parameter   :: int='0123456789'\ncharacter(len=*),parameter   :: lower='abcdefghijklmnopqrstuvwxyz'\ncharacter(len=*),parameter   :: upper='ABCDEFGHIJKLMNOPQRSTUVWXYZ'\ncharacter(len=*),parameter   :: allowed=upper//lower//int//'_'\n\ncharacter(len=*),intent(in)  :: line\ncharacter(len=:),allocatable :: name\nlogical                      :: lout\n   name=trim(line)\n   if(len(name).ne.0)then\n      ! first character is alphameric\n      lout = verify(name(1:1), lower//upper) == 0  &\n       ! other characters are allowed in a symbol name\n       & .and. verify(name,allowed) == 0           &\n       ! allowable length\n       & .and. len(name) <= 63\n   else\n      lout = .false.\n   endif\nend function fortran_name\n\nend program fortran_symbol_name\n```\nResults:\n```text\n    |A_        |10        |September |A B       |_A        |          |\n    | T        | F        | T        | F        | F        | F        |\n```\n#### Sample program IV:\n\ncheck if string is of form NN-HHHHH\n\n```fortran\nprogram checkform\n! check if string is of form NN-HHHHH\nimplicit none\ncharacter(len=*),parameter :: int='1234567890'\ncharacter(len=*),parameter :: hex='abcdefABCDEF0123456789'\nlogical                    :: lout\ncharacter(len=80)          :: chars\n\n   chars='32-af43d'\n   lout=.true.\n\n   ! are the first two characters integer characters?\n   lout = lout.and.(verify(chars(1:2), int) == 0)\n\n   ! is the third character a dash?\n   lout = lout.and.(verify(chars(3:3), '-') == 0)\n\n   ! is remaining string a valid representation of a hex value?\n   lout = lout.and.(verify(chars(4:8), hex) == 0)\n\n   if(lout)then\n      write(*,*)trim(chars),' passed'\n   else\n      write(*,*)trim(chars),' failed'\n   endif\nend program checkform\n```\nResults:\n```text\n    32-af43d passed\n```\n#### Sample program V:\n\nexploring uses of elemental functionality and dusty corners\n\n```fortran\nprogram more_verify\nimplicit none\ncharacter(len=*),parameter :: &\n  & int='0123456789', &\n  & low='abcdefghijklmnopqrstuvwxyz', &\n  & upp='ABCDEFGHIJKLMNOPQRSTUVWXYZ', &\n  & blank=' '\n! note character variables in an array have to be of the same length\ncharacter(len=6) :: strings(3)=[\"Go    \",\"right \",\"home! \"]\ncharacter(len=2) :: sets(3)=[\"do\",\"re\",\"me\"]\n\n  ! elemental -- you can use arrays for both strings and for sets\n\n   ! check each string from right to left for non-letter/non-blank\n   write(*,*)'last non-letter',verify(strings,upp//low//blank,back=.true.)\n\n   ! even BACK can be an array\n   ! find last non-uppercase character in \"Howdy \"\n   ! and first non-lowercase in \"there \"\n   write(*,*) verify(strings(1:2),[upp,low],back=[.true.,.false.])\n\n   ! using a null string for a set is not well defined. Avoid it\n   write(*,*) 'null',verify(\"for tran \", \"\", .true.) ! 8,length of string?\n   ! probably what you expected\n   write(*,*) 'blank',verify(\"for tran \", \" \", .true.) ! 7,found 'n'\n\n   ! first character in  \"Go    \" not in \"do\",\n   ! and first letter in \"right \" not in \"ri\"\n   ! and first letter in \"home! \" not in \"me\"\n   write(*,*) verify(strings,sets)\n\nend program more_verify\n```\nResults:\n```text\n    > last non-letter 0 0 5\n    > 6 6\n    > null 9\n    > blank 8\n    > 1 2 1\n```\n### **Standard**\n\nFortran 95 , with **kind** argument - Fortran 2003\n\n### **See Also**\n\nFunctions that perform operations on character strings, return lengths\nof arguments, and search for certain arguments:\n\n- **Elemental:**\n  [**adjustl**(3)](#adjustl),\n  [**adjustr**(3)](#adjustr),\n  [**index**(3)](#index),\n  [**scan**(3)](#scan),\n\n- **Nonelemental:**\n  [**len_trim**(3)](#len_trim),\n  [**len**(3)](#len),\n  [**repeat**(3)](#repeat),\n  [**trim**(3)](#trim)\n\n _fortran-lang intrinsic descriptions (license: MIT) \\@urbanjost_\n"
}
